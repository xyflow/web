# React Flow Documentation

## What is React Flow?

 React Flow is a library that allows you to create interactive, node-based user interfaces: 
    flowcharts, diagrams, visual programming tools, and workflows inside your React applications. It supports theming, 
    custom nodes and edges, a library of shadcn UI components, and offers a large collection 
    of examples for rapid  development. Developers can leverage the React Flow Pro platform 
    for advanced features like real-time collaboration, complex layouts, 
    and enhanced performance, making it suitable for both simple and large-scale, 
    production-ready visual applications.## API Reference

import { ContentGrid, ContentGridItem } from '@xyflow/xy-ui';
import { BlogPostPreview } from 'xy-shared';

### API Reference

This reference attempts to document every function, hook, component, and type
exported by React Flow. If you are looking for guides and tutorials, please refer to our [learn section](/learn).

#### How to use this reference

We think that documentation should answer two broad
questions: "what is this thing?" and "how do I use it?"

To that end, our API reference aims to **concisely** answer that first question
and learn section goes into more detail on the second. If you find yourself clicking
around the reference wondering what the heck any of this means, maybe we have a
guide that can help you out!

<ContentGrid className="mt-8">
  <ContentGridItem route="/learn/customization/custom-nodes">
    <BlogPostPreview title="Custom nodes" intro="A powerful feature of React Flow is the ability to add custom nodes. Within your custom nodes you can render everything you want. You can define multiple source and target handles and render form inputs or charts for example. In this guide we will implement a node with an input field that updates some text in another part of the application." />
  </ContentGridItem>

  <ContentGridItem route="/learn/layouting/layouting">
    <BlogPostPreview title="Layouting" intro="We regularly get asked how to handle layouting in React Flow. While we could build some basic layouting into React Flow, we believe that you know your app's requirements best and with so many options out there we think it's better you choose the best right tool for the job. In this guide we'll look at four layouting libraries and how to use them." />
  </ContentGridItem>
</ContentGrid>

#### A note for our long-term users

If you're coming here from our old API pages things might look a bit different!
We've reorganized our documentation to make it easier to look things up if you
know what you're looking for. All our types, components, hooks, and util functions
get their own page now to help you find exactly what you need.

If you're new to React Flow or you're not sure where to look for something, take
a look at the section below.

#### A note for JavaScript users

React Flow is written in TypeScript, but we know that not everyone uses it. We
encourage developers to use the technology that works best for them, and
throughout our documentation there is a blend of TypeScript and JavaScript
examples.

For our API reference, however, we use TypeScript's syntax to document the types
of props and functions. Here's a quick crash course on how to read it:

• `?` means that the field or argument is optional.

• `<T>` in a type definition represents a generic type parameter. Like a function
argument but for types! The definition `type Array<T> = ...` means a type called
`Array` that takes a generic type parameter `T`.

• `<T>` when referring to a type is like "filling in" a generic type parameter.
It's like calling a function but for types! The type `Array<number>` is the
type `Array` with the generic type parameter `T` filled in with the type
`number`.

• `T | U` means that the type is either `T` or `U`: this is often called a
*union*.

• `T & U` means that the type is both `T` and `U`: this is often called an
*intersection*.

The TypeScript folks have their own
[handy guide for reading types](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html)
that you might find useful. If you're still stuck on something, feel free to
drop by our [Discord](https://discord.com/invite/RVmnytFmGW) and ask for help!

### The ReactFlowProvider component

### \<ReactFlowProvider />

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/components/ReactFlowProvider/index.tsx/#L9)

The `<ReactFlowProvider />` component is a
[context provider](https://react.dev/learn/passing-data-deeply-with-context#) that
makes it possible to access a flow's internal state outside of the
[`<ReactFlow />`](/api-reference/react-flow) component. Many of the hooks we
provide rely on this component to work.

```tsx
import { ReactFlow, ReactFlowProvider, useNodes } from '@xyflow/react'

export default function Flow() {
  return (
    <ReactFlowProvider>
      <ReactFlow nodes={...} edges={...} />
      <Sidebar />
    </ReactFlowProvider>
  )
}

function Sidebar() {
  // This hook will only work if the component it's used in is a child of a
  // <ReactFlowProvider />.
  const nodes = useNodes()

  return (
    <aside>
      {nodes.map((node) => (
        <div key={node.id}>
          Node {node.id} -
            x: {node.position.x.toFixed(2)},
            y: {node.position.y.toFixed(2)}
        </div>
      ))}
    </aside>
  )
}
```

#### Props

<APIDocs componentName="ReactFlowProvider" />

#### Notes

* If you're using a router and want your flow's state to persist across routes,
  it's vital that you place the `<ReactFlowProvider />` component *outside* of
  your router.
* If you have multiple flows on the same page you will need to use a separate
  `<ReactFlowProvider />` for each flow.

### The ReactFlow component

import { ReactFlowAPIProps } from '@/references/ReactFlow.props';

### \<ReactFlow />

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/container/ReactFlow/index.tsx/#L47)

The `<ReactFlow />` component is the heart of your React Flow application. It
renders your nodes and edges, handles user interaction, and can manage its own
state if used as an [uncontrolled flow](/learn/advanced-use/uncontrolled-flow).

```tsx
import { ReactFlow } from '@xyflow/react'

export default function Flow() {
  return <ReactFlow
    nodes={...}
    edges={...}
    onNodesChange={...}
    ...
  />
}
```

This component takes a lot of different props, most of which are optional. We've
tried to document them in groups that make sense to help you find your way.

#### Common props

These are the props you will most commonly use when working with React Flow. If
you are working with a controlled flow with custom nodes, you will likely use
almost all of these!

<ReactFlowAPIProps group="common" />

#### Viewport props

<ReactFlowAPIProps group="viewport" />

#### Edge props

<ReactFlowAPIProps group="edge" />

#### Event handlers

> \[!WARNING]
>
> It's important to remember to define any event handlers outside of your
> component or using React's `useCallback` hook. If you don't, this can cause
> React Flow to enter an infinite re-render loop!

##### General Events

<ReactFlowAPIProps group="generalEvents" />

##### Node Events

<ReactFlowAPIProps group="nodeEvents" />

##### Edge Events

<ReactFlowAPIProps group="edgeEvents" />

##### Connection Events

<ReactFlowAPIProps group="connectionEvents" />

##### Pane Events

<ReactFlowAPIProps group="paneEvents" />

##### Selection Events

<ReactFlowAPIProps group="selectionEvents" />

#### Interaction props

<ReactFlowAPIProps group="interaction" />

#### Connection line props

<ReactFlowAPIProps group="connectionLine" />

#### Keyboard props

React Flow let's you pass in a few different keyboard shortcuts as another way
to interact with your flow. We've tried to set up sensible defaults like using
backspace to delete any selected nodes or edges, but you can use these props to
set your own.

To disable any of these shortcuts, pass in `null` to the prop you want to
disable.

<ReactFlowAPIProps group="keyboard" />

#### Style props

Applying certain classes to elements rendered inside the canvas will change how
interactions are handled. These props let you configure those class names if you
need to.

<ReactFlowAPIProps group="style" />

#### Notes

* The props of this component get exported as `ReactFlowProps`

import { ApiReferenceSummary } from 'xy-shared/server';

### Components

<ApiReferenceSummary category="components" />

### The Background component

### \<Background />

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/additional-components/Background/Background.tsx)

The `<Background />` component makes it convenient to render different types of
backgrounds common in node-based UIs. It comes with three variants: `lines`,
`dots` and `cross`.

```jsx
import { useState } from 'react';
import { ReactFlow, Background, BackgroundVariant } from '@xyflow/react';

export default function Flow() {
  return (
    <ReactFlow defaultNodes={[...]} defaultEdges={[...]}>
      <Background color="#ccc" variant={BackgroundVariant.Dots} />
    </ReactFlow>
  );
}
```

#### Props

<APIDocs componentName="Background" />

#### Examples

##### Combining multiple backgrounds

It is possible to layer multiple `<Background />` components on top of one another
to create something more interesting. The following example shows how to render a
square grid accented every 10th line.

```tsx
import { ReactFlow, Background, BackgroundVariant } from '@xyflow/react';

import '@xyflow/react/dist/style.css';

export default function Flow() {
  return (
    <ReactFlow defaultNodes={[...]} defaultEdges={[...]}>
      <Background
        id="1"
        gap={10}
        color="#f1f1f1"
        variant={BackgroundVariant.Lines}
      />

      <Background
        id="2"
        gap={100}
        color="#ccc"
        variant={BackgroundVariant.Lines}
      />
    </ReactFlow>
  );
}
```

#### Notes

* When combining multiple `<Background />` components it's important to give each
  of them a unique `id` prop!

### The BaseEdge component

### \<BaseEdge />

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/components/Edges/BaseEdge.tsx)

The `<BaseEdge />` component gets used internally for all the edges. It can be
used inside a custom edge and handles the invisible helper edge and the edge label
for you.

```jsx
import { BaseEdge } from '@xyflow/react';

export function CustomEdge({ sourceX, sourceY, targetX, targetY, ...props }) {
  const [edgePath] = getStraightPath({
    sourceX,
    sourceY,
    targetX,
    targetY,
  });

  const { label, labelStyle, markerStart, markerEnd, interactionWidth } = props;

  return (
    <BaseEdge
      path={edgePath}
      label={label}
      labelStyle={labelStyle}
      markerEnd={markerEnd}
      markerStart={markerStart}
      interactionWidth={interactionWidth}
    />
  );
}
```

#### Props

<APIDocs componentName="BaseEdge" groupKeys="Omit<SVGAttributes<SVGPathElement>, 'd' | 'path' | 'markerStart' | 'markerEnd'>" />

#### Notes

* If you want to use an edge marker with the [`<BaseEdge />`](/api-reference/components/base-edge) component,
  you can pass the `markerStart` or `markerEnd` props passed to your custom edge
  through to the [`<BaseEdge />`](/api-reference/components/base-edge) component. You can see all the props
  passed to a custom edge by looking at the [`EdgeProps`](/api-reference/types/edge-props) type.

### The ControlButton component

### \<ControlButton />

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/additional-components/ControlButton.tsx)

You can add buttons to the control panel by using the `<ControlButton />` component
and pass it as a child to the [`<Controls />`](/api-reference/components/controls) component.

```jsx
import { MagicWand } from '@radix-ui/react-icons'
import { ReactFlow, Controls, ControlButton } from '@xyflow/react'

export default function Flow() {
  return (
    <ReactFlow nodes={[...]} edges={[...]}>
      <Controls>
        <ControlButton onClick={() => alert('Something magical just happened. ✨')}>
          <MagicWand />
        </ControlButton>
      </Controls>
    </ReactFlow>
  )
}
```

#### Props

The `<ControlButton />` component accepts any prop valid on a HTML `<button />`
element.

<APIDocs componentName="ControlButton" groupKeys="ButtonHTMLAttributes<HTMLButtonElement>" />

### The Controls component

### \<Controls />

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/additional-components/Controls/Controls.tsx)

The `<Controls />` component renders a small panel that contains convenient
buttons to zoom in, zoom out, fit the view, and lock the viewport.

```tsx
import { ReactFlow, Controls } from '@xyflow/react'

export default function Flow() {
  return (
    <ReactFlow nodes={[...]} edges={[...]}>
      <Controls />
    </ReactFlow>
  )
}
```

#### Props

For TypeScript users, the props type for the `<Controls />` component is exported
as `ControlProps`.

<APIDocs componentName="Controls" />

#### Notes

* To extend or customize the controls, you can use the [`<ControlButton />`](/api-reference/components/control-button)
  component

### The EdgeLabelRenderer component

### \<EdgeLabelRenderer />

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/components/EdgeLabelRenderer/index.tsx)

Edges are SVG-based. If you want to render more complex labels you can use the
`<EdgeLabelRenderer />` component to access a div based renderer. This component
is a portal that renders the label in a `<div />` that is positioned on top of
the edges. You can see an example usage of the component in the [edge label renderer](/examples/edges/edge-label-renderer)
example.

```jsx
import React from 'react';
import { getBezierPath, EdgeLabelRenderer, BaseEdge } from '@xyflow/react';

const CustomEdge = ({ id, data, ...props }) => {
  const [edgePath, labelX, labelY] = getBezierPath(props);

  return (
    <>
      <BaseEdge id={id} path={edgePath} />
      <EdgeLabelRenderer>
        <div
          style={{
            position: 'absolute',
            transform: `translate(-50%, -50%) translate(${labelX}px,${labelY}px)`,
            background: '#ffcc00',
            padding: 10,
            borderRadius: 5,
            fontSize: 12,
            fontWeight: 700,
          }}
          className="nodrag nopan"
        >
          {data.label}
        </div>
      </EdgeLabelRenderer>
    </>
  );
};

export default CustomEdge;
```

#### Props

<APIDocs componentName="EdgeLabelRenderer" />

#### Notes

* The `<EdgeLabelRenderer />` has no pointer events by default. If you want to
  add mouse interactions you need to set the style `pointerEvents: 'all'` and add
  the `nopan` class on the label or the element you want to interact with.

### The EdgeText component

### \<EdgeText />

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/components/Edges/EdgeText.tsx)

You can use the `<EdgeText />` component as a helper component to display text
within your custom edges.

```jsx
import { EdgeText } from '@xyflow/react';

export function CustomEdgeLabel({ label }) {
  return (
    <EdgeText
      x={100}
      y={100}
      label={label}
      labelStyle={{ fill: 'white' }}
      labelShowBg
      labelBgStyle={{ fill: 'red' }}
      labelBgPadding={[2, 4]}
      labelBgBorderRadius={2}
    />
  );
}
```

#### Props

For TypeScript users, the props type for the `<EdgeText />` component is exported
as `EdgeTextProps`.

<APIDocs componentName="EdgeText" groupKeys="Omit<SVGAttributes<SVGElement>, 'x' | 'y'>" />

Additionally, you may also pass any standard React HTML attributes such as `onClick`,
`className` and so on.

### The Handle component

### \<Handle />

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/components/Handle/index.tsx)

The `<Handle />` component is used in your [custom nodes](/learn/customization/custom-nodes)
to define connection points.

```jsx
import { Handle, Position } from '@xyflow/react';

export const CustomNode = ({ data }) => {
  return (
    <>
      <div style={{ padding: '10px 20px' }}>
        {data.label}
      </div>

      <Handle type="target" position={Position.Left} />
      <Handle type="source" position={Position.Right} />
    </>
  );
};
```

#### Props

For TypeScript users, the props type for the `<Handle />` component is exported
as `HandleProps`.

<APIDocs componentName="Handle" groupKeys="Omit<ComponentProps<'div'>, 'id'>" />

### The MiniMap component

### \<MiniMap />

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/additional-components/MiniMap/MiniMap.tsx)

The `<MiniMap />` component can be used to render an overview of your flow. It
renders each node as an SVG element and visualizes where the current viewport is
in relation to the rest of the flow.

```jsx
import { ReactFlow, MiniMap } from '@xyflow/react';

export default function Flow() {
  return (
    <ReactFlow nodes={[...]]} edges={[...]]}>
      <MiniMap nodeStrokeWidth={3} />
    </ReactFlow>
  );
}
```

#### Props

For TypeScript users, the props type for the `<MiniMap />` component is exported
as `MiniMapProps`.

<APIDocs componentName="MiniMap" groupKeys="Omit<HTMLAttributes<SVGSVGElement>, 'onClick'>" />

#### Examples

##### Making the mini map interactive

By default, the mini map is non-interactive. To allow users to interact with the
viewport by panning or zooming the minimap, you can set either of the `zoomable`
or `pannable` (or both!) props to `true`.

```jsx
import { ReactFlow, MiniMap } from '@xyflow/react';

export default function Flow() {
  return (
    <ReactFlow nodes={[...]]} edges={[...]]}>
      <MiniMap pannable zoomable />
    </ReactFlow>
  );
}
```

##### Implement a custom mini map node

It is possible to pass a custom component to the `nodeComponent` prop to change
how nodes are rendered in the mini map. If you do this you **must** use only
SVG elements in your component if you want it to work correctly.

```jsx
import { ReactFlow, MiniMap } from '@xyflow/react';

export default function Flow() {
  return (
    <ReactFlow nodes={[...]]} edges={[...]]}>
      <MiniMap nodeComponent={MiniMapNode} />
    </ReactFlow>
  );
}

function MiniMapNode({ x, y }) {
  return <circle cx={x} cy={y} r="50" />;
}
```

Check out the documentation for [`MiniMapNodeProps`](/api-reference/types/mini-map-node-props)
to see what props are passed to your custom component.

##### Customising mini map node color

The `nodeColor`, `nodeStrokeColor`, and `nodeClassName` props can be a function
that takes a [`Node`](/api-reference/types/node) and computes a value for the prop. This can
be used to customize the appearance of each mini map node.

This example shows how to color each mini map node based on the node's type:

```jsx
import { ReactFlow, MiniMap } from '@xyflow/react';

export default function Flow() {
  return (
    <ReactFlow nodes={[...]]} edges={[...]]}>
      <MiniMap nodeColor={nodeColor} />
    </ReactFlow>
  );
}

function nodeColor(node) {
  switch (node.type) {
    case 'input':
      return '#6ede87';
    case 'output':
      return '#6865A5';
    default:
      return '#ff0072';
  }
}
```

#### TypeScript

This component accepts a generic type argument of custom node types. See this
[section in our Typescript guide](/learn/advanced-use/typescript#nodetype-edgetype-unions) for more information.

```tsx
<MiniMap<CustomNodeType> nodeColor={nodeColor} />
```

### The NodeResizeControl component

### \<NodeResizeControl />

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/additional-components/NodeResizer/NodeResizeControl.tsx)

To create your own resizing UI, you can use the `NodeResizeControl` component where you can pass children (such as icons).

#### Props

For TypeScript users, the props type for the `<NodeResizeControl />` component is exported
as `ResizeControlProps`.

<APIDocs componentName="NodeResizeControl" />

### The NodeResizer component

import { RemoteCodeViewer } from 'xy-shared/server';

### \<NodeResizer />

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/additional-components/NodeResizer/NodeResizer.tsx)

The `<NodeResizer />` component can be used to add a resize functionality to your
nodes. It renders draggable controls around the node to resize in all directions.

```jsx
import { memo } from 'react';
import { Handle, Position, NodeResizer } from '@xyflow/react';

const ResizableNode = ({ data }) => {
  return (
    <>
      <NodeResizer minWidth={100} minHeight={30} />
      <Handle type="target" position={Position.Left} />
      <div style={{ padding: 10 }}>{data.label}</div>
      <Handle type="source" position={Position.Right} />
    </>
  );
};

export default memo(ResizableNode);
```

#### Props

For TypeScript users, the props type for the `<NodeResizer />` component is exported
as `NodeResizerProps`.

<APIDocs componentName="NodeResizer" />

#### Examples

Head over to the [example page](/examples/nodes/node-resizer) to see how this is done.

<RemoteCodeViewer route="examples/nodes/node-resizer" framework="react" />

##### Custom Resize Controls

To build custom resize controls, you can use the [NodeResizeControl](/api-reference/components/node-resize-control) component and customize it.

#### Notes

* Take a look at the docs for the [`NodeProps`](/api-reference/types/node-props) type or the
  guide on [custom nodes](/learn/customization/custom-nodes) to see how to
  implement your own nodes.

### The NodeToolbar component

### \<NodeToolbar />

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/additional-components/NodeToolbar/NodeToolbar.tsx)

This component can render a toolbar or tooltip to one side of a custom node. This
toolbar doesn't scale with the viewport so that the content is always visible.

```jsx
import { memo } from 'react';
import { Handle, Position, NodeToolbar } from '@xyflow/react';

const CustomNode = ({ data }) => {
  return (
    <>
      <NodeToolbar isVisible={data.toolbarVisible} position={data.toolbarPosition}>
        <button>delete</button>
        <button>copy</button>
        <button>expand</button>
      </NodeToolbar>

      <div style={{ padding: '10px 20px' }}>
        {data.label}
      </div>

      <Handle type="target" position={Position.Left} />
      <Handle type="source" position={Position.Right} />
    </>
  );
};

export default memo(CustomNode);
```

#### Props

For TypeScript users, the props type for the `<NodeToolbar />` component is exported
as `NodeToolbarProps`. Additionally, the `<NodeToolbar />` component accepts all props of the HTML `<div />`
element.

<APIDocs componentName="NodeToolbar" groupKeys="HTMLAttributes<HTMLDivElement>" />

#### Notes

* By default, the toolbar is only visible when a node is selected. If multiple
  nodes are selected it will not be visible to prevent overlapping toolbars or
  clutter. You can override this behavior by setting the `isVisible` prop to
  `true`.

### The Panel component

### \<Panel />

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/components/Panel/index.tsx)

The `<Panel />` component helps you position content above the viewport. It is
used internally by the [`<MiniMap />`](/api-reference/components/minimap) and [`<Controls />`](/api-reference/components/controls)
components.

```jsx
import { ReactFlow, Panel } from '@xyflow/react';

export default function Flow() {
  return (
    <ReactFlow nodes={[...]} fitView>
      <Panel position="top-left">top-left</Panel>
      <Panel position="top-center">top-center</Panel>
      <Panel position="top-right">top-right</Panel>
      <Panel position="bottom-left">bottom-left</Panel>
      <Panel position="bottom-center">bottom-center</Panel>
      <Panel position="bottom-right">bottom-right</Panel>
      <Panel position="center-left">center-left</Panel>
      <Panel position="center-right">center-right</Panel>
    </ReactFlow>
  );
}
```

#### Props

For TypeScript users, the props type for the `<Panel />` component is exported
as `PanelProps`. Additionally, the `<Panel />` component accepts all props of the HTML `<div />`
element.

<APIDocs componentName="Panel" groupKeys="ComponentProps<'div'>" />

### The ViewportPortal component

### \<ViewportPortal />

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/components/ViewportPortal/index.tsx)

`<ViewportPortal />` component can be used to add components to the same viewport of the flow where nodes and edges are rendered.
This is useful when you want to render your own components that adhere to the same coordinate system as the nodes & edges and are also
affected by zooming and panning

```jsx
import React from 'react';
import { ViewportPortal } from '@xyflow/react';

export default function () {
  return (
    <ViewportPortal>
      <div
        style={{ transform: 'translate(100px, 100px)', position: 'absolute' }}
      >
        This div is positioned at [100, 100] on the flow.
      </div>
    </ViewportPortal>
  );
}
```

#### Props

<APIDocs componentName="ViewportPortal" />

import { ApiReferenceSummary } from 'xy-shared/server';

### Hooks

<ApiReferenceSummary category="hooks" />

### useConnection()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useConnection.ts)

The `useConnection` hook returns the current connection state when there is an active connection interaction. If no connection interaction is active, it returns `null` for every property. A typical use case for this hook is to colorize handles based on a certain condition (e.g. if the connection is valid or not).

```tsx
import { useConnection } from '@xyflow/react';

export default function App() {
  const connection = useConnection();

  return (
    <div>
      {connection ? `Someone is trying to make a connection from ${connection.fromNode} to this one.` : 'There are currently no incoming connections!'}
    </div>
  );
}
```

#### Signature

<APIDocs functionName="useConnection" />

### useEdgesState()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useNodesEdgesState.ts)

This hook makes it easy to prototype a controlled flow where you manage the
state of nodes and edges outside the `ReactFlowInstance`. You can think of it
like React's `useState` hook with an additional helper callback.

```jsx
import { ReactFlow, useNodesState, useEdgesState } from '@xyflow/react';

const initialNodes = [];
const initialEdges = [];

export default function () {
  const [nodes, setNodes, onNodesChange] = useNodesState(initialNodes);
  const [edges, setEdges, onEdgesChange] = useEdgesState(initialEdges);

  return (
    <ReactFlow
      nodes={nodes}
      edges={edges}
      onNodesChange={onNodesChange}
      onEdgesChange={onEdgesChange}
    />
  );
}
```

#### Signature

<APIDocs functionName="useEdgesState" />

#### TypeScript

This hook accepts a generic type argument of custom edge types. See this
[section in our TypeScript guide](/learn/advanced-use/typescript#nodetype-edgetype-unions) for more information.

```tsx
const nodes = useEdgesState<CustomEdgeType>();
```

#### Notes

* This hook was created to make prototyping easier and our documentation
  examples clearer. Although it is OK to use this hook in production, in
  practice you may want to use a more sophisticated state management solution
  like [Zustand](/docs/guides/state-management/) instead.

### useEdges()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useEdges.ts)

This hook returns an array of the current edges. Components that use this hook
will re-render **whenever any edge changes**.

```jsx
import { useEdges } from '@xyflow/react';

export default function () {
  const edges = useEdges();

  return <div>There are currently {edges.length} edges!</div>;
}
```

#### Signature

<APIDocs functionName="useEdges" />

#### TypeScript

This hook accepts a generic type argument of custom edge types. See this
[section in our TypeScript guide](/learn/advanced-use/typescript#nodetype-edgetype-unions) for more information.

```tsx
const nodes = useEdges<CustomEdgeType>();
```

#### Notes

* Relying on `useEdges` unnecessarily can be a common cause of performance
  issues. Whenever any edge changes, this hook will cause the component to
  re-render. Often we actually care about something more specific, like when
  the *number* of edges changes: where possible try to use
  [`useStore`](/api-reference/hooks/use-store) instead.

### useHandleConnections()

> \[!WARNING]
>
> `useHandleConnections` is deprecated in favor of the more capable
> [useNodeConnections](/api-reference/hooks/use-node-connections).

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useHandleConnections.ts)

This hook returns an array connections on a specific handle or handle type.

```jsx
import { useHandleConnections } from '@xyflow/react';

export default function () {
  const connections = useHandleConnections({ type: 'target', id: 'my-handle' });

  return (
    <div>There are currently {connections.length} incoming connections!</div>
  );
}
```

#### Signature

<APIDocs functionName="useHandleConnections" />

### useInternalNode()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useInternalNode.ts)

This hook returns the internal representation of a specific node. Components that use this hook
will re-render **whenever any node changes**, including when a node is selected
or moved.

```jsx
import { useInternalNode } from '@xyflow/react';

export default function () {
  const internalNode = useInternalNode('node-1');
  const absolutePosition = internalNode.internals.positionAbsolute;

  return (
    <div>
      The absolute position of the node is at:
      <p>x: {absolutePosition.x}</p>
      <p>y: {absolutePosition.y}</p>
    </div>
  );
}
```

#### Signature

<APIDocs functionName="useInternalNode" />

#### TypeScript

This hook accepts a generic type argument of custom node types. See this
[section in our TypeScript guide](/learn/advanced-use/typescript#nodetype-edgetype-unions) for more information.

```tsx
const internalNode = useInternalNode<CustomNodeType>();
```

### useKeyPress()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useKeyPress.ts)

This hook lets you listen for specific key codes and tells you whether they are
currently pressed or not.

```jsx
import { useKeyPress } from '@xyflow/react';

export default function () {
  const spacePressed = useKeyPress('Space');
  const cmdAndSPressed = useKeyPress(['Meta+s', 'Strg+s']);

  return (
    <div>
      {spacePressed && <p>Space pressed!</p>}
      {cmdAndSPressed && <p>Cmd + S pressed!</p>}
    </div>
  );
}
```

#### Signature

<APIDocs functionName="useKeyPress" />

#### Notes

* This hook does not rely on a `ReactFlowInstance` so you are free to use it
  anywhere in your app!

### useNodeConnections()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useNodeConnections.ts)

This hook returns an array of connections on a specific node, handle type ('source', 'target') or handle ID.

```jsx
import { useNodeConnections } from '@xyflow/react';

export default function () {
  const connections = useNodeConnections({
    handleType: 'target',
    handleId: 'my-handle',
  });

  return (
    <div>There are currently {connections.length} incoming connections!</div>
  );
}
```

#### Signature

<APIDocs functionName="useNodeConnections" />

### useNodeId()

[Source on Github](https://github.com/xyflow/xyflow/blob/v11/packages/core/src/contexts/NodeIdContext.ts/#L7)

You can use this hook to get the id of the node it is used inside. It is useful
if you need the node's id deeper in the render tree but don't want to manually
drill down the id as a prop.

```js
import { useNodeId } from '@xyflow/react';

export default function CustomNode() {
  return (
    <div>
      <span>This node has an id of </span>
      <NodeIdDisplay />
    </div>
  );
}

function NodeIdDisplay() {
  const nodeId = useNodeId();

  return <span>{nodeId}</span>;
}
```

#### Signature

<APIDocs functionName="useNodeId" />

#### Notes

* This hook should only be used within a custom node or its children.

### useNodesData()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useNodesData.ts)

This hook lets you subscribe to changes of a specific nodes `data` object.

```jsx
import { useNodesData } from '@xyflow/react';

export default function () {
  const nodeData = useNodesData('nodeId-1');

  const nodesData = useNodesData(['nodeId-1', 'nodeId-2']);
}
```

#### Signature

<APIDocs functionName="useNodesData" />

#### TypeScript

This hook accepts a generic type argument of custom node types. See this
[section in our TypeScript guide](/learn/advanced-use/typescript#nodetype-edgetype-unions) for more information.

```tsx
const nodesData = useNodesData<NodesType>(['nodeId-1', 'nodeId-2']);
```

### useNodesInitialized()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useNodesInitialized.ts)

This hook tells you whether all the nodes in a flow have been measured and given
a width and height. When you add a node to the flow, this hook will return
`false` and then `true` again once the node has been measured.

```jsx
import { useReactFlow, useNodesInitialized } from '@xyflow/react';
import { useEffect, useState } from 'react';

const options = {
  includeHiddenNodes: false,
};

export default function useLayout() {
  const { getNodes } = useReactFlow();
  const nodesInitialized = useNodesInitialized(options);
  const [layoutedNodes, setLayoutedNodes] = useState(getNodes());

  useEffect(() => {
    if (nodesInitialized) {
      setLayoutedNodes(yourLayoutingFunction(getNodes()));
    }
  }, [nodesInitialized]);

  return layoutedNodes;
}
```

#### Signature

<APIDocs functionName="useNodesInitialized" />

#### Notes

* This hook always returns `false` if the internal nodes array is empty.

### useNodesState()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useNodesEdgesState.ts)

This hook makes it easy to prototype a controlled flow where you manage the
state of nodes and edges outside the `ReactFlowInstance`. You can think of it
like React's `useState` hook with an additional helper callback.

```jsx
import { ReactFlow, useNodesState, useEdgesState } from '@xyflow/react';

const initialNodes = [];
const initialEdges = [];

export default function () {
  const [nodes, setNodes, onNodesChange] = useNodesState(initialNodes);
  const [edges, setEdges, onEdgesChange] = useEdgesState(initialEdges);

  return (
    <ReactFlow
      nodes={nodes}
      edges={edges}
      onNodesChange={onNodesChange}
      onEdgesChange={onEdgesChange}
    />
  );
}
```

#### Signature

<APIDocs functionName="useNodesState" />

#### TypeScript

This hook accepts a generic type argument of custom node types. See this
[section in our TypeScript guide](/learn/advanced-use/typescript#nodetype-edgetype-unions) for more information.

```tsx
const nodes = useNodesState<CustomNodeType>();
```

#### Notes

* This hook was created to make prototyping easier and our documentation
  examples clearer. Although it is OK to use this hook in production, in
  practice you may want to use a more sophisticated state management solution
  like [Zustand](/docs/guides/state-management/) instead.

### useNodes()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useNodes.ts)

This hook returns an array of the current nodes. Components that use this hook
will re-render **whenever any node changes**, including when a node is selected
or moved.

```jsx
import { useNodes } from '@xyflow/react';

export default function () {
  const nodes = useNodes();

  return <div>There are currently {nodes.length} nodes!</div>;
}
```

#### Signature

<APIDocs functionName="useNodes" />

#### TypeScript

This hook accepts a generic type argument of custom node types. See this
[section in our TypeScript guide](/learn/advanced-use/typescript#nodetype-edgetype-unions) for more information.

```tsx
const nodes = useNodes<CustomNodeType>();
```

#### Notes

* Relying on `useNodes` unnecessarily can be a common cause of performance
  issues. Whenever any node changes, this hook will cause the component to
  re-render. Often we actually care about something more specific, like when
  the *number* of nodes changes: where possible try to use
  [`useStore`](/api-reference/hooks/use-store) instead.

### useOnSelectionChange()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useOnSelectionChange.ts)

This hook lets you listen for changes to both node and edge selection. As the
name implies, the callback you provide will be called whenever the selection of
*either* nodes or edges changes.

> \[!WARNING]
>
> You need to memoize the passed `onChange` handler, otherwise the hook will not
> work correctly.

```jsx
import { useState } from 'react';
import { ReactFlow, useOnSelectionChange } from '@xyflow/react';

function SelectionDisplay() {
  const [selectedNodes, setSelectedNodes] = useState([]);
  const [selectedEdges, setSelectedEdges] = useState([]);

  // the passed handler has to be memoized, otherwise the hook will not work correctly
  const onChange = useCallback(({ nodes, edges }) => {
    setSelectedNodes(nodes.map((node) => node.id));
    setSelectedEdges(edges.map((edge) => edge.id));
  }, []);

  useOnSelectionChange({
    onChange,
  });

  return (
    <div>
      <p>Selected nodes: {selectedNodes.join(', ')}</p>
      <p>Selected edges: {selectedEdges.join(', ')}</p>
    </div>
  );
}
```

#### Signature

<APIDocs functionName="useOnSelectionChange" />

#### Notes

* This hook can only be used in a component that is a child of a
  [`<ReactFlowProvider />`](/api-reference/react-flow-provider) or a
  [`<ReactFlow />`](/api-reference/react-flow) component.

### useOnViewportChange()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useOnViewportChange.ts)

The `useOnViewportChange` hook lets you listen for changes to the viewport such
as panning and zooming. You can provide a callback for each phase of a viewport
change: `onStart`, `onChange`, and `onEnd`.

```tsx
import { useCallback } from 'react';
import { useOnViewportChange } from '@xyflow/react';

function ViewportChangeLogger() {
  useOnViewportChange({
    onStart: (viewport: Viewport) => console.log('start', viewport),
    onChange: (viewport: Viewport) => console.log('change', viewport),
    onEnd: (viewport: Viewport) => console.log('end', viewport),
  });

  return null;
}
```

#### Signature

<APIDocs functionName="useOnViewportChange" />

#### Notes

* This hook can only be used in a component that is a child of a
  [`<ReactFlowProvider />`](/api-reference/react-flow-provider) or a
  [`<ReactFlow />`](/api-reference/react-flow) component.

### useReactFlow()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useReactFlow.ts)

This hook returns a [`ReactFlowInstance`](/api-reference/types/react-flow-instance) that can
be used to update nodes and edges, manipulate the viewport, or query the current
state of the flow.

```jsx
import { useCallback, useState } from 'react';
import { useReactFlow } from '@xyflow/react';

export function NodeCounter() {
  const reactFlow = useReactFlow();
  const [count, setCount] = useState(0);
  const countNodes = useCallback(() => {
    setCount(reactFlow.getNodes().length);
    // you need to pass it as a dependency if you are using it with useEffect or useCallback
    // because at the first render, it's not initialized yet and some functions might not work.
  }, [reactFlow]);

  return (
    <div>
      <button onClick={countNodes}>Update count</button>
      <p>There are {count} nodes in the flow.</p>
    </div>
  );
}
```

#### Signature

<APIDocs functionName="useReactFlow" />

#### TypeScript

This hook accepts a generic type argument of custom node & edge types. See this
[section in our TypeScript guide](/learn/advanced-use/typescript#nodetype-edgetype-unions) for more information.

```tsx
const reactFlow = useReactFlow<CustomNodeType, CustomEdgeType>();
```

#### Notes

* This hook can only be used in a component that is a child of a
  [`<ReactFlowProvider />`](/api-reference/react-flow-provider) or a
  [`<ReactFlow />`](/api-reference/react-flow) component.
* Unlike [`useNodes`](/api-reference/hooks/use-nodes) or [`useEdges`](/api-reference/hooks/use-edges), this hook won't
  cause your component to re-render when state changes. Instead, you can query
  the state when you need it by using methods on the [`ReactFlowInstance`](/api-reference/types/react-flow-instance)
  this hook returns.

### useStoreApi()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useStore.ts)

In some cases, you might need to access the store directly. This hook returns the store object which can be used on demand to access the state or dispatch actions.

> \[!NOTE]
>
> This hook should only be used if there is no other way to access the internal
> state. For many of the common use cases, there are dedicated hooks available
> such as [`useReactFlow`](/api-reference/hooks/use-react-flow),
> [`useViewport`](/api-reference/hooks/use-viewport), etc.

```tsx
import { useState, useCallback } from 'react';
import { ReactFlow, useStoreApi } from '@xyflow/react';

const NodesLengthDisplay = () => {
  const [nodesLength, setNodesLength] = useState(0);
  const store = useStoreApi();

  const onClick = useCallback(() => {
    const { nodes } = store.getState();
    const length = nodes.length || 0;

    setNodesLength(length);
  }, [store]);

  return (
    <div>
      <p>The current number of nodes is: {nodesLength}</p>
      <button onClick={onClick}>Update node length.</button>
    </div>
  );
};

function Flow() {
  return (
    <ReactFlow nodes={nodes}>
      <NodesLengthLogger />
    </ReactFlow>
  );
}
```

This example computes the number of nodes in the flow *on-demand*. This is in
contrast to the example in the [`useStore`](/api-reference/hooks/use-store) hook that re-renders
the component whenever the number of nodes changes.

Choosing whether to calculate values on-demand or to subscribe to changes as they
happen is a bit of a balancing act. On the one hand, putting too many heavy
calculations in an event handler can make your app feel sluggish or unresponsive.
On the other hand, computing values eagerly can lead to slow or unnecessary
re-renders.

We make both this hook and [`useStore`](/api-reference/hooks/use-store) available so that you can
choose the approach that works best for your use-case.

#### Signature

<APIDocs functionName="useStoreApi" />

#### TypeScript

This hook accepts a generic type argument of custom node & edge types. See this
[section in our TypeScript guide](/learn/advanced-use/typescript#nodetype-edgetype-unions) for more information.

```tsx
const store = useStoreApi<CustomNodeType, CustomEdgeType>();
```

import { Callout } from 'nextra/components';

### useStore()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useStore.ts)

This hook can be used to subscribe to internal state changes of the React Flow
component. The `useStore` hook is re-exported from the [Zustand](https://github.com/pmndrs/zustand)
state management library, so you should check out their docs for more details.

<Callout type="info">
  This hook should only be used if there is no other way to access the internal
  state. For many of the common use cases, there are dedicated hooks available
  such as [`useReactFlow`](/api-reference/hooks/use-react-flow),
  [`useViewport`](/api-reference/hooks/use-viewport), etc.
</Callout>

```jsx
import { ReactFlow, useStore } from '@xyflow/react';

const nodesLengthSelector = (state) =>
  state.nodes.length || 0;

const NodesLengthDisplay = () => {
  const nodesLength = useStore(nodesLengthSelector);

  return <div>The current number of nodes is: {nodesLength}</div>;
};

function Flow() {
  return (
    <ReactFlow nodes={[...]}>
      <NodesLengthDisplay />
    </ReactFlow>
  );
}
```

This example computes the number of nodes eagerly. Whenever the number of nodes
in the flow changes, the `<NodesLengthDisplay />` component will re-render. This
is in contrast to the example in the [`useStoreApi`](/api-reference/hooks/use-store-api) hook that only
computes the number of nodes when a button is clicked.

Choosing whether to calculate values on-demand or to subscribe to changes as they
happen is a bit of a balancing act. On the one hand, putting too many heavy
calculations in an event handler can make your app feel sluggish or unresponsive.
On the other hand, computing values eagerly can lead to slow or unnecessary
re-renders.

We make both this hook and [`useStoreApi`](/api-reference/hooks/use-store-api) available so that you
can choose the approach that works best for your use-case.

#### Signature

<APIDocs functionName="useStore" />

#### Examples

##### Triggering store actions

You can manipulate the internal React Flow state by triggering internal actions
through the `useStore` hook. These actions are already used internally throughout
the library, but you can also use them to implement custom functionality.

```jsx
import { useStore } from '@xyflow/react';

const setMinZoomSelector = (state) => state.setMinZoom;

function MinZoomSetter() {
  const setMinZoom = useStore(setMinZoomSelector);

  return <button onClick={() => setMinZoom(6)}>set min zoom</button>;
}
```

#### TypeScript

This hook can be typed by typing the selector function. See this
[section in our TypeScript guide](/learn/advanced-use/typescript#nodetype-edgetype-unions) for more information.

```tsx
const nodes = useStore((s: ReactFlowState<CustomNodeType>) => s.nodes);
```

### useUpdateNodeInternals()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useUpdateNodeInternals.ts)

When you programmatically add or remove handles to a node or update a node's
handle position, you need to let React Flow know about it using this hook. This
will update the internal dimensions of the node and properly reposition handles
on the canvas if necessary.

```jsx
import { useCallback, useState } from 'react';
import { Handle, useUpdateNodeInternals } from '@xyflow/react';

export default function RandomHandleNode({ id }) {
  const updateNodeInternals = useUpdateNodeInternals();
  const [handleCount, setHandleCount] = useState(0);
  const randomizeHandleCount = useCallback(() => {
    setHandleCount(Math.floor(Math.random() * 10));
    updateNodeInternals(id);
  }, [id, updateNodeInternals]);

  return (
    <>
      {Array.from({ length: handleCount }).map((_, index) => (
        <Handle
          key={index}
          type="target"
          position="left"
          id={`handle-${index}`}
        />
      ))}

      <div>
        <button onClick={randomizeHandleCount}>Randomize handle count</button>
        <p>There are {handleCount} handles on this node.</p>
      </div>
    </>
  );
}
```

#### Signature

<APIDocs functionName="useUpdateNodeInternals" />

#### Notes

* This hook can only be used in a component that is a child of a
  [`<ReactFlowProvider />`](/api-reference/react-flow-provider) or a
  [`<ReactFlow />`](/api-reference/react-flow) component.

### useViewport()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/hooks/useViewport.ts)

The `useViewport` hook is a convenient way to read the current state of the
[`Viewport`](/api-reference/types/viewport) in a component. Components that use this hook
will re-render **whenever the viewport changes**.

```jsx
import { useViewport } from '@xyflow/react';

export default function ViewportDisplay() {
  const { x, y, zoom } = useViewport();

  return (
    <div>
      <p>
        The viewport is currently at ({x}, {y}) and zoomed to {zoom}.
      </p>
    </div>
  );
}
```

#### Signature

<APIDocs functionName="useViewport" />

#### Notes

* This hook can only be used in a component that is a child of a
  [`<ReactFlowProvider />`](/api-reference/react-flow-provider) or a
  [`<ReactFlow />`](/api-reference/react-flow) component.

import { ApiReferenceSummary } from 'xy-shared/server';

### Types

<ApiReferenceSummary category="types" />

### AriaLabelConfig

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/constants.ts/)

With the `AriaLabelConfig` you can customize the aria labels used by React Flow. This is useful if you want to translate the labels or if you want to change them to better suit your application.

#### Fields

<APIDocs typeName="AriaLabelConfig" packageName="react" />

#### Default config

```js
const defaultAriaLabelConfig = {
  'node.a11yDescription.default':
    'Press enter or space to select a node. Press delete to remove it and escape to cancel.',
  'node.a11yDescription.keyboardDisabled':
    'Press enter or space to select a node. You can then use the arrow keys to move the node around. Press delete to remove it and escape to cancel.',
  'node.a11yDescription.ariaLiveMessage': ({ direction, x, y }: { direction: string; x: number; y: number }) =>
    `Moved selected node ${direction}. New position, x: ${x}, y: ${y}`,
  'edge.a11yDescription.default':
    'Press enter or space to select an edge. You can then press delete to remove it or escape to cancel.',

  // Control elements
  'controls.ariaLabel': 'Control Panel',
  'controls.zoomIn.ariaLabel': 'Zoom In',
  'controls.zoomOut.ariaLabel': 'Zoom Out',
  'controls.fitView.ariaLabel': 'Fit View',
  'controls.interactive.ariaLabel': 'Toggle Interactivity',

  // Mini map
  'minimap.ariaLabel': 'Mini Map',

  // Handle
  'handle.ariaLabel': 'Handle',
};
```

### BackgroundVariant

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/additional-components/Background/types.ts)

The three variants are exported as an enum for convenience. You can either import
the enum and use it like `BackgroundVariant.Lines` or you can use the raw string
value directly.

```ts
export enum BackgroundVariant {
  Lines = 'lines',
  Dots = 'dots',
  Cross = 'cross',
}
```

### ColorMode

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/general.ts)

The `ColorMode` type defines the available color modes for the ReactFlow component. This can be used to control the theme of the flow diagram.

```ts
export type ColorMode = 'light' | 'dark' | 'system';
```

### ConnectionLineComponentProps

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/edges.ts/#L193)

If you want to render a custom component for connection lines, you can set the
`connectionLineComponent` prop on the
[`<ReactFlow />`](/api-reference/react-flow#connection-connectionLineComponent) component.
The `ConnectionLineComponentProps` are passed to your custom component.

#### Props

<APIDocs typeName="ConnectionLineComponentProps" />

### ConnectionLineComponent

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/edges.ts#L265)

The `ConnectionLineComponent` type allows you to provide a custom React component to render the connection line when users create new edges. The component receives `ConnectionLineComponentProps` as its props.

```ts
type ConnectionLineComponent = React.ComponentType<ConnectionLineComponentProps>;
```

### ConnectionLineType

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/edges.ts/#L62)

If you set the `connectionLineType` prop on your [`<ReactFlow />`](/api-reference/react-flow#connection-connectionLineType)
component, it will dictate the style of connection line rendered when creating
new edges.

```ts
export enum ConnectionLineType {
  Bezier = 'default',
  Straight = 'straight',
  Step = 'step',
  SmoothStep = 'smoothstep',
  SimpleBezier = 'simplebezier',
}
```

#### Notes

* If you choose to render a custom connection line component, this value will be
  passed to your component as part of its [`ConnectionLineComponentProps`](/api-reference/types/connection-line-component-props).

### ConnectionMode

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/general.ts#L68)

The `ConnectionMode` enum provides two options for connection behavior in React Flow:

* `Strict`: Connections can only be made starting from a source handle and ending on a target handle
* `Loose`: Connections can be made between any handles, regardless of type

```ts
enum ConnectionMode {
  Strict = 'strict',
  Loose = 'loose',
}
```

### ConnectionState

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/general.ts/#L148-L174)

The `ConnectionState` type bundles all information about an ongoing connection. It is returned by the [`useConnection`](/api-reference/hooks/use-connection) hook.

```ts
type NoConnection = {
  inProgress: false;
  isValid: null;
  from: null;
  fromHandle: null;
  fromPosition: null;
  fromNode: null;
  to: null;
  toHandle: null;
  toPosition: null;
  toNode: null;
};
type ConnectionInProgress = {
  inProgress: true;
  isValid: boolean | null;
  from: XYPosition;
  fromHandle: Handle;
  fromPosition: Position;
  fromNode: NodeBase;
  to: XYPosition;
  toHandle: Handle | null;
  toPosition: Position;
  toNode: NodeBase | null;
};

type ConnectionState = ConnectionInProgress | NoConnection;
```

#### Fields

<APIDocs typeName="ConnectionState" />

### Connection

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/general.ts/#L29-L34)

The `Connection` type is the basic minimal description of an
[`Edge`](/api-reference/types/edge) between two nodes. The
[`addEdge`](/api-reference/utils/add-edge) util can be used to upgrade a `Connection` to
an [`Edge`](/api-reference/types/edge).

#### Fields

<APIDocs typeName="Connection" />

### CoordinateExtent

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/utils.ts/#L36-L37)

A coordinate extent represents two points in a coordinate system: one in the top
left corner and one in the bottom right corner. It is used to represent the
bounds of nodes in the flow or the bounds of the viewport.

```ts
export type CoordinateExtent = [[number, number], [number, number]];
```

#### Notes

* Props that expect a `CoordinateExtent` usually default to `[[-∞, -∞], [+∞, +∞]]`
  to represent an unbounded extent.

### DefaultEdgeOptions

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/edges.ts/#L88-L89)

Many properties on an [`Edge`](/api-reference/types/edge) are optional. When a new edge is
created, the properties that are not provided will be filled in with the default values
passed to the `defaultEdgeOptions` prop of the
[`<ReactFlow />`](/api-reference/react-flow#defaultedgeoptions) component.

#### Fields

<APIDocs typeName="DefaultEdgeOptions" />

### DeleteElements

DeleteElements deletes provided nodes and edges and handles deleting any connected edges as well as child nodes. Returns successfully deleted edges and nodes asynchronously.

```ts
export type DeleteElements = (payload: {
  nodes?: (Partial<Node> & { id: Node['id'] })[];
  edges?: (Partial<Edge> & { id: Edge['id'] })[];
}) => Promise<{
  deletedNodes: Node[];
  deletedEdges: Edge[];
}>;
```

### EdgeChange

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/changes.ts/#L68-L72)

The [`onEdgesChange`](/api-reference/react-flow#on-edges-change) callback takes
an array of `EdgeChange` objects that you should use to update your flow's state.
The `EdgeChange` type is a union of four different object types that represent that
various ways an edge can change in a flow.

```ts
export type EdgeChange =
  | EdgeAddChange
  | EdgeRemoveChange
  | EdgeReplaceChange
  | EdgeSelectionChange;
```

#### Variants

##### EdgeAddChange

<APIDocs typeName="EdgeAddChange" />

##### EdgeRemoveChange

<APIDocs typeName="EdgeRemoveChange" />

##### EdgeReplaceChange

<APIDocs typeName="EdgeReplaceChange" />

##### EdgeSelectionChange

<APIDocs typeName="EdgeSelectionChange" />

### EdgeMarker

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/edges.ts/#L70-L78)

Edges can optionally have markers at the start and end of an edge. The `EdgeMarker` type
is used to configure those markers! Check the docs for
[`MarkerType`](/api-reference/types/marker-type) for details on what types of edge marker
are available.

#### Fields

<APIDocs typeName="EdgeMarker" />

### EdgeMouseHandler

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/edges.ts#L81)

The `EdgeMouseHandler` type defines the callback function that is called when mouse events occur on an edge. This callback receives the event and the edge that triggered it.

```ts
type EdgeMouseHandler = (event: React.MouseEvent, edge: Edge) => void;
```

<APIDocs typeName="EdgeMouseHandler" packageName="react" />

### EdgeProps

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/edges.ts/#L100)

When you implement a custom edge it is wrapped in a component that enables some basic
functionality. The `EdgeProps` type takes a generic parameter to specify the type of edges
you use in your application:

```ts
type AppEdgeProps = EdgeProps<MyEdgeType>;
```

Your custom edge component receives the following props:

#### Fields

<APIDocs typeName="EdgeProps" />

### EdgeTypes

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/general.ts#L76)

The `EdgeTypes` type is used to define custom edge types. Each key in the object represents an edge type, and the value is the component that should be rendered for that type.

```ts
export type EdgeTypes = {
  [key: string]: React.ComponentType<EdgeProps>;
};
```

### Edge

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/edges.ts/#L34-L353)

Where a [`Connection`](/api-reference/types/connection) is the minimal description of an edge between
two nodes, an `Edge` is the complete description with everything React Flow needs
to know in order to render it.

```ts
export type Edge<T> = DefaultEdge<T> | SmoothStepEdge<T> | BezierEdge<T>;
```

#### Variants

##### Edge

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/edges.ts/#L34-L353)

<APIDocs typeName="Edge" />

##### SmoothStepEdge

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/edges.ts/#L45-L46)

The `SmoothStepEdge` variant has all the same fields as an `Edge`, but it also has the following additional fields:

{/* type SmoothStepEdge isn't exported, and conflicts with SmoothStepEdge component name */}

<APIDocs
  code={`
type $ = {
type: "smoothstep"
pathOptions?: { offset?: number; borderRadius?: number }
}
export default $
`}
/>

##### BezierEdge

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/edges.ts/#L52-L53)

The `BezierEdge` variant has all the same fields as an `Edge`, but it also has the following additional fields:

{/* type BezierEdge isn't exported, and conflicts with BezierEdge component name */}

<APIDocs
  code={`
type $ = {
type: "default"
pathOptions?: { curvature?: number }
}
export default $
`}
/>

#### Default edge types

You can create any of React Flow's default edges by setting the `type` property
to one of the following values:

* `"default"`
* `"straight"`
* `"step"`
* `"smoothstep"`
* `"simplebezier"`

If you don't set the `type` property at all, React Flow will fallback to the
`"default"` bezier curve edge type.

These default edges are available even if you set the [`edgeTypes`](/api-reference/react-flow#edge-types)
prop to something else, unless you override any of these keys directly.

### FitViewOptions

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/general.ts/#L67-L68)

When calling [`fitView`](/api-reference/types/react-flow-instance#fitview) these options
can be used to customize the behavior. For example, the `duration` option can be used to
transform the viewport smoothly over a given amount of time.

#### Fields

<APIDocs typeName="FitViewOptions" />

### HandleConnection

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/general.ts/#L36-L37)

The `HandleConnection` type is an extension of a basic
[Connection](/api-reference/types/connection) that includes the `edgeId`.

#### Fields

<APIDocs typeName="HandleConnection" packageName="system" />

### Handle

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/handles.ts/#L5)

The `Handle` type represents the attributes of a handle.

#### Fields

<APIDocs typeName="Handle" packageName="system" />

### InternalNode

[Source on GitHub](https://github.com/xyflow/xyflow/blob/99985b52026cf4ac65a1033178cf8c2bea4e14fa/packages/system/src/types/nodes.ts#L68)

The `InternalNode` type is identical to the base [`Node`](/api-references/types/node) type
but is extended with some additional properties used internally by React Flow. Some
functions and callbacks that return nodes may return an `InternalNode`.

#### Fields

<APIDocs typeName="InternalNodeBase" packageName="system" />

### IsValidConnection

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/general.ts#L212)

The `IsValidConnection` type represents a function that validates whether a connection between nodes is allowed. It receives a [`Connection`](/api-reference/types/connection) and returns a boolean indicating whether the connection is valid and therefore should be created.

```ts
type IsValidConnection = (edge: Edge | Connection) => boolean;
```

<APIDocs typeName="IsValidConnection" packageName="react" />

### KeyCode

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/general.ts#L155)

The `KeyCode` type is used to specify keyboard key codes or combinations, such as deleting nodes or enabling multi-selection. It can be a single string or an array of strings representing key codes.

```ts
type KeyCode = string | Array<string>;
```

### MarkerType

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/edges.ts/#L82-L83)

Edges may optionally have a marker on either end. The MarkerType type enumerates
the options available to you when configuring a given marker.

```ts
export enum MarkerType {
  Arrow = 'arrow',
  ArrowClosed = 'arrowclosed',
}
```

### MiniMapNodeProps

[Source on GitHub](https://github.com/xyflow/xyflow/blob/487b13c9ad8903789f56c6fcfd8222f9cb74b812/packages/react/src/additional-components/MiniMap/types.ts/#L60)

The MiniMapNodeProps type defines the props for nodes in the MiniMap component. This is
only relevant if you pass a custom node type to the MiniMap.

#### Fields

<APIDocs typeName="MiniMapNodeProps" />

```
```

### NodeChange

[Source on GitHub](https://github.com/xyflow/xyflow/blob/487b13c9ad8903789f56c6fcfd8222f9cb74b812/packages/system/src/types/changes.ts/#L47)

The [`onNodesChange`](/api-reference/react-flow#on-nodes-change) callback takes
an array of `NodeChange` objects that you should use to update your flow's state.
The `NodeChange` type is a union of six different object types that represent that
various ways an node can change in a flow.

```ts
export type NodeChange =
  | NodeDimensionChange
  | NodePositionChange
  | NodeSelectionChange
  | NodeRemoveChange
  | NodeAddChange
  | NodeReplaceChange;
```

#### Variant types

##### NodeDimensionChange

<APIDocs typeName="NodeDimensionChange" />

##### NodePositionChange

<APIDocs typeName="NodePositionChange" />

##### NodeSelectionChange

<APIDocs typeName="NodeSelectionChange" />

##### NodeRemoveChange

<APIDocs typeName="NodeRemoveChange" />

##### NodeAddChange

<APIDocs typeName="NodeAddChange" />

##### NodeReplaceChange

<APIDocs typeName="NodeReplaceChange" />

### NodeConnection

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/general.ts/#L36-L37)

The `NodeConnection` type is an extension of a basic
[Connection](/api-reference/types/connection) that includes the `edgeId`.

#### Fields

<APIDocs typeName="NodeConnection" />

### NodeHandle

[Source on GitHub](https://github.com/xyflow/xyflow/blob/13897512d3c57e72c2e27b14ffa129412289d948/packages/system/src/types/nodes.ts#L139)

The `NodeHandle` type is used to define a handle for a node if server-side rendering is used. On the server, React Flow can't measure DOM nodes, so it's necessary to define the handle position dimensions.

<APIDocs typeName="NodeHandle" packageName="system" />

### NodeMouseHandler

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/nodes.tsL32)

The `NodeMouseHandler` type defines the callback function that is called when mouse events occur on a node. This callback receives the event and the node that triggered it.

```ts
export type NodeMouseHandler = (event: React.MouseEvent, node: Node) => void;
```

<APIDocs typeName="NodeMouseHandler" packageName="react" />

### NodeOrigin

The origin of a Node determines how it is placed relative to its own coordinates.
`[0, 0]` places it at the top left corner, `[0.5, 0.5]` right in the center and `[1, 1]` at the bottom right of its position.

```ts
export type NodeOrigin = [number, number];
```

### NodeProps

### NodeProps\<T>

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/nodes.ts/#L89)

When you implement a [custom node](/learn/customization/custom-nodes) it is wrapped in a
component that enables basic functionality like selection and dragging.

#### Usage

```tsx
import { useState } from 'react';
import { NodeProps, Node } from '@xyflow/react';

export type CounterNode = Node<
  {
    initialCount?: number;
  },
  'counter'
>;

export default function CounterNode(props: NodeProps<CounterNode>) {
  const [count, setCount] = useState(props.data?.initialCount ?? 0);

  return (
    <div>
      <p>Count: {count}</p>
      <button className="nodrag" onClick={() => setCount(count + 1)}>
        Increment
      </button>
    </div>
  );
}
```

Remember to register your custom node by adding it to the
[`nodeTypes`](/api-reference/react-flow#nodetypes) prop of your `<ReactFlow />` component.

```tsx
import { ReactFlow } from '@xyflow/react';
import CounterNode from './CounterNode';

const nodeTypes = {
  counterNode: CounterNode,
};

export default function App() {
  return <ReactFlow nodeTypes={nodeTypes} ... />
}
```

You can read more in our [custom node guide](/learn/customization/custom-nodes).

#### Fields

Your custom node receives the following props:

<APIDocs typeName="NodeProps" />

### NodeTypes

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/nodes.ts)

The `NodeTypes` type is used to define custom node types. Each key in the object represents a node type, and the value is the component that should be rendered for that type.

```ts
type NodeTypes = {
  [key: string]: React.ComponentType<NodeProps>;
};
```

### Node

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/nodes.ts/#L10)

The `Node` type represents everything React Flow needs to know about a given node.
Many of these properties can be manipulated both by React Flow or by you, but
some such as `width` and `height` should be considered read-only.

#### Fields

<APIDocs typeName="Node" packageName="react" />

#### Default node types

You can create any of React Flow's default nodes by setting the `type` property
to one of the following values:

* `"default"`
* `"input"`
* `"output"`
* `"group"`

If you don't set the `type` property at all, React Flow will fallback to the
`"default"` node with both an input and output port.

These default nodes are available even if you set the [`nodeTypes`](/api-reference/react-flow#node-types)
prop to something else, unless you override any of these keys directly.

#### Notes

* You shouldn't try to set the `width` or `height` of a node directly. It is
  calculated internally by React Flow and used when rendering the node in the
  viewport. To control a node's size you should use the `style` or `className`
  props to apply CSS styles instead.

### OnBeforeDelete

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/general.ts#L207)

The `OnBeforeDelete` type defines the callback function that is called before nodes or edges are deleted. This callback receives an object containing the nodes and edges that are about to be deleted.

```ts
type OnBeforeDelete = (params: {
  nodes: Node[];
  edges: Edge[];
}) => Promise<boolean | {
  nodes: Node[];
  edges: Edge[];
})>;
```

<APIDocs typeName="OnBeforeDelete" packageName="react" />

### OnConnectEnd

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/general.ts#L89)

The `OnConnectEnd` type represents a callback function that is called when finishing or canceling a connection attempt. It receives the mouse or touch event and the final state of the connection attempt.

```ts
type OnConnectEnd = (
  event: MouseEvent | TouchEvent,
  connectionState: FinalConnectionState,
) => void;
```

<APIDocs typeName="OnConnectEnd" packageName="system" />

### OnConnectStart

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/general.ts#L79)

The `OnConnectStart` type represents a callback function that is called when starting to create a connection between nodes. It receives the mouse or touch event and information about the source node and handle.

```ts
type OnConnectStart = (
  event: MouseEvent | TouchEvent,
  params: OnConnectStartParams,
) => void;
```

<APIDocs typeName="OnConnectStart" packageName="system" />

### OnConnect

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/general.ts#L80)

The `OnConnect` type represents a callback function that is called when a new connection is created between nodes. It receives a [`Connection`](/api-reference/types/connection) containing the source and target node IDs and their respective handle IDs.

```ts
type OnConnect = (connection: Connection) => void;
```

<APIDocs typeName="OnConnect" packageName="system" />

### OnDelete

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/general.ts#L59)

The `OnDelete` type defines the callback function that is called when nodes or edges are deleted. This callback receives an object containing the deleted nodes and edges.

```ts
type OnDelete = (params: { nodes: Node[]; edges: Edge[] }) => void;
```

<APIDocs typeName="OnDelete" packageName="react" />

### OnEdgesChange

This type is used for typing the [`onEdgesChange`](/api-reference/react-flow#on-edges-change) function.

```tsx
export type OnEdgesChange<EdgeType extends Edge = Edge> = (
  changes: EdgeChange<EdgeType>[],
) => void;
```

#### Fields

<APIDocs typeName="OnEdgesChange" />

#### Usage

This type accepts a generic type argument of custom edge types. See this
[section in our Typescript guide](/learn/advanced-use/typescript#nodetype-edgetype-unions) for more information.

```tsx
const onEdgesChange: OnEdgesChange = useCallback(
  (changes) => setEdges((eds) => applyEdgeChanges(changes, eds)),
  [setEdges],
);
```

### OnEdgesDelete

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/general.ts#L52)

The `OnEdgesDelete` type defines the callback function that is called when edges are deleted. This callback receives an array of the deleted edges.

```ts
type OnEdgesDelete = (edges: Edge[]) => void;
```

<APIDocs typeName="OnEdgesDelete" packageName="react" />

### OnError

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/general.ts#L233)

The `OnError` type defines the callback function that is called when an error occurs. This callback receives an error id and the error message as its argument.

```ts
type OnError = (id: string, error: string) => void;
```

<APIDocs typeName="OnError" packageName="system" />

### OnInit

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/general.ts#L113)

The `OnInit` type defines the callback function that is called when the ReactFlow instance is initialized. This callback receives the ReactFlow instance as its argument.

```ts
type OnInit = (reactFlowInstance: ReactFlowInstance) => void;
```

<APIDocs typeName="OnInit" packageName="react" />

### OnMove

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/general.ts#L16)

The `OnMove` type is a callback that fires whenever the viewport is moved, either by user interaction or programmatically. It receives the triggering event and the new viewport state.

```ts
type OnMove = (event: MouseEvent | TouchEvent | null, viewport: Viewport) => void;
```

<APIDocs typeName="OnMove" packageName="system" />

### OnNodeDrag

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/nodes.ts#L34)

The `OnNodeDrag` type defines the callback function that is called when a node is being dragged. This callback receives the event and the node that is being dragged.

```ts
type OnNodeDrag = (event: React.MouseEvent, node: Node) => void;
```

<APIDocs typeName="OnNodeDrag" packageName="react" />

### OnNodesChange

This type is used for typing the [`onNodesChange`](/api-reference/react-flow#on-nodes-change) function.

```tsx
export type OnNodesChange<NodeType extends Node = Node> = (
  changes: NodeChange<NodeType>[],
) => void;
```

#### Fields

<APIDocs typeName="OnNodesChange" />

#### Usage

This type accepts a generic type argument of custom nodes types. See this
[section in our TypeScript guide](/learn/advanced-use/typescript#nodetype-edgetype-unions) for more information.

```tsx
const onNodesChange: OnNodesChange = useCallback(
  (changes) => setNodes((nds) => applyNodeChanges(changes, nds)),
  [setNodes],
);
```

### OnNodesDelete

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/general.ts#L51)

The `OnNodesDelete` type defines the callback function that is called when nodes are deleted. This callback receives an array of the deleted nodes.

```ts
type OnNodesDelete = (nodes: Node[]) => void;
```

<APIDocs typeName="OnNodesDelete" packageName="react" />

### OnReconnect

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/general.ts#L83)

The `OnReconnect` type represents a callback function that is called when an existing edge is reconnected to a different node or handle. It receives the old edge and the new connection details.

```ts
type OnReconnect<EdgeType extends EdgeBase = EdgeBase> = (
  oldEdge: EdgeType,
  newConnection: Connection,
) => void;
```

<APIDocs typeName="OnReconnect" packageName="react" />

### OnSelectionChangeFunc

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/general.ts#98)

The `OnSelectionChangeFunc` type is a callback that is triggered when the selection of nodes or edges changes. It receives an object containing the currently selected nodes and edges.

```ts
type OnSelectionChangeFunc = (params: { nodes: Node[]; edges: Edge[] }) => void;
```

<APIDocs typeName="OnSelectionChangeFunc" packageName="react" />

### PanOnScrollMode

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/general.ts#L166)

The `PanOnScrollMode` enum controls the panning behavior of the viewport when the user scrolls. Choose `Free` for unrestricted panning, `Vertical` for up-and-down only, or `Horizontal` for left-and-right only.

```ts
enum PanOnScrollMode {
  Free = 'free',
  Vertical = 'vertical',
  Horizontal = 'horizontal',
}
```

<APIDocs typeName="PanOnScrollMode" packageName="system" />

### PanelPosition

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/general.ts/#L111-L112)

This type is mostly used to help position things on top of the flow viewport. For
example both the [`<MiniMap />`](/api-reference/components/minimap) and
[`<Controls />`](/api-reference/components/controls) components take a `position`
prop of this type.

```ts
export type PanelPosition =
  | 'top-left'
  | 'top-center'
  | 'top-right'
  | 'bottom-left'
  | 'bottom-center'
  | 'bottom-right'
  | 'center-left'
  | 'center-right';
```

### Position

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/utils.ts/#L1)

While [`PanelPosition`](/api-reference/types/panel-position) can be used to place a component in the
corners of a container, the `Position` enum is less precise and used primarily
in relation to edges and handles.

```ts
export enum Position {
  Left = 'left',
  Top = 'top',
  Right = 'right',
  Bottom = 'bottom',
}
```

### ProOptions

By default, we render a small attribution in the corner of your flows that links back to
the project. Anyone is free to remove this attribution whether they're a Pro subscriber or
not but we ask that you take a quick look at our
[removing attribution](/learn/troubleshooting/remove-attribution) guide before doing so.

<APIDocs typeName="ProOptions" />

import {
  NodesAndEdgesFields,
  IntersectionFields,
  ViewportFields,
} from '@/references/react-flow-instance';

### ReactFlowInstance

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/instance.ts/#L178-L179)

The `ReactFlowInstance` provides a collection of methods to query and manipulate the
internal state of your flow. You can get an instance by using the
[`useReactFlow`](/api-reference/hooks/use-react-flow) hook or attaching a listener to the
[`onInit`](/api-reference/react-flow#event-oninit) event.

#### Fields

##### Nodes and edges

<NodesAndEdgesFields />

##### Intersections

<IntersectionFields />

##### Viewport

<ViewportFields />

### ReactFlowJsonObject

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/instance.ts/#L5)

A JSON-compatible representation of your flow. You can use this to save the flow to a
database for example and load it back in later.

#### Fields

<APIDocs typeName="ReactFlowJsonObject" />

### Rect

[Source on GitHub](https://github.com/xyflow/xyflow/blob/f0ce2c876d8688e13632bc86286cf857f86dead6/packages/system/src/types/utils.ts/#L39-L40)

The `Rect` type defines a rectangle in a two-dimensional space with dimensions and a
position.

<APIDocs typeName="Rect" />

### ResizeParams

[Source on Github](https://github.com/xyflow/xyflow/blob/v11/packages/node-resizer/src/types.ts/#L4)

The `ResizeParams` type is used to type the various events that are emitted by the
`<NodeResizer />` component. You'll sometimes see this type extended with an additional
direction field too.

#### Fields

<APIDocs typeName="ResizeParams" />

### SelectionDragHandler

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/types/nodes.ts#L33)

The `SelectionDragHandler` type is a callback for handling drag events involving selected nodes. It receives the triggering mouse or touch event and an array of the affected nodes.

```ts
type SelectionDragHandler<NodeType extends Node = Node> = (
  event: ReactMouseEvent,
  nodes: NodeType[],
) => void;
```

<APIDocs typeName="SelectionDragHandler" packageName="react" />

### SelectionMode

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/general.ts#L223)

The `SelectionMode` enum provides two options for node selection behavior:

* `Full`: A node is only selected when the selection rectangle fully contains it
* `Partial`: A node is selected when the selection rectangle partially overlaps with it

```ts
enum SelectionMode {
  Partial = 'partial',
  Full = 'full',
}
```

### SnapGrid

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/general.ts#L157)

The `SnapGrid` type defines the grid size for snapping nodes on the pane. It is used in conjunction with the `snapToGrid` prop to enable grid snapping functionality.

```ts
type SnapGrid = [number, number];
```

### Viewport

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/types/general.ts/#L149-L153)

Internally, React Flow maintains a coordinate system that is independent of the rest of
the page. The `Viewport` type tells you where in that system your flow is currently being
display at and how zoomed in or out it is.

#### Fields

<APIDocs typeName="Viewport" />

#### Notes

* A `Transform` has the same properties as the viewport, but they represent different
  things. Make sure you don't get them muddled up or things will start to look weird!

### XYPosition

All positions are stored in an object with x and y coordinates.

```ts
export type XYPosition = {
  x: number;
  y: number;
};
```

import { ApiReferenceSummary } from 'xy-shared/server';

### Utils

<ApiReferenceSummary category="utils" />

### addEdge()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/utils/edges/general.ts/#L100)

This util is a convenience function to add a new [`Edge`](/api-reference/types/edge) to an
array of edges. It also performs some validation to make sure you don't add an
invalid edge or duplicate an existing one.

```js
import { useCallback } from 'react';
import {
  ReactFlow,
  addEdge,
  useNodesState,
  useEdgesState,
} from '@xyflow/react';

export default function Flow() {
  const [nodes, setNodes, onNodesChange] = useNodesState([]);
  const [edges, setEdges, onEdgesChange] = useEdgesState([]);
  const onConnect = useCallback(
    (connection) => {
      setEdges((oldEdges) => addEdge(connection, oldEdges));
    },
    [setEdges],
  );

  return <ReactFlow nodes={nodes} edges={edges} onConnect={onConnect} />;
}
```

#### Signature

<APIDocs functionName="addEdge" />

#### Notes

* If an edge with the same `target` and `source` already exists (and the same
  `targetHandle` and `sourceHandle` if those are set), then this util won't add
  a new edge even if the `id` property is different.

### applyEdgeChanges()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/utils/changes.ts/#L167)

Various events on the [`<ReactFlow />`](/api-reference/react-flow) component can produce an
[`EdgeChange`](/api-reference/types/edge-change) that describes how to update the edges of your
flow in some way. If you don't need any custom behavior, this util can be used to
take an array of these changes and apply them to your edges.

```js
import { useState, useCallback } from 'react';
import { ReactFlow, applyEdgeChanges } from '@xyflow/react';

export default function Flow() {
  const [nodes, setNodes] = useState([]);
  const [edges, setEdges] = useState([]);
  const onEdgesChange = useCallback(
    (changes) => {
      setEdges((oldEdges) => applyEdgeChanges(changes, oldEdges));
    },
    [setEdges],
  );

  return (
    <ReactFlow nodes={nodes} edges={edges} onEdgesChange={onEdgesChange} />
  );
}
```

#### Signature

<APIDocs functionName="applyEdgeChanges" />

#### Notes

* If you don't need any custom behavior, the [`useEdgesState`](/api-reference/hooks/use-edges-state)
  hook conveniently wraps this util and React's `useState` hook for you and might
  be simpler to use.

### applyNodeChanges()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/react/src/utils/changes.ts/#L140)

Various events on the [`<ReactFlow />`](/api-reference/react-flow) component can produce a
[`NodeChange`](/api-reference/types/node-change) that describes how to update the nodes of your
flow in some way. If you don't need any custom behavior, this util can be used to
take an array of these changes and apply them to your nodes.

```js
import { useState, useCallback } from 'react';
import { ReactFlow, applyNodeChanges } from '@xyflow/react';

export default function Flow() {
  const [nodes, setNodes] = useState([]);
  const [edges, setEdges] = useState([]);
  const onNodesChange = useCallback(
    (changes) => {
      setNodes((oldNodes) => applyNodeChanges(changes, oldNodes));
    },
    [setNodes],
  );

  return (
    <ReactFlow nodes={nodes} edges={edges} onNodesChange={onNodesChange} />
  );
}
```

#### Signature

<APIDocs functionName="applyNodeChanges" />

#### Notes

* If you don't need any custom behavior, the [`useNodesState`](/api-reference/hooks/use-nodes-state)
  hook conveniently wraps this util and React's `useState` hook for you and might
  be simpler to use.

### getBezierPath()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/utils/edges/bezier-edge.ts/#L95)

The `getBezierPath` util returns everything you need to render a bezier edge
between two nodes.

```js
import { Position, getBezierPath } from '@xyflow/react';

const source = { x: 0, y: 20 };
const target = { x: 150, y: 100 };

const [path, labelX, labelY, offsetX, offsetY] = getBezierPath({
  sourceX: source.x,
  sourceY: source.y,
  sourcePosition: Position.Right,
  targetX: target.x,
  targetY: target.y,
  targetPosition: Position.Left,
});

console.log(path); //=> "M0,20 C75,20 75,100 150,100"
console.log(labelX, labelY); //=> 75, 60
console.log(offsetX, offsetY); //=> 75, 40
```

#### Signature

<APIDocs functionName="getBezierPath" />

#### Notes

* This function returns a tuple (aka a fixed-size array) to make it easier to
  work with multiple edge paths at once.

### getConnectedEdges()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/utils/graph.ts/#L224)

This utility filters an array of edges, keeping only those where either the source or target node is present in the given array of nodes.

```js
import { getConnectedEdges } from '@xyflow/react';

const nodes = [
  { id: 'a', position: { x: 0, y: 0 } },
  { id: 'b', position: { x: 100, y: 0 } },
];
const edges = [
  { id: 'a->c', source: 'a', target: 'c' },
  { id: 'c->d', source: 'c', target: 'd' },
];

const connectedEdges = getConnectedEdges(nodes, edges);
// => [{ id: 'a->c', source: 'a', target: 'c' }]
```

#### Signature

<APIDocs functionName="getConnectedEdges" />

### getIncomers()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/utils/graph.ts/#L91)

This util is used to tell you what nodes, if any, are connected to the given node
as the *source* of an edge.

```ts
import { getIncomers } from '@xyflow/react';

const nodes = [];
const edges = [];

const incomers = getIncomers(
  { id: '1', position: { x: 0, y: 0 }, data: { label: 'node' } },
  nodes,
  edges,
);
```

#### Signature

<APIDocs functionName="getIncomers" />

### getNodesBounds()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/utils/graph.ts/#L133)

Returns the bounding box that contains all the given nodes in an array. This can
be useful when combined with [`getViewportForBounds`](/api-reference/utils/get-viewport-for-bounds)
to calculate the correct transform to fit the given nodes in a viewport.

> \[!NOTE]
>
> This function was previously called `getRectOfNodes`

```js
import { getNodesBounds } from '@xyflow/react';

const nodes = [
  {
    id: 'a',
    position: { x: 0, y: 0 },
    data: { label: 'a' },
    width: 50,
    height: 25,
  },
  {
    id: 'b',
    position: { x: 100, y: 100 },
    data: { label: 'b' },
    width: 50,
    height: 25,
  },
];

const bounds = getNodesBounds(nodes);
```

#### Signature

<APIDocs functionName="getNodesBounds" />

### getOutgoers()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/utils/graph.ts/#L64)

This util is used to tell you what nodes, if any, are connected to the given node
as the *target* of an edge.

```ts
import { getOutgoers } from '@xyflow/react';

const nodes = [];
const edges = [];

const outgoers = getOutgoers(
  { id: '1', position: { x: 0, y: 0 }, data: { label: 'node' } },
  nodes,
  edges,
);
```

#### Signature

<APIDocs functionName="getOutgoers" />

### getSimpleBezierPath()

[Source on Github](https://github.com/xyflow/xyflow/blob/main/packages/react/src/components/Edges/SimpleBezierEdge.tsx/#L32)

The `getSimpleBezierPath` util returns everything you need to render a simple
bezier edge between two nodes.

```js
import { Position, getSimpleBezierPath } from '@xyflow/react';

const source = { x: 0, y: 20 };
const target = { x: 150, y: 100 };

const [path, labelX, labelY, offsetX, offsetY] = getSimpleBezierPath({
  sourceX: source.x,
  sourceY: source.y,
  sourcePosition: Position.Right,
  targetX: target.x,
  targetY: target.y,
  targetPosition: Position.Left,
});

console.log(path); //=> "M0,20 C75,20 75,100 150,100"
console.log(labelX, labelY); //=> 75, 60
console.log(offsetX, offsetY); //=> 75, 40
```

#### Signature

<APIDocs functionName="getSimpleBezierPath" />

#### Notes

* This function returns a tuple (aka a fixed-size array) to make it easier to
  work with multiple edge paths at once.

### getSmoothStepPath()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/utils/edges/smoothstep-edge.ts/#L215)

The `getSmoothStepPath` util returns everything you need to render a stepped path
between two nodes. The `borderRadius` property can be used to choose how rounded
the corners of those steps are.

```js
import { Position, getSmoothStepPath } from '@xyflow/react';

const source = { x: 0, y: 20 };
const target = { x: 150, y: 100 };

const [path, labelX, labelY, offsetX, offsetY] = getSmoothStepPath({
  sourceX: source.x,
  sourceY: source.y,
  sourcePosition: Position.Right,
  targetX: target.x,
  targetY: target.y,
  targetPosition: Position.Left,
});

console.log(path); //=> "M0 20L20 20L 70,20Q 75,20 75,25L 75,95Q ..."
console.log(labelX, labelY); //=> 75, 60
console.log(offsetX, offsetY); //=> 75, 40
```

#### Signature

<APIDocs functionName="getSmoothStepPath" />

#### Notes

* This function returns a tuple (aka a fixed-size array) to make it easier to
  work with multiple edge paths at once.
* You can set the `borderRadius` property to `0` to get a step edge path.

### getStraightPath()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/utils/edges/straight-edge.ts/#L30)

Calculates the straight line path between two points.

```js
import { getStraightPath } from '@xyflow/react';

const source = { x: 0, y: 20 };
const target = { x: 150, y: 100 };

const [path, labelX, labelY, offsetX, offsetY] = getStraightPath({
  sourceX: source.x,
  sourceY: source.y,
  targetX: target.x,
  targetY: target.y,
});

console.log(path); //=> "M 0,20L 150,100"
console.log(labelX, labelY); //=> 75, 60
console.log(offsetX, offsetY); //=> 75, 40
```

#### Signature

<APIDocs functionName="getStraightPath" />

#### Notes

* This function returns a tuple (aka a fixed-size array) to make it easier to work with multiple edge paths at once.

import { Callout } from 'nextra/components';

### getViewportForBounds()

[Source on Github](https://github.com/xyflow/xyflow/blob/main/packages/system/src/utils/general.ts/#L170)

This util returns the viewport for the given bounds.
You might use this to pre-calculate the viewport for a given set of nodes on the
server or calculate the viewport for the given bounds *without* changing the
viewport directly.

> \[!NOTE]
>
> This function was previously called `getTransformForBounds`

```js
import { getViewportForBounds } from '@xyflow/react';

const { x, y, zoom } = getViewportForBounds(
  {
    x: 0,
    y: 0,
    width: 100,
    height: 100,
  },
  1200,
  800,
  0.5,
  2,
);
```

#### Signature

<APIDocs functionName="getViewportForBounds" />

#### Notes

* This is quite a low-level utility. You might want to look at the
  [`fitView`](/api-reference/types/react-flow-instance#fitview) or
  [`fitBounds`](/api-reference/types/react-flow-instance#fitbounds) methods for a more practical
  api.

### isEdge()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/utils/graph.ts/#L39-L40)

Test whether an object is usable as an [`Edge`](/api-reference/types/edge). In TypeScript
this is a type guard that will narrow the type of whatever you pass in to
[`Edge`](/api-reference/types/edge) if it returns `true`.

```js
import { isEdge } from '@xyflow/react';

const edge = {
  id: 'edge-a',
  source: 'a',
  target: 'b',
};

if (isEdge(edge)) {
  // ...
}
```

#### Signature

<APIDocs functionName="isEdge" />

### isNode()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/system/src/utils/graph.ts/#L49)

Test whether an object is usable as a [`Node`](/api-reference/types/node). In TypeScript
this is a type guard that will narrow the type of whatever you pass in to
[`Node`](/api-reference/types/node) if it returns `true`.

```js
import { isNode } from '@xyflow/react';

const node = {
  id: 'node-a',
  data: {
    label: 'node',
  },
  position: {
    x: 0,
    y: 0,
  },
};

if (isNode(node)) {
  // ..
}
```

#### Signature

<APIDocs functionName="isNode" />

### reconnectEdge()

[Source on GitHub](https://github.com/xyflow/xyflow/blob/main/packages/core/src/utils/graph.ts/#L97)

A handy utility to update an existing [`Edge`](/api-reference/types/edge) with new properties.
This searches your edge array for an edge with a matching `id` and updates its
properties with the connection you provide.

```js
const onReconnect = useCallback(
  (oldEdge: Edge, newConnection: Connection) => setEdges((els) => reconnectEdge(oldEdge, newConnection, els)),
  []
);
```

#### Signature

<APIDocs functionName="reconnectEdge" />

## Learn

import { Emoji } from '@xyflow/xy-ui';
import { Callout, Cards, Steps } from 'nextra/components';
import { LiteYouTubeEmbed } from 'xy-shared';
import { RemoteCodeViewer } from 'xy-shared/server';

### Quick Start

This page will take you from zero to a working React Flow app in a few minutes. If you
just want to have a look around and get an impression of React Flow, check out our
interactive no-code [Playground](https://play.reactflow.dev/).

If you are a large language model, you can find the raw text of React Flow's documentation in the [llms.txt](/llms.txt) file.

#### Installation

First, spin up a new React project however you like -- we recommend using
[Vite](https://vitejs.dev/)

```bash copy npm2yarn
npm init vite my-react-flow-app -- --template react
```

Next `cd` into your new project folder and add
[`@xyflow/react`](https://npmjs.com/package/@xyflow/react) as a dependency

```bash copy npm2yarn
npm install @xyflow/react
```

Lastly, spin up the dev server and you're good to go!

#### Usage

We will render the [`<ReactFlow />`](/api-reference/react-flow#reactflow) component from
the `@xyflow/react` package. That and defining a handful of
[node](/api-reference/types/node) objects, [edge](/api-reference/types/edge) objects and
[event handlers](/api-reference/react-flow#event-handlers) are all we need to get
something going! Get rid of everything inside `App.jsx` and add the following:

```jsx "import '@xyflow/react/dist/style.css';" "width: '100vw', height: '100vh'"
import { useState, useCallback } from 'react';
import { ReactFlow, applyNodeChanges, applyEdgeChanges, addEdge } from '@xyflow/react';
import '@xyflow/react/dist/style.css';

const initialNodes = [
  { id: 'n1', position: { x: 0, y: 0 }, data: { label: 'Node 1' } },
  { id: 'n2', position: { x: 0, y: 100 }, data: { label: 'Node 2' } },
];
const initialEdges = [{ id: 'n1-n2', source: 'n1', target: 'n2' }];

export default function App() {
  const [nodes, setNodes] = useState(initialNodes);
  const [edges, setEdges] = useState(initialEdges);

  const onNodesChange = useCallback(
    (changes) => setNodes((nodesSnapshot) => applyNodeChanges(changes, nodesSnapshot)),
    [],
  );
  const onEdgesChange = useCallback(
    (changes) => setEdges((edgesSnapshot) => applyEdgeChanges(changes, edgesSnapshot)),
    [],
  );
  const onConnect = useCallback(
    (params) => setEdges((edgesSnapshot) => addEdge(params, edgesSnapshot)),
    [],
  );

  return (
    <div style={{ width: '100vw', height: '100vh' }}>
      <ReactFlow
        nodes={nodes}
        edges={edges}
        onNodesChange={onNodesChange}
        onEdgesChange={onEdgesChange}
        onConnect={onConnect}
        fitView
      />
    </div>
  );
}
```

There are two things to pay attention to here:

* <Emoji content="🎨" /> You must import the css stylesheet for React Flow to work.
* <Emoji content="📐" /> The `<ReactFlow />` component must have a parent element with a
  width and height.

#### Result

Et voila. You've already created your first interactive flow! <Emoji content="🎉" />

<RemoteCodeViewer route="learn/quickstart" framework="react" />

#### Next steps

<Cards>
  <Cards.Card title="Core Concepts" href="/learn/concepts/terms-and-definitions" />

  <Cards.Card title="Customization" href="/learn/customization/custom-nodes" />

  <Cards.Card title="Examples" href="/examples" />

  <Cards.Card title="API Reference" href="/api-reference" />

  <Cards.Card title="Discord" href="https://discord.gg/RVmnytFmGW" />

  <Cards.Card title="Template Projects" href="https://github.com/xyflow/react-flow-example-apps" />
</Cards>

import { Callout } from 'nextra/components';

### Accessibility

<Callout type="info">
  If you have suggestions for how we can improve the accessibility of React Flow, please feel free to [contact us](https://xyflow.com/contact).
</Callout>

React Flow provides keyboard and screen-reader support to help meet accessibility standards. By default, all nodes and edges are keyboard-focusable and operable. You can enable or disable these features with props including: [nodesFocusable](/api-reference/react-flow#nodesfocusable), [edgesFocusable](/api-reference/react-flow#edgesfocusable), and [disableKeyboardA11y](/api-reference/react-flow#disablekeyboarda11y) which are passed through `<ReactFlow />` like this:

```js
<ReactFlow
  nodesFocusable={true}
  edgesFocusable={true}
  disableKeyboardA11y={false}
  nodes={nodes}
  edges={edges}
>
  {/* ...other components like Controls, MiniMap... */}
</ReactFlow>
```

#### Built-in features

* **Tab navigation:** Pressing `Tab` moves focus through all focusable nodes and edges. These elements receive `tabIndex={0}` and, by default, `role="group"` to handle interactivity.
* **Select/Deselect:** Press `Enter` or `Space` to select the focused node/edge, and `Escape` to clear the selection.
* **Move nodes with arrow keys:** If `nodesDraggable` and `nodesFocusable` are both true (default), you can move the selected node with the arrow keys. You can hold `Shift` to increase movement speed. If you set `disableKeyboardA11y={true}`, arrow-key movement is disabled (but tab-focus and selection still work).
* **Automatic panning:** When a node receives focus, React Flow automatically pans the canvas to bring that node into view. This ensures focused nodes are visible to the user. This behavior can be toggled via the [autoPanOnNodeFocus](/api-reference/react-flow#autopanonnodefocus) prop.
* **ARIA descriptions:** React Flow automatically adds ARIA descriptions for keyboard guidance. These can be configured by using [ariaLabelConfig](/api-reference/react-flow#arialabelconfig).

<Callout type="info">
  To enable full keyboard accessibility, ensure both `nodesFocusable` and `edgesFocusable`
  are set to `true`. If either is false, corresponding elements will not be
  keyboard-focusable.
</Callout>

#### ARIA roles for nodes and edges

By default, React Flow uses semantic ARIA roles for interactive elements. You can override a node’s role using the `ariaRole` prop. For example:

```js
const nodes = [
  {
    id: '1',
    data: { label: 'Hello' },
    ariaRole: 'button',
  },
];
<ReactFlow nodes={nodes} edges={[]} />;
```

By, default, if you don’t set a role, `role="group"` is applied. Customizing `ariaRole` lets you match any relevant ARIA role (e.g. `"listitem"`, `"region"`, etc.), improving semantic information for assistive technology.

**Note:** The `ariaRole` is applied to the node wrapper. If a custom node includes interactive elements, avoid setting `ariaRole: 'button'` on the node itself. Instead, apply the appropriate ARIA role directly to the interactive element.

##### DOM attributes

To pass custom ARIA attributes or other DOM-level attributes (e.g., `aria-roledescription`, `data-\*`,`tabIndex`, etc.), you can use the `domAttributes` prop. This is available for both nodes and edges:

```
// Example for a node
{
  id: '2',
  data: { label: 'Accessible Node' },
  domAttributes: {
    'aria-roledescription': 'collapsible node',
    tabIndex: 0,
    'data-test-id': 'node-2',
  },
}

```

This gives you full control over accessibility-related attributes while maintaining React Flow’s built-in roles and behaviors.

#### Localizing accessibility messages

React Flow’s built-in accessibility text (such as keyboard instructions and live updates) can be customized or localized via the [ariaLabelConfig](/api-reference/react-flow#arialabelconfig) prop on`<ReactFlow>`. This prop takes an object mapping message keys to strings or functions. Keys include:

| Key                                     | Default Value                                                                                                                                   |
| --------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------- |
| `node.a11yDescription.default`          | Press enter or space to select a node. Press delete to remove it and escape to cancel.                                                          |
| `node.a11yDescription.keyboardDisabled` | Press enter or space to select a node. You can then use the arrow keys to move the node around. Press delete to remove it and escape to cancel. |
| `node.a11yDescription.ariaLiveMessage`  | `Moved selected node {direction}. New position, x: {x}, y: {y}`                                                                                 |
| `edge.a11yDescription.default`          | Press enter or space to select an edge. You can then press delete to remove it or escape to cancel.                                             |
| `controls.ariaLabel`                    | Control Panel                                                                                                                                   |
| `controls.zoomIn.ariaLabel`             | Zoom In                                                                                                                                         |
| `controls.zoomOut.ariaLabel`            | Zoom Out                                                                                                                                        |
| `controls.fitView.ariaLabel`            | Fit View                                                                                                                                        |
| `controls.interactive.ariaLabel`        | Toggle Interactivity                                                                                                                            |
| `minimap.ariaLabel`                     | Mini Map                                                                                                                                        |
| `handle.ariaLabel`                      | Handle                                                                                                                                          |

For example, to provide custom or localized text:

```js
const ariaLabels = {
  'node.a11yDescription.default': 'Press [Enter] to select this node',
  'node.a11yDescription.keyboardDisabled': 'Keyboard navigation is disabled',
};
<ReactFlow nodes={nodes} edges={edges} ariaLabelConfig={ariaLabels}>
  <MiniMap />
  <Controls />
</ReactFlow>;
```

This tells React Flow to use your text instead of the defaults. By supplying localized strings via [ariaLabelConfig](/api-reference/react-flow#arialabelconfig), you ensure screen readers announce messages in the user’s language.

#### WCAG 2.1 AA

React Flow provides features that can help you meet key WCAG 2.1 AA criteria when properly implemented:

* **Keyboard:** React Flow supports keyboard operability with `Tab` navigation to nodes and edges, interaction via `Enter`/`Space`, and arrow key movement for nodes. These features help satisfy requirements for keyboard accessibility.
* **Screen Reader:** With semantic ARIA roles and labels (e.g. `role="group"`, `aria-label`, and `aria-roledescription`), React Flow enables you to create meaningfully announced graphical nodes/edges. Edge components include a customizable `aria-label` and nodes can be given appropriate `aria-label` text.
* **ARIA Live Regions:** Dynamic updates are announced through an `aria-live` region. The `A11yDescriptions` component includes an element with `aria-live="assertive"` that notifies users of node movements, helping you meet requirements for status messages.
* **Instructions and Focus Management:** React Flow provides contextual help with clear instructions like "Press enter or space to select a node…". The automatic focus management ensures nodes scroll into view when focused, helping satisfy requirements for input assistance.

This guide is helpful for learning about [ARIA best practices](https://www.w3.org/WAI/ARIA/apg/practices/read-me-first/).

### Computing Flows

import { Callout } from 'nextra/components';
import { RemoteCodeViewer } from 'xy-shared/server';

<Callout type="info">
  For this guide we assume that you already know about the [core
  concepts](/learn/concepts/core-concepts) of React Flow and how to implement
  [custom nodes](/learn/customization/custom-nodes).
</Callout>

Usually with React Flow, developers handle their data outside of React Flow by sending it somewhere else, like on a server or a database. Instead, in this guide we'll show you how to compute data flows directly inside of React Flow. You can use this for updating a node based on connected data, or for building an app that runs entirely inside the browser.

#### What are we going to build?

By the end of this guide, you will build an interactive flow graph that generates a color out of three separate number input fields (red, green and blue), and determines whether white or black text would be more readable on that background color.

<RemoteCodeViewer route="learn/computing-6" framework="react" />

#### Creating custom nodes

Let's start by creating a custom input node (`NumberInput.js`) and add three instances of it. We will be using a controlled `<input type="number" />` and limit it to integer numbers between 0 - 255 inside the `onChange` event handler.

```jsx
import { useCallback, useState } from 'react';
import { Handle, Position } from '@xyflow/react';

function NumberInput({ id, data }) {
  const [number, setNumber] = useState(0);

  const onChange = useCallback((evt) => {
    const cappedNumber = Math.round(
      Math.min(255, Math.max(0, evt.target.value)),
    );
    setNumber(cappedNumber);
  }, []);

  return (
    <div className="number-input">
      <div>{data.label}</div>
      <input
        id={`number-${id}`}
        name="number"
        type="number"
        min="0"
        max="255"
        onChange={onChange}
        className="nodrag"
        value={number}
      />
      <Handle type="source" position={Position.Right} />
    </div>
  );
}

export default NumberInput;
```

Next, we'll add a new custom node (`ColorPreview.js`) with one target handle for each color channel and a background that displays the resulting color. We can use `mix-blend-mode: 'difference';` to make the text color always readable.

<Callout type="info">
  Whenever you have multiple handles of the same kind on a single node, don't
  forget to give each one a separate id!
</Callout>

Let's also add edges going from the input nodes to the color node to our
`initialEdges` array while we are at it.

<RemoteCodeViewer route="learn/computing" framework="react" activeFile="ColorPreview.jsx" />

#### Computing data

How do we get the data from the input nodes to the color node? This is a two step process that involves two hooks created for this exact purpose:

1. Store each number input value inside the node's `data` object with help of the [`updateNodeData`](/api-reference/types/react-flow-instance#update-node-data) callback.
2. Find out which nodes are connected by using [`useNodeConnections`](/api-reference/hooks/use-node-connections) and then use [`useNodesData`](/api-reference/hooks/use-nodes-data) for receiving the data from the connected nodes.

##### Step 1: Writing values to the data object

First let's add some initial values for the input nodes inside the `data` object in our `initialNodes` array and use them as an initial state for the input nodes.
Then we'll grab the function [`updateNodeData`](/api-reference/types/react-flow-instance#update-node-data) from the [`useReactFlow`](/api-reference/hooks/use-react-flow) hook and use it to update the `data` object of the node with a new value whenever the input changes.

<Callout type="info">
  By default, the data you pass to [`updateNodeData`](/api-reference/types/react-flow-instance#update-node-data) will be merged with the old data object. This makes it easier to do partial updates and saves you in case you forget to add `{...data}`. You can pass `{ replace: true }` as an option to replace the object instead.
</Callout>

<RemoteCodeViewer route="learn/computing-2" framework="react" activeFile="NumberInput.jsx" />

<Callout type="warning">
  <b>
    When dealing with input fields you don't want to use a nodes `data` object
    as UI state directly.
  </b>

  There is a delay in updating the data object and the cursor might jump around
  erratically and lead to unwanted inputs.
</Callout>

##### Step 2: Getting data from connected nodes

We start by determining all connections for each node with the [`useNodeConnections`](/api-reference/hooks/use-node-connections) hook and then fetching the data for the first connected node with [`updateNodeData`](/api-reference/types/react-flow-instance#update-node-data).

<Callout type="info">
  Note that each handle can have multiple nodes connected to it and you might
  want to restrict the number of connections to a single handle inside your
  application. Check out the [connection limit
  example](/examples/nodes/connection-limit) to see how to do that.
</Callout>

<b>And there you go!</b> Try changing the input values and see the color change
in real time.

<RemoteCodeViewer route="learn/computing-3" framework="react" activeFile="ColorPreview.jsx" />

##### Improving the code

It might seem awkward to get the connections first, and then the data separately for each handle. For nodes with multiple handles like these, you should consider creating a custom handle component that isolates connection states and node data binding. We can create one inline.

```jsx filename="ColorPreview.js"
// {...}
function CustomHandle({ id, label, onChange }) {
  const connections = useNodeConnections({
    handleType: 'target',
    handleId: id,
  });

  const nodeData = useNodesData(connections?.[0].source);

  useEffect(() => {
    onChange(nodeData?.data ? nodeData.data.value : 0);
  }, [nodeData]);

  return (
    <div>
      <Handle
        type="target"
        position={Position.Left}
        id={id}
        className="handle"
      />
      <label htmlFor="red" className="label">
        {label}
      </label>
    </div>
  );
}
```

We can promote color to local state and declare each handle like this:

```jsx filename="ColorPreview.js"
// {...}
function ColorPreview() {
  const [color, setColor] = useState({ r: 0, g: 0, b: 0 });

  return (
    <div
      className="node"
      style={{
        background: `rgb(${color.r}, ${color.g}, ${color.b})`,
      }}
    >
      <CustomHandle
        id="red"
        label="R"
        onChange={(value) => setColor((c) => ({ ...c, r: value }))}
      />
      <CustomHandle
        id="green"
        label="G"
        onChange={(value) => setColor((c) => ({ ...c, g: value }))}
      />
      <CustomHandle
        id="blue"
        label="B"
        onChange={(value) => setColor((c) => ({ ...c, b: value }))}
      />
    </div>
  );
}

export default ColorPreview;
```

#### Getting more complex

Now we have a simple example of how to pipe data through React Flow. What if we want to do something more complex, like transforming the data along the way? Or even take different paths? We can do that too!

##### Continuing the flow

Let's extend our flow. Start by adding an output `<Handle type="source" position={Position.Right} />` to the color node and remove the local component state.

<Callout type="info">
  Because there are no inputs fields on this node, we don't need to keep a local
  state at all. We can just read and update the node's `data` object directly.
</Callout>

Next, we add a new node (`Lightness.js`) that takes in a color object and determines if it is either a light or dark color. We can use the [relative luminance formula](https://en.wikipedia.org/wiki/Relative_luminance#Relative_luminance_and_%22gamma_encoded%22_colorspaces)
`luminance = 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b`
to calculate the perceived brightness of a color (0 being the darkest and 255 being the brightest). We can assume everything >= 128 is a light color.

<RemoteCodeViewer route="learn/computing-4" framework="react" activeFile="Lightness.jsx" />

##### Conditional branching

What if we would like to take a different path in our flow based on the perceived lightness? Let's give our lightness node two source handles `light` and `dark` and separate the node `data` object by source handle IDs. This is needed if you have multiple source handles to distinguish between each source handle's data.

But what does it mean to "take a different route"? One solution would be to assume that `null` or `undefined` data hooked up to a target handle is considered a "stop". In our case we can write the incoming color into `data.values.light` if it's a light color and into `data.values.dark` if it's a dark color and set the respective other value to `null`.

Don't forget to add `flex-direction: column;` and `align-items: end;` to reposition the handle labels.

<RemoteCodeViewer route="learn/computing-5" framework="react" activeFile="Lightness.jsx" />

Cool! Now we only need a last node to see if it actually works... We can create a custom debugging node (`Log.js`) that displays the hooked up data, and we're done!

<RemoteCodeViewer route="learn/computing-6" framework="react" activeFile="Log.jsx" />

#### Summary

You have learned how to move data through the flow and transform it along the way.
All you need to do is

1. store data inside the node's `data` object with help of [`updateNodeData`](/api-reference/types/react-flow-instance#update-node-data) callback.
2. find out which nodes are connected by using [`useNodeConnections`](/api-reference/hooks/use-node-connections) and then use [`useNodesData`](/api-reference/hooks/use-nodes-data) for receiving the data from the connected nodes.

You can implement branching for example by interpreting incoming data that is undefined as a "stop". As a side note, most flow graphs that also have a branching usually separate the triggering of nodes from the actual data hooked up to the nodes. Unreal Engines Blueprints are a good example for this.

<Callout type="info">
  One last note before you go: you should find a consistent way of structuring
  all your node data, instead of mixing ideas like we did just now. This means
  for example, if you start working with splitting data by handle ID you should
  do it for all nodes, regardless whether they have multiple handles or not.
  Being able to make assumptions about the structure of your data throughout
  your flow will make life a lot easier.
</Callout>

import { Callout } from 'nextra/components';
import { RemoteCodeViewer } from 'xy-shared/server';

### Devtools and Debugging

<Callout type="info">
  This is an ongoing experiment on implementing our own React Flow devtools. While we are
  working on the actual package, we'd love to hear about your feedback and ideas on
  [Discord](https://discord.gg/Bqt6xrs) or via mail at [info@xyflow.com](mailto:info@xyflow.com).
</Callout>

React Flow can often seem like a magic black box, but in reality you can reveal quite a
lot about its internal state if you know where to look. In this guide we will show you
three different ways to reveal the internal state of your flow:

* A `<ViewportLogger />` component that shows the current position and zoom level of the
  viewport.
* A `<NodeInspector />` component that reveals the state of each node.
* A `<ChangeLogger />` that wraps your flow's `onNodesChange` handler and logs each change
  as it is dispatched.

While we find these tools useful for making sure React Flow is working properly, you might
also find them useful for debugging your applications as your flows and their interactions
become more complex.

<div className="nestedSandpack">
  <RemoteCodeViewer route="learn/devtools" framework="react" />
</div>

We encourage you to copy any or all of the components from this example into your own
projects and modify them to suit your needs: each component works independently!

#### Node Inspector

The `<NodeInspector />` component makes use of our
[`useNodes`](/api-reference/hooks/use-nodes) hook to access all the nodes in the flow.
Typically we discourage using this hook because it will trigger a re-render any time *any*
of your nodes change, but that's exactly what makes it so useful for debugging!

The `width` and `height` properties are added to each node by React Flow after it has
measured the node's dimensions. We pass those dimensions, as well as other information
like the node's id and type, to a custom `<NodeInfo />` component.

We make use of the [`<ViewportPortal />`](/api-reference/components/viewport-portal)
component to let us render the inspector into React Flow's viewport. That means it's
content will be positioned and transformed along with the rest of the flow as the user
pans and zooms.

#### Change Logger

Any change to your nodes and edges that originates from React Flow itself is communicated
to you through the `onNodesChange` and `onEdgesChange` callbacks. If you are working with
a controlled flow (that means you're managing the nodes and edges yourself), you need to
apply those changes to your state in order to keep everything in sync.

The `<ChangeLogger />` component wraps your user-provided `onNodesChange` handler with a
custom function that intercepts and logs each change as it is dispatched. We can do this
by using the [`useStore`](/api-reference/hooks/use-store) and
[`useStoreApi`](/api-reference/hooks/use-store-api) hooks to access the store and and then
update React Flow's internal state accordingly. These two hooks give you powerful access
to React Flow's internal state and methods.

Beyond debugging, using the `<ChangeLogger />` can be a great way to learn more about how
React Flow works and get you thinking about the different functionality you can build on
top of each change.

You can find documentation on the [`NodeChange`](/api-reference/types/node-change) and
[`EdgeChange`](/api-reference/types/edge-change) types in the API reference.

#### Viewport Logger

The `<ViewportLogger />` is the simplest example of what state you can pull out of React
Flow's store if you know what to look for. The state of the viewport is stored internally
under the `transform` key (a name we inherited from
[d3-zoom](https://d3js.org/d3-zoom#zoomTransform)). This component extracts the `x`, `y`,
and `zoom` components of the transform and renders them into a
[`<Panel />`](/api-reference/components/panel) component.

#### Let us know what you think

As mentioned above, if you have any feedback or ideas on how to improve the devtools,
please let us know on [Discord](https://discord.gg/Bqt6xrs) or via mail at
[info@xyflow.com](mailto:info@xyflow.com). If you build your own devtools using these ideas, we'd love to hear about
it!

import { RemoteCodeViewer } from 'xy-shared/server';

### Hooks and Providers

React Flow provides several [hooks](/api-reference/hooks) and a context provider
for you to enhance the functionality of your flow. These tools help you to
manage state, access internal methods, and create custom components more
effectively.

#### ReactFlowProvider

The ReactFlowProvider is a context provider that allows you to access the
internal state of the flow, such as nodes, edges, and viewport, from anywhere in
your component tree even outside the [`ReactFlow`](/api-reference/react-flow)
component. It is typically used at the top level of your application.

There are several cases where you might need to use the
[`ReactFlowProvider`](/api-reference/react-flow-provider) component:

* Many of the [hooks](/api-reference/hooks) we provide rely on this component to
  work.
* You want to access the internal state of the flow outside of the `ReactFlow`
  component.
* You are working with multiple flows on a page.
* You are using a client-side router.

<RemoteCodeViewer route="examples/misc/provider" framework="react" />

#### useReactFlow

The [`useReactFlow`](/api-reference/hooks/use-react-flow) hook provides access
to the [`ReactFlowInstance`](/api-reference/types/react-flow-instance) and its
methods. It allows you to manipulate nodes, edges, and the viewport
programmatically.

This example illustrates how to use the `useReactFlow` hook.

<RemoteCodeViewer route="examples/misc/use-react-flow-hook" framework="react" />

### Performance

When dealing with a large number of nodes or complex components, managing performance can
be challenging. Here are a few effective strategies to optimize the performance of React
Flow.

#### Use memoization

One of the main reasons for performance issues in React Flow is unnecessary re-renders.
Since node movements trigger frequent state updates, this can lead to performance
bottlenecks, especially in larger diagrams.

##### Memoize components

Components provided as props to the `<ReactFlow>` component, including custom node and
edge components, should either be memoized using `React.memo` or declared outside the
parent component. This ensures that React does not create a new reference for the
component on every render, which would otherwise trigger unnecessary re-renders.

```tsx
const NodeComponent = memo(() => {
  return <div>{data.label}</div>;
});
```

##### Memoize functions

Similarly, functions passed as props to `<ReactFlow>` should be memoized using
`useCallback`. This prevents React from creating a new function reference on every render,
which could also trigger unnecessary re-renders. Additionally, arrays and objects like
`defaultEdgeOptions` or `snapGrid` should be memoized using `useMemo` to prevent
unnecessary re-renders.

```tsx
import React, { useCallback } from 'react';

const MyDiagram = () => {
  const onNodeClick = useCallback((event, node) => {
    console.log('Node clicked:', node);
  }, []);

  return <ReactFlow onNodeClick={onNodeClick} />;
};

export default MyDiagram;
```

#### Avoid accessing nodes in components

One of the most common performance pitfalls in React Flow is directly accessing
the `nodes` or `edges` in the components or the viewport. These objects change frequently
during operations like dragging, panning, or zooming, which can cause unnecessary
re-renders of components that depend on them.

For example, if you fetch the entire `nodes` array from the store and filter it to display
selected node IDs, this approach can lead to performance degradation. Every update to
the `nodes` array triggers a re-render of all dependent components, even if the change is
unrelated to the selected nodes.

##### Inefficient example

```tsx
const SelectedNodeIds = () => {
  // ❌ This will cause unnecessary re-renders!

  const nodes = useStore((state) => state.nodes);

  const selectedNodeIds = nodes.filter((node) => node.selected).map((node) => node.id);

  return (
    <div>
      {selectedNodeIds.map((id) => (
        <div key={id}>{id}</div>
      ))}
    </div>
  );
};
```

In this example, every update to the `nodes` array causes the `SelectedNodeIds` component
to re-render, even if the selection hasn’t changed.

##### Optimized solution

To avoid unnecessary re-renders, store the selected nodes in a separate field in your
state (using Zustand, Redux, or any other state management solution). This ensures that
the component only re-renders when the selection changes.

```tsx
const SelectedNodeIds = () => {
  const selectedNodeIds = useStore((state) => state.selectedNodeIds);

  return (
    <div>
      {selectedNodeIds.map((id) => (
        <div key={id}>{id}</div>
      ))}
    </div>
  );
};
```

By decoupling the selected nodes from the `nodes` array, you prevent unnecessary updates
and improve performance. For more information, view our
[State Management guide](/learn/advanced-use/state-management).

#### Collapse large node trees

If your node tree is deeply nested, rendering all nodes at once can be inefficient.
Instead, show only a limited number of nodes and allow users to expand them as needed. You
can do this by modifying the node’s `hidden` property dynamically to toggle visibility.

```tsx
const handleNodeClick = (targetNode) => {
  if (targetNode.data.children) {
    setNodes((prevNodes) =>
      prevNodes.map((node) =>
        targetNode.data.children.includes(node.id)
          ? { ...node, hidden: !node.hidden }
          : node,
      ),
    );
  }
};
```

By hiding nodes initially and rendering them only when expanded, we optimize performance
while maintaining usability.

#### Simplify node and edge styles

If you've optimized performance in every other way, and you are still finding performance
issues with large numbers of nodes, complex CSS styles, particularly those involving
animations, shadows, or gradients, can significantly impact performance. Consider reducing
complexity on your node styles in these cases.

#### Additional resources

Here are a few helpful resources on performance in React Flow that you can check out:

* [Guide to Optimize React Flow Project Performance](https://www.synergycodes.com/blog/guide-to-optimize-react-flow-project-performance)
* [Tuning Edge Animations ReactFlow Optimal Performance](https://liambx.com/blog/tuning-edge-animations-reactflow-optimal-performance)
* [5 Ways to Optimize React Flow in 10 minutes](https://www.youtube.com/watch?v=8M2qZ69iM20)

### Server Side Rendering

### Server side rendering, server side generation

import { Callout } from 'nextra/components';

<Callout type="info">Server side rendering is supported since React Flow 12</Callout>

This is an advanced use case and assumes you are already familiar with React Flow. If you're new to React Flow, check out our [getting started guide](/learn/getting-started/installation-and-requirements).

In this guide you will learn how to configure React Flow to render a flow on the server, which will allow you to

* Display static HTML diagrams in documentation
* Render React Flow diagrams in non-js environments
* Dynamically generate open graph images that appear as embeds when sharing a link to your flow

(If you want to download an image of your flow, there's an easier way to do that on the client-side in our [download image example](/examples/misc/download-image).)

##### Node dimensions

You need to configure a few things to make React Flow work on the server, the most important being the node dimensions. React Flow only renders nodes if they have a width and height. Usually you pass nodes without a specific `width` and `height`, they are then measured and the dimensions get written to `measured.width` and `measured.height`. Since we can't measure the dimensions on the server, we need to pass them explicitly. This can be done with the `width` and `height` or the `initialWidth` and `initialHeight` node properties.

```js
const nodes = [
  {
    id: '1',
    type: 'default',
    position: { x: 0, y: 0 },
    data: { label: 'Node 1' },
    width: 100,
    height: 50,
  },
];
```

React Flow now knows the dimensions of the node and can render it on the server. The `width` and `height` properties are used as an inline style for the node. If you expect nodes to have different dimensions on the client or if the dimensions should by dynamic based on the content, you can use the `initialWidth` and `initialHeight` properties. They are only used for the first render (on the server or on the client) as long as the nodes are not measured and `measured.width` and `measured.height` are not set.

<Callout type="default">
  <strong>
    There are two ways to specify node dimensions for server side rendering:
  </strong>

  <div>
    1. `width` and `height` for static dimensions that are known in advance and don't
       change.
  </div>

  <div>
    2. `initialWidth` and `initialHeight` for dynamic dimensions that are not known in
       advance or change.
  </div>
</Callout>

##### Handle positions

You probably also want to render the edges on the server. On the client, React Flow checks the positions of the handles and stores that information to draw the edges. Since we can't measure the handle positions on the server, we need to pass this information, too. This can be done with the `handles` property of a node.

```js
const nodes: Node[] = [
  {
    id: '1',
    type: 'default',
    position: { x: 0, y: 0 },
    data: { label: 'Node 1' },
    width: 100,
    height: 50,
    handles: [
      {
        type: 'target',
        position: Position.Top,
        x: 100 / 2,
        y: 0,
      },
      {
        type: 'source',
        position: Position.Bottom,
        x: 100 / 2,
        y: 50,
      },
    ],
  },
];
```

With this additional information, React Flow knows enough about the handles to render the edges on the server. If you are fine with just rendering the nodes, you can skip this step.

##### Using `fitView` on the server

If you know the dimensions of the React Flow container itself, you can even use `fitView` on the server. For this, you need to pass the `width` and `height` of the container to the `ReactFlow` component.

```js
<ReactFlow nodes={nodes} edges={edges} fitView width={1000} height={500} />
```

This will calculate the viewport and set the `transform` on the server in order to include all nodes in the viewport.

##### Usage with the `<ReactFlowProvider>`

If you are using the `ReactFlowProvider`, you can pass `initialNodes`, `initialEdges` and optional wrapper dimensions (`initialWidth` and `initialHeight`) and `fitView` to the provider.

```js
<ReactFlowProvider
  initialNodes={nodes}
  initialEdges={edges}
  initialWidth={1000}
  initialHeight={500}
  fitView
>
  <App />
</ReactFlowProvider>
```

The `initial-` prefix means that these values are only used for the first render. After that, the provider will use the `nodes` and `edges` from the context.

##### Creating static HTML

If you want to create static HTML, you can use the `renderToStaticMarkup` function from React. This will render the React Flow component to a string of HTML. You can then use this string to create a static HTML file or send it as a response to an HTTP request.

```js
import React from 'react';
import { renderToStaticMarkup } from 'react-dom/server';
import { ReactFlow, Background } from '@xyflow/react';

function toHTML({ nodes, edges, width, height }) {
  const html = renderToStaticMarkup(
    React.createElement(
      ReactFlow,
      {
        nodes,
        edges,
        width,
        height,
        minZoom: 0.2,
        fitView: true,
      },
      React.createElement(Background, null),
    ),
  );

  return html;
}
```

### Using a State Management Library

import { Callout } from 'nextra/components';
import { RemoteCodeViewer } from 'xy-shared/server';

<Callout type="info">
  For this guide we assume that you already know about the [core
  concepts](/learn/concepts/core-concepts) of React Flow and how to implement
  [custom nodes](/learn/customization/custom-nodes). You should also be familiar
  with the concepts of state management libraries and how to use them.
</Callout>

In this guide, we explain how to use React Flow with the state management library [Zustand](https://github.com/pmndrs/zustand). We will build a small app where each node features a color chooser that updates its background color. We chose Zustand for this guide because React Flow already uses it internally, but you can easily use other state management libraries such as [Redux](https://redux.js.org/), [Recoil](https://recoiljs.org/) or [Jotai](https://jotai.org/)

As demonstrated in previous guides and examples, React Flow can easily be used with a local component state to manage nodes and edges in your diagram. However, as your application grows and you need to update the state from within individual nodes, managing this state can become more complex. Instead of passing functions through the node's data field, you can use a [React context](https://reactjs.org/docs/context.html) or integrate a state management library like Zustand, as outlined in this guide.

#### Install Zustand

As mentioned above we are using Zustand in this example. Zustand is a bit like Redux: you have a central store with actions to alter your state and hooks to access your state. You can install Zustand via:

```bash copy npm2yarn
npm install --save zustand
```

#### Create a store

Zustand lets you create a hook for accessing the values and functions of your store. We put the `nodes` and `edges` and the `onNodesChange`, `onEdgesChange`, `onConnect`, `setNodes` and `setEdges` functions in the store to get the basic interactivity for our graph:

<RemoteCodeViewer route="learn/state-management" framework="react" />

That's the basic setup. We now have a store with nodes and edges that can handle the changes (dragging, selecting or removing a node or edge) triggered by React Flow. When you take a look at the `App.tsx` file, you can see that it's kept nice and clean. All the data and actions are now part of the store and can be accessed with the `useStore` hook.

#### Implement a color change action

We add a new `updateNodeColor` action to update the `data.color` field of a specific node. For this we pass the node id and the new color to the action, iterate over the nodes and update the matching one with the new color:

```ts
updateNodeColor: (nodeId: string, color: string) => {
  set({
    nodes: get().nodes.map((node) => {
      if (node.id === nodeId) {
        // it's important to create a new object here, to inform React Flow about the changes
        return { ...node, data: { ...node.data, color } };
      }

      return node;
    }),
  });
};
```

This new action can now be used in a React component like this:

```tsx
const updateNodeColor = useStore((s) => s.updateNodeColor);
...
<button onClick={() => updateNodeColor(nodeId, color)} />;
```

#### Add a color chooser node

In this step we implement the `ColorChooserNode` component and call the `updateNodeColor` when the user changes the color. The custom part of the color chooser node is the color input.

```jsx
<input
  type="color"
  defaultValue={data.color}
  onChange={(evt) => updateNodeColor(id, evt.target.value)}
  className="nodrag"
/>
```

We add the `nodrag` class name so that the user doesn't drag the node by mistake when changing the color and call the `updateNodeColor` in the `onChange` event handler.

<RemoteCodeViewer route="learn/state-management-2" framework="react" activeFile="ColorChooserNode.tsx" />

You can now click on a color chooser and change the background of a node.

### Testing

There are plenty of options to test a React application. If you want to test a React Flow application, we recommend to use [Cypress](https://www.cypress.io/) or [Playwright](https://playwright.dev/). React Flow needs to measure nodes in order to render edges and for that relies on rendering DOM elements.

#### Using Cypress or Playwright

If you are using Cypress or Playwright no additional setup is needed. You can refer to the getting started guide for [Cypress here](https://docs.cypress.io/guides/getting-started/installing-cypress) and for [Playwright here](https://playwright.dev/docs/intro).

#### Using Jest

If you are using [Jest](https://jestjs.io/), you need to mock some features in order to be able to run your tests. You can do that by adding this file to your project. Calling `mockReactFlow()` in a `setupTests` file (or inside a `beforeEach`) will trigger the necessary overrides.

```ts
// To make sure that the tests are working, it's important that you are using
// this implementation of ResizeObserver and DOMMatrixReadOnly
class ResizeObserver {
  callback: globalThis.ResizeObserverCallback;

  constructor(callback: globalThis.ResizeObserverCallback) {
    this.callback = callback;
  }

  observe(target: Element) {
    this.callback([{ target } as globalThis.ResizeObserverEntry], this);
  }

  unobserve() {}

  disconnect() {}
}

class DOMMatrixReadOnly {
  m22: number;
  constructor(transform: string) {
    const scale = transform?.match(/scale\(([1-9.])\)/)?.[1];
    this.m22 = scale !== undefined ? +scale : 1;
  }
}

// Only run the shim once when requested
let init = false;

export const mockReactFlow = () => {
  if (init) return;
  init = true;

  global.ResizeObserver = ResizeObserver;

  // @ts-ignore
  global.DOMMatrixReadOnly = DOMMatrixReadOnly;

  Object.defineProperties(global.HTMLElement.prototype, {
    offsetHeight: {
      get() {
        return parseFloat(this.style.height) || 1;
      },
    },
    offsetWidth: {
      get() {
        return parseFloat(this.style.width) || 1;
      },
    },
  });

  (global.SVGElement as any).prototype.getBBox = () => ({
    x: 0,
    y: 0,
    width: 0,
    height: 0,
  });
};
```

If you want to test mouse events with jest (for example inside your custom nodes), you need to disable `d3-drag` as it does not work outside of the browser:

```js
<ReactFlow nodesDraggable={false} panOnDrag={false} {...rest} />
```

import { Callout } from 'nextra/components';

### Usage with TypeScript

React Flow is written in TypeScript because we value the additional safety barrier it provides.
We export all the types you need for correctly typing data structures and functions you pass to the React Flow component. We also provide a way to extend the types of nodes and edges.

#### Basic usage

Let's start with the most basic types you need for a simple starting point. Typescript might already infer some of these types, but we will define them explicitly nonetheless.

```tsx
import { useState, useCallback } from 'react';
import {
  ReactFlow,
  addEdge,
  applyNodeChanges,
  applyEdgeChanges,
  type Node,
  type Edge,
  type FitViewOptions,
  type OnConnect,
  type OnNodesChange,
  type OnEdgesChange,
  type OnNodeDrag,
  type DefaultEdgeOptions,
} from '@xyflow/react';

const initialNodes: Node[] = [
  { id: '1', data: { label: 'Node 1' }, position: { x: 5, y: 5 } },
  { id: '2', data: { label: 'Node 2' }, position: { x: 5, y: 100 } },
];

const initialEdges: Edge[] = [{ id: 'e1-2', source: '1', target: '2' }];

const fitViewOptions: FitViewOptions = {
  padding: 0.2,
};

const defaultEdgeOptions: DefaultEdgeOptions = {
  animated: true,
};

const onNodeDrag: OnNodeDrag = (_, node) => {
  console.log('drag event', node.data);
};

function Flow() {
  const [nodes, setNodes] = useState<Node[]>(initialNodes);
  const [edges, setEdges] = useState<Edge[]>(initialEdges);

  const onNodesChange: OnNodesChange = useCallback(
    (changes) => setNodes((nds) => applyNodeChanges(changes, nds)),
    [setNodes],
  );
  const onEdgesChange: OnEdgesChange = useCallback(
    (changes) => setEdges((eds) => applyEdgeChanges(changes, eds)),
    [setEdges],
  );
  const onConnect: OnConnect = useCallback(
    (connection) => setEdges((eds) => addEdge(connection, eds)),
    [setEdges],
  );

  return (
    <ReactFlow
      nodes={nodes}
      edges={edges}
      onNodesChange={onNodesChange}
      onEdgesChange={onEdgesChange}
      onConnect={onConnect}
      onNodeDrag={onNodeDrag}
      fitView
      fitViewOptions={fitViewOptions}
      defaultEdgeOptions={defaultEdgeOptions}
    />
  );
}
```

##### Custom nodes

When working with [custom nodes](/learn/customization/custom-nodes) you have the possibility to pass a custom `Node` type (or your `Node` union) to the `NodeProps` type. There are basically two ways to work with custom nodes:

1. If you have **multiple custom nodes**, you want to pass a specific `Node` type as a generic to the `NodeProps` type:

```tsx filename="NumberNode.tsx"
import type { Node, NodeProps } from '@xyflow/react';

type NumberNode = Node<{ number: number }, 'number'>;

export default function NumberNode({ data }: NodeProps<NumberNode>) {
  return <div>A special number: {data.number}</div>;
}
```

⚠️ If you specify the node data separately, you need to use `type` (an `interface` would not work here):

```ts
type NumberNodeData = { number: number };
type NumberNode = Node<NumberNodeData, 'number'>;
```

2. If you have **one custom node** that renders different content based on the node type, you want to pass your `Node` union type as a generic to `NodeProps`:

```tsx filename="CustomNode.tsx"
import type { Node, NodeProps } from '@xyflow/react';

type NumberNode = Node<{ number: number }, 'number'>;
type TextNode = Node<{ text: string }, 'text'>;

type AppNode = NumberNode | TextNode;

export default function CustomNode({ data }: NodeProps<AppNode>) {
  if (data.type === 'number') {
    return <div>A special number: {data.number}</div>;
  }

  return <div>A special text: {data.text}</div>;
}
```

##### Custom edges

For [custom edges](/learn/customization/custom-nodes) you have the same possibility as for custom nodes.

```tsx filename="CustomEdge.tsx"
import { getStraightPath, BaseEdge, type EdgeProps, type Edge } from '@xyflow/react';

type CustomEdge = Edge<{ value: number }, 'custom'>;

export default function CustomEdge({
  id,
  sourceX,
  sourceY,
  targetX,
  targetY,
}: EdgeProps<CustomEdge>) {
  const [edgePath] = getStraightPath({ sourceX, sourceY, targetX, targetY });

  return <BaseEdge id={id} path={edgePath} />;
}
```

#### Advanced usage

When creating complex applications with React Flow, you will have a number of custom nodes & edges, each with different kinds of data attached to them.
When we operate on these nodes & edges through built in functions and hooks, we have to make sure that we [narrow down](https://www.typescriptlang.org/docs/handbook/2/narrowing.html)
the types of nodes & edges to prevent runtime errors.

##### `Node` and `Edge` type unions

You will see many functions, callbacks and hooks (even the ReactFlow component itself) that expect a `NodeType` or `EdgeType` generic. These generics are simply
[unions](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#union-types) of all the different types of nodes & edges you have in your application.
As long as you have typed the data objects correctly (see previous section), you can use their exported type.

<Callout type="info">
  If you use any of the built-in nodes ('input', 'output', 'default') or edges
  ('straight', 'step', 'smoothstep', 'bezier'), you can add the `BuiltInNode` and
  `BuiltInEdge` types exported from `@xyflow/react` to your union type.
</Callout>

```tsx
import type { BuiltInNode, BuiltInEdge } from '@xyflow/react';

// Custom nodes
import NumberNode from './NumberNode';
import TextNode from './TextNode';

// Custom edge
import EditableEdge from './EditableEdge';

export type CustomNodeType = BuiltInNode | NumberNode | TextNode;
export type CustomEdgeType = BuiltInEdge | EditableEdge;
```

##### Functions passed to `<ReactFlow />`

To receive correct types for callback functions, you can pass your union types to the `ReactFlow` component.
By doing that you will have to type your callback functions explicitly.

```tsx
import { type OnNodeDrag } from '@xyflow/react';

// ...

// Pass your union type here ...
const onNodeDrag: OnNodeDrag<CustomNodeType> = useCallback((_, node) => {
  if (node.type === 'number') {
    // From here on, Typescript knows that node.data
    // is of type { num: number }
    console.log('drag event', node.data.number);
  }
}, []);

const onNodesChange: OnNodesChange<CustomNodeType> = useCallback(
  (changes) => setNodes((nds) => applyNodeChanges(changes, nds)),
  [setNodes],
);
```

##### Hooks

The type unions can also be used to type the return values of many hooks.

```tsx filename="FlowComponent.tsx"
import { useReactFlow, useNodeConnections, useNodesData, useStore } from '@xyflow/react';

export default function FlowComponent() {
  // returned nodes and edges are correctly typed now
  const { getNodes, getEdges } = useReactFlow<CustomNodeType, CustomEdgeType>();

  // You can type useStore by typing the selector function
  const nodes = useStore((s: ReactFlowState<CustomNodeType>) => s.nodes);

  const connections = useNodeConnections({
    handleType: 'target',
  });

  const nodesData = useNodesData<CustomNodeType>(connections?.[0].source);

  nodeData.forEach(({ type, data }) => {
    if (type === 'number') {
      // This is type safe because we have narrowed down the type
      console.log(data.number);
    }
  });
  // ...
}
```

##### Type guards

There are multiple ways you can define [type guards](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#typeof-type-guards) in Typescript.
One way is to define type guard functions like `isNumberNode` or `isTextNode` to filter out specific nodes from a list of nodes.

```tsx
function isNumberNode(node: CustomNodeType): node is NumberNode {
  return node.type === 'number';
}

// numberNodes is of type NumberNode[]
const numberNodes = nodes.filter(isNumberNode);
```

import { Callout } from 'nextra/components';
import { RemoteCodeViewer } from 'xy-shared/server';

### Uncontrolled Flow

There are two ways to use React Flow - controlled or uncontrolled. Controlled means, that you are in control of the state of the nodes and edges. In an uncontrolled flow the state of the nodes and edges is handled by React Flow internally. In this part we will show you how to work with an uncontrolled flow.

An implementation of an uncontrolled flow is simpler, because you don't need to pass any handlers:

<RemoteCodeViewer route="learn/uncontrolled" framework="react" />

As you can see, we are passing `defaultEdgeOptions` to define that edges are animated. This is helpful, because you can't use the `onConnect` handler anymore to pass custom options to a newly created edge. Try to connect "Node B" with "Node C" and you see that the new edge is animated.

#### Updating nodes and edges

Since you don't have nodes and edges in your local state, you can't update them directly. To do so, you need to use the [React Flow instance](/api-reference/types/react-flow-instance) that comes with functions for updating the internal state. You can receive the instance via the `onInit` callback or better by using the [`useReactFlow` hook](/api-reference/hooks/use-react-flow). Let's create a button that adds a new node at a random position. For this, we are wrapping our flow with the [`ReactFlowProvider`](/api-reference/react-flow-provider) and use the [`addNodes` function](/api-reference/types/react-flow-instance#nodes-and-edges).

<Callout>
  The `Flow` component in this example is wrapped with the `ReactFlowProvider`
  to use the `useReactFlow` hook.
</Callout>

<RemoteCodeViewer route="learn/uncontrolled-2" framework="react" />

import ProExampleViewer from '@/components/pro-example-viewer';
import { Callout } from 'nextra/components';
import { RemoteCodeViewer } from 'xy-shared/server';

### Whiteboard Features

React Flow is designed for building node-based UIs like workflow editors, flowcharts and
diagrams. Even if React Flow is not made for creating whiteboard applications, you might
want to integrate common whiteboard features. These examples show how to add drawing
capabilities to your applications when you need to annotate or sketch alongside your nodes
and edges.

#### Examples

##### ✏️ Freehand draw (Pro)

Draw smooth curves on your React Flow pane. Useful for annotations or sketching around
existing nodes.

**Features:**

* Mouse/touch drawing
* Adjustable brush size and color
* converts drawn paths into custom nodes

**Common uses:**

* Annotating flowcharts
* Adding notes to diagrams
* Sketching ideas around nodes

<ProExampleViewer slug="freehand-draw" innerClassName="flex flex-col-reverse" />

##### 🎯 Lasso selection

Select multiple elements by drawing a freeform selection area with an option to include
partially selected elements.

**Features:**

* Freeform selection shapes
* partial selection of elements

**Common uses:**

* Selecting nodes and annotations together
* Complex selections in mixed content

<RemoteCodeViewer route="examples/whiteboard/lasso-selection" framework="react" />

##### 🧹 Eraser

Remove items by "erasing" over them. Uses collision detection to determine what to delete.

**Features:**

* Collision-based erasing
* Visual eraser cursor

**Common uses:**

* Removing parts of a flow

<RemoteCodeViewer route="examples/whiteboard/eraser" framework="react" />

##### 📐 Rectangle draw

Create rectangular shapes by clicking and dragging. Good for highlighting areas or
creating backgrounds for node groups.

**Features:**

* Click-and-drag rectangle creation
* Customizable colors

**Common uses:**

* Creating background containers
* Grouping related nodes visually
* Highlighting sections of diagrams

<RemoteCodeViewer route="examples/whiteboard/rectangle" framework="react" />

#### Whiteboard libraries

If you are looking for a more complete whiteboard solution, consider using libraries that
are specifically designed for whiteboard applications like [tldraw](https://tldraw.dev/)
or [Excalidraw](https://docs.excalidraw.com/). These libraries provide a full set of
features for collaborative drawing, shapes, text, and more.

import { Callout, Steps } from 'nextra/components';
import { RemoteCodeViewer } from 'xy-shared/server';

### Adding Interactivity

Now that we've built our [first flow](learn/concepts/building-a-flow), let's add
interactivity so you can select, drag, and remove nodes and edges.

#### Handling change events

By default React Flow doesn't manage any internal state updates besides handling the
viewport. As you would with an HTML `<input />` element you need to pass
[event handlers](/api-reference/react-flow#event-handlers) to React Flow in order to apply
triggered changes to your nodes and edges.

<Steps>
  ##### Add imports

  To manage changes, we'll be using `useState` with two helper functions from React Flow:
  [`applyNodeChanges`](/api-reference/utils/apply-node-changes) and
  [`applyEdgeChanges`](/api-reference/utils/apply-edge-changes). So let's import these
  functions:

  ```jsx
  import { useState, useCallback } from 'react';
  import { ReactFlow, applyEdgeChanges, applyNodeChanges } from '@xyflow/react';
  ```

  ##### Define nodes and edges

  We need to define initial nodes and edges. These will be the starting point for our flow.

  ```jsx
  const initialNodes = [
    {
      id: 'n1',
      position: { x: 0, y: 0 },
      data: { label: 'Node 1' },
      type: 'input',
    },
    {
      id: 'n2',
      position: { x: 100, y: 100 },
      data: { label: 'Node 2' },
    },
  ];

  const initialEdges = [
    {
      id: 'n1-n2',
      source: 'n1',
      target: 'n2',
    },
  ];
  ```

  ##### Initialize state

  In our component, we'll call the `useState` hook to manage the state of our nodes and
  edges:

  ```jsx {2-3}
  export default function App() {
    const [nodes, setNodes] = useState(initialNodes);
    const [edges, setEdges] = useState(initialEdges);

    return (
      <div style={{ height: '100%', width: '100%' }}>
        <ReactFlow>
          <Background />
          <Controls />
        </ReactFlow>
      </div>
    );
  }
  ```

  ##### Add event handlers

  We need to create two event handlers:
  [`onNodesChange`](/api-reference/react-flow#onnodeschange) and
  [`onEdgesChange`](/api-reference/react-flow#onedgeschange). They will be used to update
  the state of our nodes and edges when changes occur, such as dragging or deleting an
  element. Go ahead and add these handlers to your component:

  ```jsx
  const onNodesChange = useCallback(
    (changes) => setNodes((nodesSnapshot) => applyNodeChanges(changes, nodesSnapshot)),
    [],
  );
  const onEdgesChange = useCallback(
    (changes) => setEdges((edgesSnapshot) => applyEdgeChanges(changes, edgesSnapshot)),
    [],
  );
  ```

  ##### Pass them to ReactFlow

  Now we can pass our nodes, edges, and event handlers to the `<ReactFlow />` component:

  ```jsx {2-5}
  <ReactFlow
    nodes={nodes}
    edges={edges}
    onNodesChange={onNodesChange}
    onEdgesChange={onEdgesChange}
    fitView
  >
    <Background />
    <Controls />
  </ReactFlow>
  ```

  ##### Interactive flow

  And that's it! You now have a basic interactive flow 🎉

  When you drag or select a node, the `onNodesChange` handler is triggered. The
  `applyNodeChanges` function then uses these change events to update the current state of
  your nodes. Here's how it all comes together. Try clicking and dragging a node to move it
  around and watch the UI update in real time.

  <RemoteCodeViewer route="learn/make-it-interactive-1" framework="react" aspectRatio="4" />
</Steps>

#### Handling connections

One last piece is missing: connecting nodes interactively. For this, we need to implement
an [`onConnect`](/api-reference/react-flow#onconnect) handler.

<Steps>
  ##### Create `onConnect` handler

  The `onConnect` handler is called whenever a new connection is made between two nodes. We
  can use the [`addEdge`](/api-reference/utils/add-edge) utility function to create a new
  edge and update the edge Array.

  ```jsx
  const onConnect = useCallback(
    (params) => setEdges((edgesSnapshot) => addEdge(params, edgesSnapshot)),
    [],
  );
  ```

  ##### Pass it to ReactFlow

  Now we can pass the `onConnect` handler to the `<ReactFlow />` component:

  ```jsx {6}
  <ReactFlow
    nodes={nodes}
    edges={edges}
    onNodesChange={onNodesChange}
    onEdgesChange={onEdgesChange}
    onConnect={onConnect}
    fitView
  >
    <Background />
    <Controls />
  </ReactFlow>
  ```

  ##### Connectable flow

  Try to connect the two nodes by dragging from on handle to another one. The `onConnect`
  handler will be triggered, and the new edge will be added to the flow. 🥳

  <RemoteCodeViewer aspectRatio="4" route="learn/make-it-interactive-2" framework="react" />
</Steps>

#### Full code example 🏁

<RemoteCodeViewer route="learn/make-it-interactive-2" framework="react" />

What is happening here? Whenever React Flow triggers a change (node init, node drag, edge
select, etc.), the `onNodesChange` handler gets called. We export an `applyNodeChanges`
handler so that you don't need to handle the changes by yourself. The `applyNodeChanges`
handler returns an updated array of nodes that is your new nodes array. You now have an
interactive flow with the following capabilities:

* selectable nodes and edges
* draggable nodes
* connectable nodes by dragging from one node handle to another
* multi-selection area by pressing `shift` -- the default
  [`selectionKeyCode`](/api-reference/react-flow#selectionkeycode)
* multi-selection by pressing `cmd` -- the default
  [`multiSelectionKeyCode`](/api-reference/react-flow#multiselectionkeycode)
* removing selected elements by pressing `backspace` -- the default
  [`deleteKeyCode`](/api-reference/react-flow#deletekeycode)

If you want to jump straight into creating your own application, we recommend checking out
the [Customization](/learn/customization) section. Otherwise keep reading to learn more
about React Flows capabilities.

import { Callout, Steps } from 'nextra/components';
import { RemoteCodeViewer } from 'xy-shared/server';

### Building a Flow

In the following pages we will introduce you to the core concepts of React Flow and
explain how to create a basic interactive flow. A flow consists of
[nodes](/api-reference/types/node), [edges](/api-reference/types/edge) and the viewport.

To follow along with this guide you will need to have a React project set up and install
the `@xyflow/react` package:

```bash copy npm2yarn
npm install @xyflow/react
```

#### Creating the flow

Let's start by creating an empty flow with viewport
[`<Controls />`](/api-reference/components/controls) and a dotted
[`<Background />`](/api-reference/components/background).

<Steps>
  ##### Add imports

  First, we need to import some basic components from the `@xyflow/react` package
  and the **css stylesheet**, which is **required** for React Flow to work:

  ```jsx "import '@xyflow/react/dist/style.css';"
  import { ReactFlow, Background, Controls } from '@xyflow/react';
  import '@xyflow/react/dist/style.css';
  ```

  ##### Render ReactFlow

  Now we create a React component, that renders our flow. The **width and height** on the
  parent container are **required** because React Flow uses these dimensions.

  ```jsx "height: '100%', width: '100%'"
  export default function App() {
    return (
      <div style={{ height: '100%', width: '100%' }}>
        <ReactFlow>
          <Background />
          <Controls />
        </ReactFlow>
      </div>
    );
  }
  ```

  ##### Empty flow

  That's it! You have created your first empty flow 🎉

  <RemoteCodeViewer aspectRatio="4" route="learn/building-a-flow-1" framework="react" />
</Steps>

#### Adding nodes

Now that the flow is set up, it's time to add nodes — each node represents an element in
your diagram with a specific position and content.

<Steps>
  ##### Create node objects

  Outside of your React component, create an array of [node](/api-reference/types/node)
  objects. Each node object needs a unique `id` and a `position`. Let's also add a label to
  them:

  ```jsx
  const initialNodes = [
    {
      id: 'n1',
      position: { x: 0, y: 0 },
      data: { label: 'Node 1' },
      type: 'input',
    },
    {
      id: 'n2',
      position: { x: 100, y: 100 },
      data: { label: 'Node 2' },
    },
  ];
  ```

  ##### Add nodes to the flow

  Now we can pass our `initialNodes` array to the `<ReactFlow />` component using the
  `nodes` prop:

  ```jsx "nodes={initialNodes}"
  <ReactFlow nodes={initialNodes}>
    <Background />
    <Controls />
  </ReactFlow>
  ```

  ##### Flow with nodes

  This gives us a flow with two labeled nodes 🎉

  <RemoteCodeViewer aspectRatio="4" route="learn/building-a-flow-2" framework="react" />
</Steps>

We have several built-in nodes that you can explore in the
[node](/api-reference/types/node) reference. However, once you start building your own
application, you will want to use [custom nodes](/learn/customization/custom-nodes).

#### Adding edges

Now that we have two nodes, let's connect them with an edge.

<Steps>
  ##### Create an edge

  To create an edge, we define an array of [edge](/api-reference/types/edge) objects. Each
  edge object needs to have an `id`, a `source` (where the edge begins), and a `target`
  (where it ends). In this example, we use the `id` values of the two nodes we created so
  far (`n1` and `n2`) to define the edge:

  ```js
  const initialEdges = [
    {
      id: 'n1-n2',
      source: 'n1',
      target: 'n2',
    },
  ];
  ```

  This edge connects the node with `id: 'n1'` (the source) to the node with `id: 'n2'` (the
  target).

  <RemoteCodeViewer aspectRatio="4" route="learn/building-a-flow-3" framework="react" />

  ##### Label the edge

  Let's give this edge two properties that are built into React Flow, a `label` and a
  `type: "step"`.

  ```jsx {6-7}
  const initialEdges = [
    {
      id: 'n1-n2',
      source: 'n1',
      target: 'n2',
      type: 'step',
      label: 'connects with',
    },
  ];
  ```

  ##### Basic flow

  Now we have completed a basic flow with nodes and edges! 🎉

  <RemoteCodeViewer aspectRatio="4" route="learn/building-a-flow-4" framework="react" />
</Steps>

#### Full code example 🏁

<RemoteCodeViewer route="learn/building-a-flow-4" framework="react" />

You took your first steps in React Flow! You might have realized that you can't drag or
otherwise interact with nodes. On the next page you'll learn how to make the flow
interactive.

import { RemoteCodeViewer } from 'xy-shared/server';

### Built-In Components

React Flow comes with several built-in components that can be passed as children to the [`<ReactFlow />`](/api-reference/react-flow) component.

#### MiniMap

The [`MiniMap`](/api-reference/components/minimap) provides a bird’s-eye view of your flowgraph, making navigation easier, especially for larger flows. You can customize the appearance of nodes in the minimap by providing a nodeColor function.

<RemoteCodeViewer aspectRatio="2" route="learn/mini-map" framework="react" />

#### Controls

React Flow comes with a set of customizable [`Controls`](/api-reference/components/controls) for the viewport. You can zoom in and out, fit the viewport and toggle if the user can move, select and edit the nodes.

<RemoteCodeViewer aspectRatio="2" route="learn/controls" framework="react" />

#### Background

The [`Background`](/api-reference/components/background) component adds a visual grid pattern to your flowgraph, helping users maintain orientation. You can choose from different pattern variants, or if you need more advanced customization, you can explore the [source](https://github.com/xyflow/xyflow/blob/main/packages/react/src/additional-components/Background/Background.tsx) code to implement your own pattern.

<RemoteCodeViewer aspectRatio="2" route="learn/background" framework="react" />

#### Panel

The [`Panel`](/api-reference/components/panel) component allows you to add fixed overlays to your flowgraph, perfect for titles, controls, or any other UI elements that should remain stationary.

<RemoteCodeViewer aspectRatio="2" route="learn/panel" framework="react" />

#### Advanced

For more advanced use cases and customization, we have even more built-in components you can check out in the [API components overview](/api-reference/components)

import { RemoteCodeViewer } from 'xy-shared/server';

### Overview

At its core, React Flow is about creating interactive flowgraphs -- a collection of nodes connected by edges.
To help you understand the terminology we use throughout the documentation, let's take a look at the example flow below.

<RemoteCodeViewer route="learn/basic-terms" framework="react" />

##### Nodes

React Flow has a few default node types out of the box, but customization is where the magic of React Flow truly happens.
You can design your nodes to work exactly the way you need them to—whether that’s embedding interactive form elements,
displaying dynamic data visualizations, or even incorporating multiple connection handles. React Flow lays the foundation,
and your imagination does the rest.

We have a guide on creating your own [Custom Nodes](/learn/customization/custom-nodes)
and you can find all the options for customizing your nodes in the [Node](/api-reference/types/node) reference.

##### Handles

A handle (also known as a “port” in other libraries) is the attachment point where an edge connects to a node.
By default, they appear as grey circles on the top, bottom, left, or right sides of a node.
But they are just `div` elements, and can be positioned and styled any way you’d like.
When creating a custom node, you can include as many handles as needed.
For more information, refer to the [Handle](/learn/customization/handles) page.

##### Edges

Edges connect nodes. Every edge needs a target and a source node.
React Flow comes with four built-in [edge types](/examples/edges/edge-types):
`default` (bezier), `smoothstep`, `step`, and `straight`.
An edge is a SVG path that can be styled with CSS and is completely customizable.
If you are using multiple handles, you can reference them individually to create multiple connections for a node.

Like custom nodes, you can also customize edges. Things that people do with custom edges include:

* Adding buttons to remove edges
* Custom routing behavior
* Complex styling or interactions that cannot be solved with just one SVG path

For more information, refer to the [Edges](/learn/customize/edges) page.

##### Connection line

React Flow has built-in functionality that allows you to click and drag from one handle to another to create a new edge.
While dragging, the placeholder edge is referred to as a connection line.
The connection line comes with the same four built-in types as edges and is customizable.
You can find the props for configuring the connection line in the [connection props](/api-reference/react-flow#connection-line-props) reference.

##### Viewport

All of React Flow is contained within the viewport. Each node has an x- and y-coordinate, which indicates its position within the viewport. The viewport has x, y, and zoom values. When you drag the pane, you change the x and y coordinates. When you zoom in or out, you alter the zoom level.

import { RemoteCodeViewer } from 'xy-shared/server';

### Panning and Zooming

The default pan and zoom behavior of React Flow is inspired by
[slippy maps](https://wiki.openstreetmap.org/wiki/Slippy_map). You pan by dragging your
pointer and zoom by scrolling. You can customize this behavior easily with the
[interaction](/api-reference/react-flow#interaction-props) and
[keyboard](/api-reference/react-flow#keyboard-props) props on the `<ReactFlow />`
component.

#### Viewport configurations

Here we will list and explain some configurations that other tools use.

##### Default viewport controls

As mentioned above, the ReactFlow default controls are as follows:

* `pan:` pointer drag
* `zoom:` pinch or scroll
* `select:` shift + pointer drag

<RemoteCodeViewer aspectRatio="3" route="learn/zoom-pan" framework="react" />

##### Design tool viewport controls

If you prefer figma/sketch/design tool controls you can set
[`panOnScroll`](/api-reference/react-flow#panonscroll) and
[`selectionOnDrag`](/api-reference/react-flow#selectionondrag) to `true` and
[`panOnDrag`](/api-reference/react-flow#panondrag) to `false`:

* `pan:` scroll, middle / right mouse drag, space + pointer drag
* `zoom:` pinch or cmd + scroll
* `select:` pointer drag

<RemoteCodeViewer aspectRatio="3" route="learn/zoom-pan-2" framework="react" />

In this example we also set `selectionMode="partial"` to be able to add nodes to a
selection that are only partially selected.

import { Callout, Steps } from 'nextra/components';
import { Image } from 'xy-shared';
import { RemoteCodeViewer } from 'xy-shared/server';

### Custom Edges

Like [custom nodes](/learn/customization/custom-nodes), parts of a custom edge
in React Flow are just React components. That means you can render anything you
want along an edge! This guide shows you how to implement a custom edge with
some additional controls. For a comprehensive reference of props available for
custom edges, see the [Edge](/api-reference/types/edge-props) reference.

#### A basic custom edge

An edge isn't much use to us if it doesn't render a path between two connected
nodes. These paths are always SVG-based and are typically rendered using the
[`<BaseEdge />`](/api-reference/components/base-edge) component. To calculate
the actual SVG path to render, React Flow comes with some handy utility functions:

* [`getBezierPath`](/api-reference/utils/get-bezier-path)
* [`getSimpleBezierPath`](/api-reference/utils/get-simple-bezier-path)
* [`getSmoothStepPath`](/api-reference/utils/get-smooth-step-path)
* [`getStraightPath`](/api-reference/utils/get-straight-path)

To kickstart our custom edge, we'll just render a straight path between the
source and target.

<Steps>
  ##### Create the component

  We start by creating a new React component called `CustomEdge`. Then we render
  the [`<BaseEdge />`](/api-reference/components/base-edge) component with the
  calculated path. This gives us a straight edge that behaves the same as the
  built-in default [edge version](/api-reference/types/edge#default-edge-types)
  `"straight"`.

  ```jsx
  import { BaseEdge, getStraightPath } from '@xyflow/react';

  export function CustomEdge({ id, sourceX, sourceY, targetX, targetY }) {
    const [edgePath] = getStraightPath({
      sourceX,
      sourceY,
      targetX,
      targetY,
    });

    return (
      <>
        <BaseEdge id={id} path={edgePath} />
      </>
    );
  }
  ```

  ##### Create `edgeTypes`

  Outside of our component, we define an `edgeTypes` object.
  We name our new edge type `"custom-edge"` and assign the `CustomEdge` component
  we just created to it.

  ```jsx
  const edgeTypes = {
    'custom-edge': CustomEdge,
  };
  ```

  ##### Pass the `edgeTypes` prop

  To use it, we also need to update the
  [`edgeTypes`](/api-reference/react-flow#edge-types) prop on the
  `<ReactFlow />` component.

  ```jsx "edgeTypes={edgeTypes}"
  export function Flow() {
    return <ReactFlow edgeTypes={edgeTypes} />;
  }
  ```

  ##### Use the new edge type

  After defining the `edgeTypes` object, we can use our new custom edge by setting
  the `type` field of an edge to `"custom-edge"`.

  ```jsx {6}
  const initialEdges = [
    {
      id: 'e1',
      source: 'n1',
      target: 'n2',
      type: 'custom-edge',
    },
  ];
  ```

  ##### Flow with a custom edge

  <RemoteCodeViewer route="learn/custom-edge" framework="react" />
</Steps>

#### Custom SVG edge paths

As discussed previously, if you want to make a custom edge in React Flow, you
have to use either of the four path creation functions discussed above
(e.g [`getBezierPath`](/api-reference/utils/get-bezier-path)). However if you
want to make some other path shape like a Sinusoidal edge or some other edge
type then you will have to make the edge path yourself.

The edge path we get from functions like
[`getBezierPath`](/api-reference/utils/get-bezier-path) is just a path string
which we pass into the `path` prop of the `<BaseEdge />` component. It contains
the necessary information needed in order to draw that path, like where it
should start from, where it should curve, where it should end, etc. A simple
straight path string between two points `(x1, y1)` to `(x2, y2)` would look like:

```jsx
M x1 y1 L x2 y2
```

An SVG path is a concatenated list of commands like `M`, `L`, `Q`, etc, along
with their values. Some of these commands are listed below, along with their
supported values.

* `M x1 y1` is the Move To command which moves the current point to the x1, y1
  coordinate.
* `L x1 y1` is the Line To command which draws a line from the current point to
  x1, y1 coordinate.
* `Q x1 y1 x2 y2` is the Quadratic Bezier Curve command which draws a bezier
  curve from the current point to the x2, y2 coordinate. x1, y1 is the control
  point of the curve which determines the curviness of the curve.

Whenever we want to start a path for our custom edge, we use the `M` command to
move our current point to `sourceX, sourceY` which we get as props in the custom
edge component. Then based on the shape we want, we will use other commands like
`L`(to make lines), `Q`(to make curves) and then finally end our path at
`targetX, targetY` which we get as props in the custom edge component.

If you want to learn more about SVG paths, you can check out
[SVG-Path-Editor](https://yqnn.github.io/svg-path-editor/). You can paste any
SVG path there and analyze individual path commands via an intuitive UI.

Here is an example with two types of custom edge paths, a Step edge and a
Sinusoidal edge. You should look at the Step edge first to get your hands dirty
with custom SVG paths since it's simple, and then look at how the Sinusoidal
edge is made. After going through this example, you will have the necessary
knowledge to make custom SVG paths for your custom edges.

<RemoteCodeViewer route="learn/custom-edge-path" framework="react" />

import { Callout, Steps } from 'nextra/components';
import { RemoteCodeViewer } from 'xy-shared/server';

### Custom Nodes

A powerful feature of React Flow is the ability to create custom nodes. This gives you the
flexibility to render anything you want within your nodes. We generally recommend creating
your own custom nodes rather than relying on built-in ones. With custom nodes, you can add
as many source and target [handles](/learn/customization/handles) as you like—or even
embed form inputs, charts, and other interactive elements.

In this section, we'll walk through creating a custom node featuring an input field that
updates text elsewhere in your application. For further examples, we recommend checking
out our [Custom Node Example](/examples/nodes/custom-node).

#### Implementing a custom node

To create a custom node, all you need to do is create a React component. React Flow will
automatically wrap it in an interactive container that injects essential props like the
node's id, position, and data, and provides functionality for selection, dragging, and
connecting handles. For a full overview on all available node props, see the
[Node](/api-reference/types/node-props) reference.

<Steps>
  ##### Create the component

  Let's dive into an example by creating a custom node called `TextUpdaterNode`. For this,
  we've added a simple input field with a change handler.

  ```jsx
  export function TextUpdaterNode(props) {
    const onChange = useCallback((evt) => {
      console.log(evt.target.value);
    }, []);

    return (
      <div className="text-updater-node">
        <div>
          <label htmlFor="text">Text:</label>
          <input id="text" name="text" onChange={onChange} className="nodrag" />
        </div>
      </div>
    );
  }
  ```

  ##### Initialize nodeTypes

  You can add a new node type to React Flow by adding it to the `nodeTypes` prop like below.
  We define the `nodeTypes` outside of the component to prevent re-renderings.

  ```jsx
  const nodeTypes = {
    textUpdater: TextUpdaterNode,
  };
  ```

  ##### Pass nodeTypes to React Flow

  ```jsx {4}
  <ReactFlow
    nodes={nodes}
    edges={edges}
    nodeTypes={nodeTypes}
    onNodesChange={onNodesChange}
    onEdgesChange={onEdgesChange}
    fitView
  />
  ```

  ##### Update node definitions

  After defining your new node type, you can use it by specifying the `type` property on
  your node definition:

  ```jsx {4}
  const nodes = [
    {
      id: 'node-1',
      type: 'textUpdater',
      position: { x: 0, y: 0 },
      data: { value: 123 },
    },
  ];
  ```

  ##### Flow with custom node

  After putting all together and adding some basic styles we get a custom node that prints
  text to the console:

  <RemoteCodeViewer aspectRatio="4" route="learn/custom-node" framework="react" />
</Steps>

#### Full code example 🏁

<RemoteCodeViewer route="learn/custom-node" framework="react" />

To enable your custom node to connect with other nodes, check out the
[Handles](/learn/customization/handles) page to learn how to add source and target
handles.

import { RemoteCodeViewer } from 'xy-shared/server';
import { Callout } from 'nextra/components';
import { Image } from 'xy-shared';

### Edge Labels

One of the more common uses for [custom edges](/learn/customization/custom-edges) is rendering some controls or info
along an edge's path. In React Flow we call that an *custom edge label* and unlike the
edge path, edge labels can be any React component!

#### Adding an edge label

To render a custom edge label we must wrap it in the
[`<EdgeLabelRenderer />`](/api-reference/components/edge-label-renderer) component.
This allows us to render the labels outside of the SVG world where the edges life.
The edge label renderer is a portal to a single container that *all* edge labels are rendered into.

Let's add a button to our custom edge that can be used to delete the edge it's
attached to:

```jsx
import {
  BaseEdge,
  EdgeLabelRenderer,
  getStraightPath,
  useReactFlow,
} from '@xyflow/react';

export default function CustomEdge({ id, sourceX, sourceY, targetX, targetY }) {
  const { deleteElements } = useReactFlow();
  const [edgePath] = getStraightPath({
    sourceX,
    sourceY,
    targetX,
    targetY,
  });

  return (
    <>
      <BaseEdge id={id} path={edgePath} />
      <EdgeLabelRenderer>
        <button onClick={() => deleteElements({ edges: [{ id }] })}>delete</button>
      </EdgeLabelRenderer>
    </>
  );
}
```

If we try to use this edge now, we'll see that the button is rendered in the
centre of the flow (it might be hidden behind "Node A"). Because of the edge
label portal, we'll need to do some extra work to position the button ourselves.

<Image
  src="/img/learn/edge-label-renderer-position.png"
  alt="A screen shot of a simple flow. The edge label renderer is highlighted in
the DOM inspector and the button is rendered in the centre of the flow."
/>

Fortunately, the path utils we've already seen can help us with this! Along with
the SVG path to render, these functions also return the `x` and `y` coordinates
of the path's midpoint. We can then use these coordinates to translate our custom
edge label's into the right position!

```jsx
export default function CustomEdge({ id, sourceX, sourceY, targetX, targetY }) {
  const { deleteElements } = useReactFlow();
  const [edgePath, labelX, labelY] = getStraightPath({ ... });

  return (
    ...
        <button
          style={{
            position: 'absolute',
            transform: `translate(-50%, -50%) translate(${labelX}px, ${labelY}px)`,
            pointerEvents: 'all',
          }}
          className="nodrag nopan"
          onClick={() => deleteElements({ edges: [{ id }] })}
        >
    ...
  );
}
```

<Callout type="info">
  To make sure our edge labels are interactive and not just for presentation, it
  is important to add `pointer-events: all` to the label's style. This will ensure
  that the label is clickable.

  And just like with interactive controls in custom nodes, we need to remember
  to add the `nodrag` and `nopan` classes to the label to stop mouse events from
  controlling the canvas.
</Callout>

Here's an interactive example with our updated custom edge. Clicking the delete
button will remove that edge from the flow. Creating a new edge will use the
custom node.

<RemoteCodeViewer route="learn/custom-edge-2" framework="react" />

import { RemoteCodeViewer } from 'xy-shared/server';
import { Callout } from 'nextra/components';

### Handles

Handles are the connection points on
[nodes](/learn/concepts/terms-and-definitions#nodes) in React Flow. Our built-in
nodes include one source and one target handle, but you can customize your nodes
with as many different handles as you need.

#### Creating a node with handles

To create a [custom node](/learn/customization/custom-nodes) with handles, you
can use the [`<Handle />`](/api-reference/components/handle) component provided
by React Flow. This component allows you to define source and target handles for
your custom nodes. Here's an example of how to implement a custom node with two
handles:

```jsx {7-8}
import { Handle } from '@xyflow/react';

export function CustomNode() {
  return (
    <div className="custom-node">
      <div>Custom Node Content</div>
      <Handle type="source" position="top" />
      <Handle type="target" position="bottom" />
    </div>
  );
}
```

#### Using multiple handles

If you want to use multiple source or target handles in your custom node, you
need to specify each handle with a unique `id`. This allows React Flow to
differentiate between the handles when connecting edges.

```jsx /id="a"/ /id="b"/
  <Handle type="target" position="top" />
  <Handle type="source" position="right" id="a" />
  <Handle type="source" position="bottom" id="b" />
```

To connect an edge to a specific handle of a node, use the properties
`sourceHandle` (for the edge's starting point) and `targetHandle` (for the
edge's ending point). By defining `sourceHandle` or `targetHandle` with the
appropriate handle `id`, you instruct React Flow to attach the edge to that
specific handle, ensuring that connections are made where you intend.

```js "sourceHandle: 'a'" "sourceHandle: 'b'"
const initialEdges = [
  { id: 'n1-n2', source: 'n1', sourceHandle: 'a', target: 'n2' },
  { id: 'n1-n3', source: 'n1', sourceHandle: 'b', target: 'n3' },
];
```

In this case, the source node is `n1` for both handles but the handle `id`s are
different. One comes from handle id `a` and the other one from `b`. Both edges
also have different target nodes:

<RemoteCodeViewer route="learn/custom-node-2" framework="react" />

#### Custom handles

You can create your own custom handles by wrapping the
[`<Handle />`](/api-reference/components/handle) component.
This example shows a custom handle that only allows connections when the
connection source matches a given id.

```jsx
import { Handle, Position } from '@xyflow/react';

export function TargetHandleWithValidation({ position, source }) {
  return (
    <Handle
      type="target"
      position={position}
      isValidConnection={(connection) => connection.source === source}
      onConnect={(params) => console.log('handle onConnect', params)}
      style={{ background: '#fff' }}
    />
  );
}
```

#### Typeless handles

If you want to create a handle that does not have a specific type (source or
target), you can set [connectionMode](/api-reference/react-flow#connectionmode)
to `Loose` in the `<ReactFlow />` component. This allows the handle to be used
for both incoming and outgoing connections.

#### Dynamic handles

If you are programmatically changing the position or number of handles in your
custom node, you need to update the node internals with the
[`useUpdateNodeInternals`](/api-reference/hooks/use-update-node-internals) hook.

#### Custom handle styles

Since the handle is a div, you can use CSS to style it or pass a style prop to
customize a Handle. You can see this in the
[Add Node On Edge Drop](/examples/nodes/add-node-on-edge-drop) and
[Simple Floating Edges](/examples/edges/simple-floating-edges) examples.

##### Styling handles when connecting

The handle receives the additional class names `connecting` when the connection
line is above the handle and `valid` if the connection is valid. You can find an
example which uses these classes [here](/examples/interaction/validation).

##### Hiding handles

If you need to hide a handle for some reason, you must use `visibility: hidden`
or `opacity: 0` instead of `display: none`. This is important because React
Flow needs to calculate the dimensions of the handle to work properly and using
`display: none` will report a width and height of `0`!

import { Callout } from 'nextra/components';
import { RemoteCodeViewer } from 'xy-shared/server';

### Theming

React Flow has been built with deep customization in mind. Many of our users
fully transform the look and feel of React Flow to match their own brand or design
system. This guide will introduce you to the different ways you can customize
React Flow's appearance.

#### Default styles

React Flow's default styles are enough to get going with the built-in nodes. They
provide some sensible defaults for styles like padding, border radius, and animated
edges. You can see what they look like below:

<RemoteCodeViewer route="examples/styling/default-style" framework="react" />

You'll typically load these default styles by importing them in you `App.jsx`
file or other entry point:

```js
import '@xyflow/react/dist/style.css';
```

Without dipping into [custom nodes](/examples/nodes/custom-node) and
[edges](/examples/edges/custom-edges), there are three ways you can style
React Flow's basic look:

* Passing inline styles through `style` props
* Overriding the built-in classes with custom CSS
* Overriding the CSS variables React Flow uses

##### Built in dark and light mode

You can choose one of the built-in color modes by using the `colorMode` prop ('dark', 'light' or 'system') as seen in the [dark mode example](/examples/styling/dark-mode).

```jsx
import ReactFlow from '@xyflow/react';

export default function Flow() {
  return <ReactFlow colorMode="dark" nodes={[...]} edges={[...]} />
}
```

When you use the `colorMode` prop, React Flow adds a class to the root element (`.react-flow`) that you can use to style your flow based on the color mode:

```css
.dark .react-flow__node {
  background: #777;
  color: white;
}

.light .react-flow__node {
  background: white;
  color: #111;
}
```

##### Customizing with `style` props

The easiest way to start customizing the look and feel of your flows is to use
the `style` prop found on many of React Flow's components to inline your own
CSS.

```jsx
import ReactFlow from '@xyflow/react'

const styles = {
  background: 'red',
  width: '100%',
  height: 300,
};

export default function Flow() {
  return <ReactFlow style={styles} nodes={[...]} edges={[...]} />
}
```

##### CSS variables

If you don't want to replace the default styles entirely but just want to tweak
the overall look and feel, you can override some of the CSS variables we use
throughout the library. For an example of how to use these CSS variables, check out our [Feature Overview](/examples/overview) example.

These variables are mostly self-explanatory. Below is a table of all the variables
you might want to tweak and their default values for reference:

| Variable name                                         | Default                             |
| :---------------------------------------------------- | :---------------------------------- |
| `--xy-edge-stroke-default`                            | `#b1b1b7`                           |
| `--xy-edge-stroke-width-default`                      | `1`                                 |
| `--xy-edge-stroke-selected-default`                   | `#555`                              |
| `--xy-connectionline-stroke-default`                  | `#b1b1b7`                           |
| `--xy-connectionline-stroke-width-default`            | `1`                                 |
| `--xy-attribution-background-color-default`           | `rgba(255, 255, 255, 0.5)`          |
| `--xy-minimap-background-color-default`               | `#fff`                              |
| `--xy-background-pattern-dots-color-default`          | `#91919a`                           |
| `--xy-background-pattern-line-color-default`          | `#eee`                              |
| `--xy-background-pattern-cross-color-default`         | `#e2e2e2`                           |
| `--xy-node-color-default`                             | `inherit`                           |
| `--xy-node-border-default`                            | `1px solid #1a192b`                 |
| `--xy-node-background-color-default`                  | `#fff`                              |
| `--xy-node-group-background-color-default`            | `rgba(240, 240, 240, 0.25)`         |
| `--xy-node-boxshadow-hover-default`                   | `0 1px 4px 1px rgba(0, 0, 0, 0.08)` |
| `--xy-node-boxshadow-selected-default`                | `0 0 0 0.5px #1a192b`               |
| `--xy-handle-background-color-default`                | `#1a192b`                           |
| `--xy-handle-border-color-default`                    | `#fff`                              |
| `--xy-selection-background-color-default`             | `rgba(0, 89, 220, 0.08)`            |
| `--xy-selection-border-default`                       | `1px dotted rgba(0, 89, 220, 0.8)`  |
| `--xy-controls-button-background-color-default`       | `#fefefe`                           |
| `--xy-controls-button-background-color-hover-default` | `#f4f4f4`                           |
| `--xy-controls-button-color-default`                  | `inherit`                           |
| `--xy-controls-button-color-hover-default`            | `inherit`                           |
| `--xy-controls-button-border-color-default`           | `#eee`                              |
| `--xy-controls-box-shadow-default`                    | `0 0 2px 1px rgba(0, 0, 0, 0.08)`   |
| `--xy-resize-background-color-default`                | `#3367d9`                           |

These variables are used to define the *defaults* for the various elements of
React Flow. This means they can still be overridden by inline styles or custom
classes on a per-element basis. If you want to override these variables, you can do so
by adding:

```css
.react-flow {
  --xy-node-background-color-default: #ff5050;
}
```

<Callout type="warning">
  Be aware that these variables are defined under `.react-flow` and under
  `:root`.
</Callout>

##### Overriding built-in classes

Some consider heavy use of inline styles to be an anti-pattern. In that case,
you can override the built-in classes that React Flow uses with your own CSS.
There are many classes attached to all sorts of elements in React Flow, but the
ones you'll likely want to override are listed below:

| Class name                         | Description                                                                              |
| :--------------------------------- | :--------------------------------------------------------------------------------------- |
| `.react-flow`                      | The outermost container                                                                  |
| `.react-flow__renderer`            | The inner container                                                                      |
| `.react-flow__zoompane`            | Zoom & pan pane                                                                          |
| `.react-flow__selectionpane`       | Selection pane                                                                           |
| `.react-flow__selection`           | User selection                                                                           |
| `.react-flow__edges`               | The element containing all edges in the flow                                             |
| `.react-flow__edge`                | Applied to each [`Edge`](/api-reference/types/edge) in the flow                          |
| `.react-flow__edge.selected`       | Added to an [`Edge`](/api-reference/types/edge) when selected                            |
| `.react-flow__edge.animated`       | Added to an [`Edge`](/api-reference/types/edge) when its `animated` prop is `true`       |
| `.react-flow__edge.updating`       | Added to an [`Edge`](/api-reference/types/edge) while it gets updated via `onReconnect`  |
| `.react-flow__edge-path`           | The SVG `<path />` element of an [`Edge`](/api-reference/types/edge)                     |
| `.react-flow__edge-text`           | The SVG `<text />` element of an [`Edge`](/api-reference/types/edge) label               |
| `.react-flow__edge-textbg`         | The SVG `<text />` element behind an [`Edge`](/api-reference/types/edge) label           |
| `.react-flow__connection`          | Applied to the current connection line                                                   |
| `.react-flow__connection-path`     | The SVG `<path />` of a connection line                                                  |
| `.react-flow__nodes`               | The element containing all nodes in the flow                                             |
| `.react-flow__node`                | Applied to each [`Node`](/api-reference/types/node) in the flow                          |
| `.react-flow__node.selected`       | Added to a [`Node`](/api-reference/types/node) when selected.                            |
| `.react-flow__node-default`        | Added when [`Node`](/api-reference/types/node) type is `"default"`                       |
| `.react-flow__node-input`          | Added when [`Node`](/api-reference/types/node) type is `"input"`                         |
| `.react-flow__node-output`         | Added when [`Node`](/api-reference/types/node) type is `"output"`                        |
| `.react-flow__nodesselection`      | Nodes selection                                                                          |
| `.react-flow__nodesselection-rect` | Nodes selection rect                                                                     |
| `.react-flow__handle`              | Applied to each [`<Handle />`](/api-reference/components/handle) component               |
| `.react-flow__handle-top`          | Applied when a handle's [`Position`](/api-reference/types/position) is set to `"top"`    |
| `.react-flow__handle-right`        | Applied when a handle's [`Position`](/api-reference/types/position) is set to `"right"`  |
| `.react-flow__handle-bottom`       | Applied when a handle's [`Position`](/api-reference/types/position) is set to `"bottom"` |
| `.react-flow__handle-left`         | Applied when a handle's [`Position`](/api-reference/types/position) is set to `"left"`   |
| `.connectingfrom`                  | Added to a Handle when a connection line is above a handle.                              |
| `.connectingto`                    | Added to a Handle when a connection line is above a handle.                              |
| `.valid`                           | Added to a Handle when a connection line is above **and** the connection is valid        |
| `.react-flow__background`          | Applied to the [`<Background />`](/api-reference/components/background) component        |
| `.react-flow__minimap`             | Applied to the [`<MiniMap />`](/api-reference/components/minimap) component              |
| `.react-flow__controls`            | Applied to the [`<Controls />`](/api-reference/components/controls) component            |

<Callout type="warning">
  Be careful if you go poking around the source code looking for other classes
  to override. Some classes are used internally and are required in order for
  the library to be functional. If you replace them you may end up with
  unexpected bugs or errors!
</Callout>

#### Third-party solutions

You can choose to opt-out of React Flow's default styling altogether and use a
third-party styling solution instead. If you want to do this, you must make sure
you still import the base styles.

```js
import '@xyflow/react/dist/base.css';
```

<Callout type="warning">
  These base styles are **required** for React Flow to function correctly. If
  you don't import them or you override them with your own styles, some things
  might not work as expected!
</Callout>

<RemoteCodeViewer route="examples/styling/base-style" framework="react" />

##### TailwindCSS

Custom nodes and edges are just React components, and you can use any styling
solution you'd like to style them. For example, you might want to use
[Tailwind](https://tailwindcss.com/) to style your nodes:

```jsx
function CustomNode({ data }) {
  return (
    <div className="px-4 py-2 shadow-md rounded-md bg-white border-2 border-stone-400">
      <div className="flex">
        <div className="rounded-full w-12 h-12 flex justify-center items-center bg-gray-100">
          {data.emoji}
        </div>
        <div className="ml-2">
          <div className="text-lg font-bold">{data.name}</div>
          <div className="text-gray-500">{data.job}</div>
        </div>
      </div>

      <Handle
        type="target"
        position={Position.Top}
        className="w-16 !bg-teal-500"
      />
      <Handle
        type="source"
        position={Position.Bottom}
        className="w-16 !bg-teal-500"
      />
    </div>
  );
}
```

<Callout type="warning">
  If you want to overwrite default styles, make sure to import Tailwinds entry
  point after React Flows base styles.
</Callout>

```js
import '@xyflow/react/dist/style.css';
import 'tailwind.css';
```

For a complete example of using Tailwind with React Flow, check out
[the example](/examples/styling/tailwind)!

import { Callout } from 'nextra/components';
import { RemoteCodeViewer } from 'xy-shared/server';

### Utility Classes

React Flow provides several built-in utility CSS classes to help you fine-tune how
interactions work within your custom elements.

#### `nodrag`

Adding the class `nodrag` to an element ensures that interacting with it doesn't trigger a
drag. This is particularly useful for elements like buttons or inputs that should not
initiate a drag operation when clicked.

Nodes have a `drag` class name in place by default. However, this class name can affect
the behaviour of the event listeners inside your custom nodes. To prevent unexpected
behaviours, add a `nodrag` class name to elements with an event listener. This prevents
the default drag behavior as well as the default node selection behavior when elements
with this class are clicked.

```tsx
export default function CustomNode(props: NodeProps) {
  return (
    <div>
      <input className="nodrag" type="range" min={0} max={100} />
    </div>
  );
}
```

#### `nopan`

If an element in the canvas does not stop mouse events from propagating, clicking and
dragging that element will pan the viewport. Adding the "nopan" class prevents this
behavior and this prop allows you to change the name of that class.

```tsx
export default function CustomNode(props: NodeProps) {
  return (
    <div className="nopan">
      <p>fixed content...</p>
    </div>
  );
}
```

#### `nowheel`

If your custom element contains scrollable content, you can apply the `nowheel` class.
This disables the canvas' default pan behavior when you scroll inside your custom node,
ensuring that only the content scrolls instead of moving the entire canvas.

```tsx
export default function CustomNode(props: NodeProps) {
  return (
    <div className="nowheel" style={{ overflow: 'auto' }}>
      <p>Scrollable content...</p>
    </div>
  );
}
```

Applying these utility classes helps you control interaction on a granular level. You can
customize these class names inside React Flow's
[style props](/api-reference/react-flow/#style-props).

<Callout type="info">
  When creating your own custom nodes, you will also need to remember to style them!
  Unlike the built-in nodes, custom nodes have no default styles, so feel free to use any
  styling method you prefer, such as [Tailwind CSS](/examples/styling/tailwind).
</Callout>

import { Callout } from 'nextra/components';
import { RemoteCodeViewer } from 'xy-shared/server';

### Overview

We regularly get asked how to handle layouting in React Flow. We have not implemented our
own layouting solution yet, but will present some viable external libraries on this page.
We'll split things up into resources for layouting nodes and resources for routing edges.

You can test out some of the layouting options in our [playground](/playground/layouting)
or have a look at the [examples](/examples#layout) we've put together.

To start let's put together a simple example flow that we can use as a base for testing
out the different layouting options.

<RemoteCodeViewer route="learn/layouting-flow-1-empty" framework="react" />

Each of the examples that follow will be built on this empty flow. Where possible we've
tried to keep the examples confined to just one `index.js` file so it's easy for you to
compare how they're set up.

#### Layouting nodes

For layouting nodes, there are a few third-party libraries that we think are worth
checking out:

| Library                                            | Dynamic node sizes | Sub-flow layouting | Edge routing | Bundle size                                                                                                                                    |
| -------------------------------------------------- | ------------------ | ------------------ | ------------ | ---------------------------------------------------------------------------------------------------------------------------------------------- |
| [Dagre](https://github.com/dagrejs/dagre)          | Yes                | Yes¹               | No           | <a href="https://pkg-size.dev/@dagrejs/dagre"><img src="https://pkg-size.dev/badge/bundle/39882" title="Bundle size for @dagrejs/dagre" /></a> |
| [D3-Hierarchy](https://github.com/d3/d3-hierarchy) | No                 | No                 | No           | <a href="https://pkg-size.dev/d3-hierarchy"><img src="https://pkg-size.dev/badge/bundle/14697" title="Bundle size for d3-hierarchy" /></a>     |
| [D3-Force](https://github.com/d3/d3-force)         | Yes                | No                 | No           | <a href="https://pkg-size.dev/d3-force"><img src="https://pkg-size.dev/badge/bundle/15623" title="Bundle size for d3-force" /></a>             |
| [ELK](https://github.com/kieler/elkjs)             | Yes                | Yes                | Yes          | <a href="https://pkg-size.dev/elkjs"><img src="https://pkg-size.dev/badge/bundle/1455420" title="Bundle size for elkjs" /></a>                 |

¹ Dagre currently has an [open issue](https://github.com/dagrejs/dagre/issues/238) that
prevents it from laying out sub-flows correctly if any nodes in the sub-flow are connected
to nodes outside the sub-flow.

We've loosely ordered these options from simplest to most complex, where dagre is largely
a drop-in solution and elkjs is a full-blown highly configurable layouting engine. Below,
we'll take a look at a brief example of how each of these libraries can be used with React
Flow. For dagre and elkjs specifically, we have some separate examples you can refer back
to [here](/examples/layout/dagre) and [here](/examples/layout/elkjs).

##### Dagre

* Repo: [https://github.com/dagrejs/dagre](https://github.com/dagrejs/dagre)
* Docs: [https://github.com/dagrejs/dagre/wiki#configuring-the-layout](https://github.com/dagrejs/dagre/wiki#configuring-the-layout)

Dagre is a simple library for layouting directed graphs. It has minimal configuration
options and a focus on speed over choosing the most optimal layout. If you need to
organize your flows into a tree, *we highly recommend dagre*.

<RemoteCodeViewer route="learn/layouting-flow-2-dagre" framework="react" />

With no effort at all we get a well-organized tree layout! Whenever `getLayoutedElements`
is called, we'll reset the dagre graph and set the graph's direction (either left-to-right
or top-to-bottom) based on the `direction` prop. Dagre needs to know the dimensions of
each node in order to lay them out, so we iterate over our list of nodes and add them to
dagre's internal graph.

After laying out the graph, we'll return an object with the layouted nodes and edges. We
do this by mapping over the original list of nodes and updating each node's position
according to node stored in the dagre graph.

Documentation for dagre's configuration options can be found
[here](https://github.com/dagrejs/dagre/wiki#configuring-the-layout), including properties
to set for spacing and alignment.

##### D3-Hierarchy

* Repo: [https://github.com/d3/d3-hierarchy](https://github.com/d3/d3-hierarchy)
* Docs: [https://d3js.org/d3-hierarchy](https://d3js.org/d3-hierarchy)

When you know your graph is a tree with a single root node, d3-hierarchy can provide a
handful of interesting layouting options. While the library can layout a simple tree just
fine, it also has layouting algorithms for tree maps, partition layouts, and enclosure
diagrams.

<RemoteCodeViewer route="learn/layouting-flow-3-d3-hierarchy" framework="react" />

<Callout>
  D3-hierarchy expects your graphs to have a single root node, so it won't work in all
  cases. It's also important to note that d3-hierarchy assigns the same width and height
  to *all* nodes when calculating the layout, so it's not the best choice if you're
  displaying lots of different node types.
</Callout>

##### D3-Force

* Repo: [https://github.com/d3/d3-force](https://github.com/d3/d3-force)
* Docs: [https://d3js.org/d3-force](https://d3js.org/d3-force)

For something more interesting than a tree, a force-directed layout might be the way to
go. D3-Force is a physics-based layouting library that can be used to position nodes by
applying different forces to them.

As a consequence, it's a little more complicated to configure and use compared to dagre
and d3-hierarchy. Importantly, d3-force's layouting algorithm is iterative, so we need a
way to keep computing the layout across multiple renders.

First, let's see what it does:

<RemoteCodeViewer route="learn/layouting-flow-4-d3-force" framework="react" />

We've changed our `getLayoutedElements` to a hook called `useLayoutedElements` instead.
Additionally, instead of passing in the nodes and edges explicitly, we'll use get
`getNodes` and `getEdges` functions from the `useReactFlow` hook. This is important when
combined with the store selector in `initialized` because it will prevent us from
reconfiguring the simulation any time the nodes update.

The simulation is configured with a number of different forces applied so you can see how
they interact: play around in your own code to see how you want to configure those forces.
You can find the documentation and some different examples of d3-force
[here](https://d3js.org/d3-force).

<Callout>
  <strong>Rectangular collisions</strong>
  D3-Force has a built-in collision force, but it assumes nodes are circles. We've thrown
  together a custom force in `collision.js` that uses a similar algorithm but accounts for
  our rectangular nodes instead. Feel free to steal it or let us know if you have any
  suggestions for improvements!
</Callout>

The tick function progresses the simulation by one step and then updates React Flow with
the new node positions. We've also included a demonstration on how to handle node dragging
while the simulation is running: if your flow isn't interactive you can ignore that part!

<Callout>
  For larger graphs, computing the force layout every render forever is going to incur a
  big performance hit. In this example we have a simple toggle to turn the layouting on
  and off, but you might want to come up with some other approach to only compute the
  layout when necessary.
</Callout>

##### Elkjs

* Repo: [https://github.com/kieler/elkjs](https://github.com/kieler/elkjs)
* Docs: [https://eclipse.dev/elk/reference.html](https://eclipse.dev/elk/reference.html) (good luck!)

Elkjs is certainly the most configurable option available, but it's also the most
complicated. Elkjs is a Java library that's been ported to JavaScript, and it provides a
huge number of options for configuring the layout of your graph.

<RemoteCodeViewer route="learn/layouting-flow-6-elkjs" framework="react" />

At it's most basic we can compute layouts similar to dagre, but because the layouting
algorithm runs asynchronously we need to create a `useLayoutedElements` hook similar to
the one we created for d3-force.

<Callout>
  <strong>The ELK reference is your new best friend</strong>
  We don't often recommend elkjs because it's complexity makes it difficult for us to
  support folks when they need it. If you do decide to use it, you'll want to keep the
  original [Java API reference](https://eclipse.dev/elk/reference.html) handy.
</Callout>

We've also included a few examples of some of the other layouting algorithms available,
including a non-interactive force layout.

##### Honourable Mentions

Of course, we can't go through every layouting library out there: we'd never work on
anything else! Here are some other libraries we've come across that might be worth taking
a look at:

* If you want to use dagre or d3-hierarchy but need to support nodes with different
  dimensions, both [d3-flextree](https://github.com/klortho/d3-flextree) and
  [entitree-flex](https://github.com/codeledge/entitree-flex) look promising.

  You can find an example of how to use entitree-flex with React Flow
  [here](/examples/layout/entitree-flex).

* [Cola.js](https://github.com/tgdwyer/WebCola) looks like a promising option for
  so-called "constraint-based" layouts. We haven't had time to properly investigate it
  yet, but it looks like you can achieve results similar to d3-force but with a lot more
  control.

#### Routing Edges

If you don't have any requirements for edge routing, you can use one of the layouting
libraries above to position nodes and let the edges fall wherever they may. Otherwise,
you'll want to look into some libraries and techniques for edge routing.

Your options here are more limited than for node layouting, but here are some resources we
thought looked promising:

* [react-flow-smart-edge](https://github.com/tisoap/react-flow-smart-edge)
* [Routing Orthogonal Diagram Connectors in JavaScript](https://medium.com/swlh/routing-orthogonal-diagram-connectors-in-javascript-191dc2c5ff70)

If you do explore some custom edge routing options, consider contributing back to the
community by writing a blog post or creating a library!

Our [editable edge Pro Example](/examples/edges/editable-edge) could also be used as a
starting point for implementing a custom edge that can be routed along a specific path.

import { Callout } from 'nextra/components';
import { RemoteCodeViewer } from 'xy-shared/server';

### Sub Flows

<Callout type="info">
  **Deprecation of `parentNode` property!** We have renamed the `parentNode` option to
  `parentId` in version 11.11.0. The old property is still supported but will be removed
  in version 12.
</Callout>

A sub flow is a flow inside a node. It can be a separate flow or a flow that is connected
with other nodes outside of its parent. This feature can also be used for grouping nodes.
In this part of the docs we are going to build a flow with sub flows and show you the
child node specific options.

<Callout type="warning">
  <strong>Order of Nodes</strong>
  It's important that your parent nodes appear before their children in the `nodes`/
  `defaultNodes` array to get processed correctly.
</Callout>

##### Adding child nodes

If you want to add a node as a child of another node you need to use the `parentId` (this
was called `parentNode` in previous versions) option (you can find a list of all options
in the [node options section](/api-reference/types/node)). Once we do that, the child node
is positioned relative to its parent. A position of `{ x: 0, y: 0 }` is the top left
corner of the parent.

In this example we are setting a fixed width and height of the parent node by passing the
style option. Additionally, we set the child extent to `'parent'` so that we can't move
the child nodes out of the parent node.

<RemoteCodeViewer route="learn/sub-flows" framework="react" />

##### Using child specific options

When you move the parent node you can see that the child nodes move, too. Adding a node to
another node with the `parentId` option, just does one thing: It positions it relatively
to its parent. The child node is not really a child markup-wise. You can drag or position
the child outside of its parent (when the `extent: 'parent'` option is not set) but when
you move the parent, the child moves with it.

In the example above we are using the `group` type for the parent node but you can use any
other type as well. The `group` type is just a convenience node type that has no handles
attached.

Now we are going to add some more nodes and edges. As you can see, we can connect nodes
within a group and create connections that go from a sub flow to an outer node:

<RemoteCodeViewer route="learn/sub-flows-2" framework="react" />

##### Edge rendering behavior

Edges are rendered below nodes by default, and this behavior applies to both normal nodes
and group nodes. However, edges connected to a node with a parent are rendered above
nodes.

If you want to customize the z-index of edges, you can use the `zIndex` option. For
example:

```tsx
const defaultEdgeOptions = { zIndex: 1 };

<ReactFlow defaultEdgeOptions={defaultEdgeOptions} />;
```

This allows you to render edges above nodes or adjust their stacking order as needed.

##### Using a default node type as a parent

Let's remove the label of node B and add some child nodes. In this example you can see
that you can use one of the default node types as parents, too. We also set the child
nodes to `draggable: false` so that they are not draggable anymore.

<RemoteCodeViewer route="learn/sub-flows-3" framework="react" />

### Common Errors

import { Callout } from 'nextra/components';

This guide contains warnings and errors that can occur when using React Flow. We are also
adding common questions and pitfalls that we collect from our
[Discord Server](https://discord.gg/RVmnytFmGW),
[Github Issues](https://github.com/xyflow/xyflow/issues) and
[Github Discussions](https://github.com/xyflow/xyflow/discussions).

<div id="001" />

##### Warning: Seems like you have not used zustand provider as an ancestor.

This usually happens when:

**A:** You have two different versions of @reactflow/core installed.<br /> **B:** You are
trying to access the internal React Flow state outside of the React Flow context.

###### Solution for A

Update reactflow and @reactflow/node-resizer (in case you are using it), remove
node\_modules and package-lock.json and reinstall the dependencies.

###### Solution for B

A possible solution is to wrap your component with a
[`<ReactFlowProvider />`](/api-reference/react-flow-provider) or move the code that is
accessing the state inside a child of your React Flow instance.

<Callout type="error">This will cause an error:</Callout>

```jsx
import { ReactFlow } from '@xyflow/react';
import '@xyflow/react/dist/style.css';

function FlowWithoutProvider(props) {
  // cannot access the state here
  const reactFlowInstance = useReactFlow();

  return <ReactFlow {...props} />;
}

export default FlowWithoutProvider;
```

<Callout type="error">This will cause an error, too:</Callout>

```jsx
import { ReactFlow, ReactFlowProvider } from '@xyflow/react';
import '@xyflow/react/dist/style.css';

function Flow(props) {
  // still cannot access the state here
  // only child components of this component can access the state
  const reactFlowInstance = useReactFlow();

  return (
    <ReactFlowProvider>
      <ReactFlow {...props} />
    </ReactFlowProvider>
  );
}

export default FlowWithProvider;
```

<Callout type="info">This works:</Callout>

As soon as you want to access the internal state of React Flow (for example by using the
`useReactFlow` hook), you need to wrap your component with a `<ReactFlowProvider />`. Here
the wrapping is done outside of the component:

```jsx
import { ReactFlow, ReactFlowProvider } from '@xyflow/react';
import '@xyflow/react/dist/style.css';

function Flow(props) {
  // you can access the internal state here
  const reactFlowInstance = useReactFlow();

  return <ReactFlow {...props} />;
}

// wrapping with ReactFlowProvider is done outside of the component
function FlowWithProvider(props) {
  return (
    <ReactFlowProvider>
      <Flow {...props} />
    </ReactFlowProvider>
  );
}

export default FlowWithProvider;
```

<div id="002" />

##### It looks like you have created a new nodeTypes or edgeTypes object.

If this wasn't on purpose please define the nodeTypes/edgeTypes outside of the component
or memoize them.

This warning appears when the `nodeTypes` or `edgeTypes` properties change after the
initial render. The `nodeTypes` or `edgeTypes` should only be changed dynamically in very
rare cases. Usually, they are defined once, along with all the types you use in your
application. It can happen easily that you are defining the nodeTypes or edgeTypes object
inside of your component render function, which will cause React Flow to re-render every
time your component re-renders.

<Callout type="error">Causes a warning:</Callout>

```jsx
import { ReactFlow } from '@xyflow/react';
import '@xyflow/react/dist/style.css';

import MyCustomNode from './MyCustomNode';

function Flow(props) {
  // new object being created on every render
  // causing unnecessary re-renders
  const nodeTypes = {
    myCustomNode: MyCustomNode,
  };

  return <ReactFlow nodeTypes={nodeTypes} />;
}

export default Flow;
```

<Callout type="info">Recommended implementation:</Callout>

```jsx
import { ReactFlow } from '@xyflow/react';
import MyCustomNode from './MyCustomNode';

// defined outside of the component
const nodeTypes = {
  myCustomNode: MyCustomNode,
};

function Flow(props) {
  return <ReactFlow nodeTypes={nodeTypes} />;
}

export default Flow;
```

<Callout type="info">Alternative implementation:</Callout>

You can use this if you want to change your nodeTypes dynamically without causing
unnecessary re-renders.

```jsx
import { useMemo } from 'react';
import { ReactFlow } from '@xyflow/react';
import '@xyflow/react/dist/style.css';

import MyCustomNode from './MyCustomNode';

function Flow(props) {
  const nodeTypes = useMemo(
    () => ({
      myCustomNode: MyCustomNode,
    }),
    [],
  );

  return <ReactFlow nodeTypes={nodeTypes} />;
}

export default Flow;
```

<div id="003" />

##### Node type not found. Using fallback type "default".

This usually happens when you specify a custom node type for one of your nodes but do not
pass the correct nodeTypes property to React Flow. The string for the type option of your
custom node needs to be exactly the same as the key of the nodeTypes object.

<Callout type="error">Doesn't work:</Callout>

```jsx
import { ReactFlow } from '@xyflow/react';
import '@xyflow/react/dist/style.css';

import MyCustomNode from './MyCustomNode';

const nodes = [
  {
    id: 'mycustomnode',
    type: 'custom',
    // ...
  },
];

function Flow(props) {
  // nodeTypes property is missing, so React Flow cannot find the custom node component to render
  return <ReactFlow nodes={nodes} />;
}
```

<Callout type="error">Doesn't work either:</Callout>

```jsx
import { ReactFlow } from '@xyflow/react';
import '@xyflow/react/dist/style.css';

import MyCustomNode from './MyCustomNode';

const nodes = [
  {
    id: 'mycustomnode',
    type: 'custom',
    // ...
  },
];

const nodeTypes = {
  Custom: MyCustomNode,
};

function Flow(props) {
  // node.type and key in nodeTypes object are not exactly the same (capitalized)
  return <ReactFlow nodes={nodes} nodeTypes={nodeTypes} />;
}
```

<Callout type="info">This does work:</Callout>

```jsx
import { ReactFlow } from '@xyflow/react';
import '@xyflow/react/dist/style.css';

import MyCustomNode from './MyCustomNode';

const nodes = [
  {
    id: 'mycustomnode',
    type: 'custom',
    // ...
  },
];

const nodeTypes = {
  custom: MyCustomNode,
};

function Flow(props) {
  return <ReactFlow nodes={nodes} nodeTypes={nodeTypes} />;
}
```

<div id="004" />

##### The React Flow parent container needs a width and a height to render the graph.

Under the hood, React Flow measures the parent DOM element to adjust the renderer. If you
try to render React Flow in a regular div without a height, we cannot display the graph.
If you encounter this warning, you need to make sure that your wrapper component has some
CSS attached to it so that it gets a fixed height or inherits the height of its parent.

<Callout type="error">This will cause the warning:</Callout>

```jsx
import { ReactFlow } from '@xyflow/react';
import '@xyflow/react/dist/style.css';

function Flow(props) {
  return (
    <div>
      <ReactFlow {...props} />
    </div>
  );
}
```

<Callout type="info">Working example:</Callout>

```jsx
import { ReactFlow } from '@xyflow/react';

function Flow(props) {
  return (
    <div style={{ height: 800 }}>
      <ReactFlow {...props} />
    </div>
  );
}
```

<div id="005" />

##### Only child nodes can use a parent extent.

This warning appears when you are trying to add the `extent` option to a node that does
not have a parent node. Depending on what you are trying to do, you can remove the
`extent` option or specify a `parentNode`.

<Callout type="error">Does show a warning:</Callout>

```jsx
import { ReactFlow } from '@xyflow/react';
import '@xyflow/react/dist/style.css';

const nodes = [
  {
    id: 'mycustomnode',
    extent: 'parent',
    // ...
  },
];

function Flow(props) {
  return <ReactFlow nodes={nodes} />;
}
```

<Callout type="info">Warning resolved:</Callout>

```jsx import { ReactFlow } from '@xyflow/react';
const nodes = [
  {
    id: 'mycustomnode',
    parentNode: 'someothernode',
    extent: 'parent',
    // ...
  },
];

function Flow(props) {
  return <ReactFlow nodes={nodes} />;
}
```

<div id="006" />

##### Can't create edge. An edge needs a source and a target.

This happens when you do not pass a `source` and a `target` option to the edge object.
Without the source and target, the edge cannot be rendered.

<Callout type="error">Will show a warning:</Callout>

```jsx
import { ReactFlow } from '@xyflow/react';
import '@xyflow/react/dist/style.css';

const nodes = [
  /* ... */
];

const edges = [
  {
    nosource: '1',
    notarget: '2',
  },
];

function Flow(props) {
  return <ReactFlow nodes={nodes} edges={edges} />;
}
```

<Callout type="info">This works:</Callout>

```jsx
import { ReactFlow } from '@xyflow/react';

const nodes = [
  /* ... */
];

const edges = [
  {
    source: '1',
    target: '2',
  },
];

function Flow(props) {
  return <ReactFlow nodes={nodes} edges={edges} />;
}
```

<div id="007" />

##### The old edge with id="some-id" does not exist.

This can happen when you are trying to [reconnect an edge](/examples/edges/reconnect-edge)
but the edge you want to update is already removed from the state. This is a very rare
case. Please see the [Reconnect Edge example](/examples/edges/reconnect-edge) for
implementation details.

<div id="008" />

##### Couldn't create edge for source/target handle id: "some-id"; edge id: "some-id".

This can happen if you are working with multiple handles and a handle is not found by its
`id` property or if you haven't
[updated the node internals after adding or removing handles](/api-reference/hooks/use-update-node-internals)
programmatically. Please see the [Custom Node Example](/examples/nodes/custom-node) for an
example of working with multiple handles.

<div id="009" />

##### Marker type doesn't exist.

This warning occurs when you are trying to specify a marker type that is not built into
React Flow. The existing marker types are documented
[here](/api-reference/types/edge#edgemarker).

<div id="010" />

##### Handle: No node id found.

This warning occurs when you try to use a `<Handle />` component outside of a custom node
component.

##### I get an error when building my app with webpack 4.

If you're using webpack 4, you'll likely run into an error like this:

```
ERROR in /node_modules/@reactflow/core/dist/esm/index.js 16:19
Module parse failed: Unexpected token (16:19)
You may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders
```

React Flow is a modern JavaScript code base and makes use of lots of newer JavaScript
features. By default, webpack 4 does not transpile your code and it doesn't know how to
handle React Flow.

You need to add a number of babel plugins to your webpack config to make it work:

```sh npm2yarn copy
npm i --save-dev babel-loader@8.2.5 @babel/preset-env @babel/preset-react @babel/plugin-proposal-optional-chaining @babel/plugin-proposal-nullish-coalescing-operator
```

and configure the loader like this:

```js
{
  test: /node_modules[\/\\]@?reactflow[\/\\].*.js$/,
  use: {
    loader: 'babel-loader',
    options: {
      presets: ['@babel/preset-env', "@babel/preset-react"],
      plugins: [
        "@babel/plugin-proposal-optional-chaining",
        "@babel/plugin-proposal-nullish-coalescing-operator",
      ]
    }
  }
}
```

<Callout type="info">
  If you're using webpack 5, you don't need to do anything! React Flow will work out of
  the box.
</Callout>

##### Mouse events aren't working consistently when my nodes contain a `<canvas />` element.

If you’re using a `<canvas />` element inside your custom node, you might run into
problems with seemingly incorrect coordinates in mouse events from the canvas.

React Flow uses CSS transforms to scale nodes as you zoom in and out. However, from the
DOM’s perspective, the element is still the same size. This can cause problems if you have
event listeners that want to calculate the mouse position relative to the canvas element.

To remedy this in event handlers you control, you can scale your computed relative
position by `1 / zoom` where `zoom` is the current zoom level of the flow. To get the
current zoom level, you can use the `getZoom` method from the
[`useReactFlow`](/api-reference/hooks/use-react-flow) hook.

##### Edges are not displaying.

If your edges are not displaying in React Flow, this might be due to one of the following
reasons:

* You have not imported the React Flow stylesheet. If you haven't imported it, you can
  import it like `import '@xyflow/react/dist/style.css';`.
* If you have replaced your default nodes with a custom node, check if that custom node
  has appropriate `source/target` handles in the custom node component. An edge cannot be
  made without a handle.
* If you use an external styling library like Tailwind or Bulma, ensure it doesn't
  override the edge styles. For example, sometimes styling libraries override the
  `.react-flow__edges` SVG selector with `overflow: hidden`, which hides the edges.
* If you are using an async operation like a request to the backend, make sure to call the
  `updateNodeInternals` function returned by the
  [`useUpdateNodeInternal`](/api-reference/hooks/use-update-node-internals) hook after the
  async operation so React Flow updates the handle position internally.

##### Edges are not displaying correctly.

If your edges are not rendering as they should, this could be due to one of the following
reasons:

* If you want to hide your handles, do not use `display: none` to hide them. Use either
  `opacity: 0` or `visibility: hidden`.
* If edges are not connected to the correct handle, check if you have added more than one
  handle of the same type(`source` or `target`) in your custom node component. If that is
  the case, assign IDs to them. Multiple handles of the same kind on a node need to have
  distinguishable IDs so that React Flow knows which handle an edge corresponds to.
* If you are changing the position of the handles (via reordering, etc.), make sure to
  call the `updateNodeInternals` function returned by the
  [`useUpdateNodeInternals`](/api-reference/hooks/use-update-node-internals) hook after so
  React Flow knows to update the handle position internally.
* If you are using a custom edge and want your edge to go from the source handle to a
  target handle, make sure to correctly pass the `sourceX, sourceY, targetX, and targetY`
  props you get from the custom edge component in the edge path creation function(e.g.,
  [`getBezierPath`](/api-reference/utils/get-bezier-path), etc.). `sourceX, sourceY`, and
  `targetX, targetY` represent the `x,y` coordinates for the source and target handle,
  respectively.
* If the custom edge from the source or target side is not going towards the handle as
  expected (entering or exiting from a handle at a weird angle), make sure to pass the
  `sourcePosition` and `targetPosition` props you get from the custom edge component in
  the edge path creation function(e.g.,
  [`getBezierPath`](/api-reference/utils/get-bezier-path)). Passing the source/target
  handle position in the path creation function is necessary for the edge to start or end
  properly at a handle.

### Migrate to React Flow v10

import { Callout } from 'nextra/components';

<Callout type="info">
  You can find the docs for old versions of React Flow here:
  [v11](https://v11.reactflow.dev), [v10](https://v10.reactflow.dev),
  [v9](https://v9.reactflow.dev)
</Callout>

Welcome to React Flow v10! With the major version update, there are coming many new features but also some breaking changes.

#### New Features

* [**Sub Flows**](/learn/layouting/sub-flows): You can now add nodes to a parent node and create groups and nested flows
* **Node Type 'group'**: A new node type without handles that can be used as a group node
* **Touch Device Support**: It is now possible to connect nodes on touch devices
* **Fit View on Init**: You can use the new `fitView` prop to fit the initial view
* **Key Handling**: Not only single keys but also multiple keys and key combinations are possible now
* [**useKeyPress hook**](/api-reference/hooks/use-key-press): A util hook for handling keyboard events
* [**useReactFlow hook**](/api-reference/hooks/use-react-flow): Returns a React Flow instance that exposes functions to manipulate the flow
* **[useNodes](/api-reference/hooks/use-nodes), [useEdges](/api-reference/hooks/use-edges) and [useViewport](/api-reference/hooks/use-viewport) hooks**: Hooks for receiving nodes, edges and the viewport
* **Edge Marker**: More options to configure the start and end markers of an edge

#### Breaking Changes

TLDR:

* Split the `elements` array into `nodes` and `edges` arrays and implement `onNodesChange` and `onEdgesChange` handlers (detailed guide in the [core concepts section](/learn/concepts/core-concepts))
* Memoize your custom `nodeTypes` and `edgeTypes`
* Rename `onLoad` to `onInit`
* Rename `paneMoveable` to `panOnDrag`
* Rename `useZoomPanHelper` to `useReactFlow` (and `setTransform` to `setViewport`)
* Rename node and edge option `isHidden` to `hidden`

Detailed explanation of breaking changes:

##### 1. ~~Elements~~ - Nodes and Edges

We saw that a lot of people struggle with the semi controlled `elements` prop. It was always a bit messy to sync the local user state with the internal state of React Flow. Some of you used the internal store that was never documented and always a kind of hacky solution. For the new version we offer two ways to use React Flow - uncontrolled and controlled.

##### 1.1. Controlled `nodes` and `edges`

If you want to have the full control and use nodes and edges from your local state or your store, you can use the `nodes`, `edges` props in combination with the `onNodesChange` and `onEdgesChange` handlers. You need to implement these handlers for an interactive flow (if you are fine with just pan and zoom you don't need them). You'll receive a change when a node(s) gets initialized, dragged, selected or removed. This means that you always know the exact position and dimensions of a node or if it's selected for example. We export the helper functions `applyNodeChanges` and `applyEdgeChanges` that you should use to apply the changes.

###### Old API

```jsx
import { useState, useCallback } from 'react';
import { ReactFlow, removeElements, addEdge } from 'react-flow-renderer';

const initialElements = [
  { id: '1', data: { label: 'Node 1' }, position: { x: 250, y: 0 } },
  { id: '2', data: { label: 'Node 2' }, position: { x: 150, y: 100 } },
  { id: 'e1-2', source: '1', target: '2' },
];

const BasicFlow = () => {
  const [elements, setElements] = useState(initialElements);
  const onElementsRemove = useCallback(
    (elementsToRemove) =>
      setElements((els) => removeElements(elementsToRemove, els)),
    [],
  );
  const onConnect = useCallback((connection) =>
    setElements((es) => addEdge(connection, es)),
  );

  return (
    <ReactFlow
      elements={elements}
      onElementsRemove={onElementsRemove}
      onConnect={onConnect}
    />
  );
};

export default BasicFlow;
```

###### New API

```jsx
import { useState, useCallback } from 'react';
import {
  ReactFlow,
  applyNodeChanges,
  applyEdgeChanges,
  addEdge,
} from 'react-flow-renderer';

const initialNodes = [
  { id: '1', data: { label: 'Node 1' }, position: { x: 250, y: 0 } },
  { id: '2', data: { label: 'Node 2' }, position: { x: 150, y: 100 } },
];

const initialEdges = [{ id: 'e1-2', source: '1', target: '2' }];

const BasicFlow = () => {
  const [nodes, setNodes] = useState(initialNodes);
  const [edges, setEdges] = useState(initialEdges);

  const onNodesChange = useCallback(
    (changes) => setNodes((ns) => applyNodeChanges(changes, ns)),
    [],
  );
  const onEdgesChange = useCallback(
    (changes) => setEdges((es) => applyEdgeChanges(changes, es)),
    [],
  );
  const onConnect = useCallback((connection) =>
    setEdges((eds) => addEdge(connection, eds)),
  );

  return (
    <ReactFlow
      nodes={nodes}
      edges={edges}
      onNodesChange={onNodesChange}
      onEdgesChange={onEdgesChange}
      onConnect={onConnect}
    />
  );
};

export default BasicFlow;
```

You can also use the new hooks `useNodesState` and `useEdgesState` for a quick start:

```js
const [nodes, setNodes, onNodesChange] = useNodesState(initialNodes);
const [edges, setEdges, onEdgesChange] = useEdgesState(initialEdges);
```

related changes:

* `onElementsClick` ->`onNodeClick` and `onEdgeClick`
* `onElementsRemove` -> replaced by the `onNodesChange` and `onEdgesChange` handler

##### 1.2 Uncontrolled `defaultNodes` and `defaultEdges`

The easiest way to get started is to use the `defaultNodes` and `defaultEdges` props. When you set these props, all actions are handled internally. You don't need to add any other handlers to get a fully interactive flow with the ability to drag nodes, connect nodes and remove nodes and edges:

###### New API

```jsx
import ReactFlow from 'react-flow-renderer';

const defaultNodes = [
  { id: '1', data: { label: 'Node 1' }, position: { x: 250, y: 0 } },
  { id: '2', data: { label: 'Node 2' }, position: { x: 150, y: 100 } },
];

const defaultEdges = [{ id: 'e1-2', source: '1', target: '2' }];

const BasicFlow = () => {
  return <ReactFlow defaultNodes={defaultNodes} defaultEdges={defaultEdges} />;
};

export default BasicFlow;
```

If you want to add, remove or update a node or edge you can only do this by using the [ReactFlow instance](/api-reference/types/react-flow-instance) that you can receive either with the new `useReactFlow` hook or by using the `onInit` handler that gets the instance as a function param.

##### 2. Memoize your custom `nodeTypes` and `edgeTypes`

Whenever you pass new node or edge types, we create wrapped node or edge component types in the background. This means that you should not create a new `nodeType` or `edgeType` object on every render. **Memoize your nodeTypes and edgeTypes or define them outside of the component when they don't change**.

**Don't do this:**

This creates a new object on every render and leads to bugs and performance issues:

```jsx
// this is bad! Don't do it.
<ReactFlow
  nodes={[]}
  nodeTypes={{
    specialType: SpecialNode, // bad!
  }}
/>
```

**Do this:**

```jsx
function Flow() {
  const nodeTypes = useMemo(() => ({ specialType: SpecialNode }), []);

  return <ReactFlow nodes={[]} nodeTypes={nodeTypes} />;
}
```

or create the types outside of the component when they don't change:

```jsx
const nodeTypes = { specialType: SpecialNode };

function Flow() {
  return <ReactFlow nodes={[]} nodeTypes={nodeTypes} />;
}
```

##### 3. ~~Redux~~ - Zustand

We switched our state management library from Redux to [Zustand](https://github.com/pmndrs/zustand). With this change we could remove about 300LOC from our state related code. If you need to access the internal store, you can use the [`useStore` hook](/api-reference/hooks/use-store):

###### Old API

```jsx
import { useStoreState, useStoreActions } from 'react-flow-renderer';

...

const transform = useStoreState((store) => store.transform);
```

###### New API

```jsx
import { useStore } from 'react-flow-renderer';

...
const transform = useStore((store) => store.transform);
```

You still need to wrap your component with the `<ReactFlowProvider />` if you want to access the internal store.

We are also exporting `useStoreApi` if you need to get the store in an event handler for example without triggering re-renders.

```js
import { useStoreApi } from 'react-flow-renderer';

...

const store = useStoreApi();

...
// in an event handler
const [x, y, zoom] = store.getState().transform;
```

##### 4. ~~onLoad~~ - onInit

The `onLoad` callback has been renamed to `onInit` and now fires when the nodes are initialized.

###### Old API

```jsx
const onLoad = (reactFlowInstance: OnLoadParams) => reactFlowInstance.zoomTo(2);
...
<ReactFlow
   ...
  onLoad={onLoad}
/>
```

###### New API

```jsx
const onInit = (reactFlowInstance: ReactFlowInstance) => reactFlowInstance.zoomTo(2);
...
<ReactFlow
   ...
  onInit={onInit}
/>
```

##### 5. ~~paneMoveable~~ - panOnDrag

This is more consistent with the rest of the API (`panOnScroll`, `zoomOnScroll`, etc.)

###### Old API

```jsx
<ReactFlow
   ...
  paneMoveable={false}
/>
```

###### New API

```jsx
<ReactFlow
   ...
  panOnDrag={false}
/>
```

##### 6. ~~useZoomPanHelper transform~~ - unified in `useReactFlow`

As "transform" is also the variable name of the transform in the store and it's not clear that `transform` is a setter we renamed it to `setViewport`. This is also more consistent with the other functions. Also, all `useZoomPanHelper` functions have been moved to the [React Flow instance](/api-reference/types/react-flow-instance) that you get from the [`useReactFlow` hook](/api-reference/hooks/use-react-flow) or the `onInit` handler.

###### Old API

```js
const { transform, setCenter, setZoom  } = useZoomPanHelper();
...
transform({ x: 100, y: 100, zoom: 2 });
```

###### New API

```js
const { setViewport, setCenter, setZoom } = useReactFlow();
...
setViewport({ x: 100, y: 100, zoom: 2 });
```

New viewport functions:

* `getZoom`
* `getViewport`

##### 7. ~~isHidden~~ - hidden

We mixed prefixed (`is...`) and non-prefixed boolean option names. All node and edge options are not prefixed anymore. So it's `hidden`, `animated`, `selected`, `draggable`, `selectable` and `connectable`.

###### Old API

```js
const hiddenNode = { id: '1', isHidden: true, position: { x: 50, y: 50 } };
```

###### New API

```js
const hiddenNode = { id: '1', hidden: true, position: { x: 50, y: 50 } };
```

##### 8. ~~arrowHeadType~~ ~~markerEndId~~ - markerStart / markerEnd

We improved the API for customizing the markers for an edge. With the new API you are able to set individual markers at the start and the end of an edge as well as customizing them with colors, strokeWidth etc. You still have the ability to set a markerEndId but instead of using different properties, the `markerStart` and `markerEnd` property accepts either a string (id for the svg marker that you need to define yourself) or a configuration object for using the built in arrowClosed or arrow markers.

###### Old API

```js
const markerEdge = { source: '1', target: '2', arrowHeadType: 'arrow' };
```

###### New API

```js
const markerEdge = {
  source: '1',
  target: '2',
  markerStart: 'myCustomSvgMarker',
  markerEnd: { type: 'arrow', color: '#f00' },
};
```

##### 9. ~~ArrowHeadType~~ - MarkerType

This is just a wording change for making the marker API more consistent. As we are now able to set markers for the start of the edge, the name type ArrowHeadType has been renamed to MarkerType. In the future, this can also not only contain arrow shapes but others like circles, diamonds etc.

##### 10. Attribution

This is not really a breaking change to the API but a little change in the general appearance of React Flow. We added a tiny "React Flow" attribution to the bottom right (the position is configurable via the `attributionPosition` prop). This change comes with the new "React Flow Pro" subscription model. If you want to remove the attribution in a commercial application, please subscribe to ["React Flow Pro"](/pro).

### Migrate to React Flow v11

import { Callout } from 'nextra/components';

<Callout type="info">
  You can find the docs for old versions of React Flow here:
  [v11](https://v11.reactflow.dev), [v10](https://v10.reactflow.dev),
  [v9](https://v9.reactflow.dev)
</Callout>

A lot changed in v11 but this time we've tried to keep the breaking changes small. The biggest change is the new package name `reactflow` and the new repo structure. React Flow is now managed as a monorepo and separated into multiple packages that can be installed separately. In addition to that, there are some API changes and new APIs introduced in v11. This guide explains the changes in detail and helps you to migrate from v10 to v11.

<Callout>React Flow 11 only works with **React 17** or greater</Callout>

#### New Features

* **Better [Accessibility](/learn/advanced-use/accessibility)**
  * Nodes and edges are focusable, selectable, moveable and deletable with the keyboard.
  * `aria-` default attributes for all elements and controllable via `ariaLabel` options
  * Keyboard controls can be disabled with the new `disableKeyboardA11y` prop
* **Better selectable edges** via new edge option: `interactionWidth` - renders invisible edge that makes it easier to interact
* **Better routing for smoothstep and step edges**: [https://twitter.com/reactflowdev/status/1567535405284614145](https://twitter.com/reactflowdev/status/1567535405284614145)
* **Nicer edge updating behavior**: [https://twitter.com/reactflowdev/status/1564966917517021184](https://twitter.com/reactflowdev/status/1564966917517021184)
* **Node origin**: The new `nodeOrigin` prop lets you control the origin of a node. Useful for layouting.
* **New background pattern**: `BackgroundVariant.Cross` variant
* **[`useOnViewportChange`](/api-reference/hooks/use-on-viewport-change) hook** - handle viewport changes within a component
* **[`use-on-selection-change`](/api-reference/hooks/use-on-selection-change) hook** - handle selection changes within a component
* **[`useNodesInitialized`](/api-reference/hooks/use-nodes-initialized) hook** - returns true if all nodes are initialized and if there is more than one node
* **Deletable option** for Nodes and edges
* **New Event handlers**: `onPaneMouseEnter`, `onPaneMouseMove` and `onPaneMouseLeave`
* **Edge `pathOptions`** for `smoothstep` and `default` edges
* **Nicer cursor defaults**: Cursor is grabbing, while dragging a node or panning
* **Pane moveable** with middle mouse button
* **Pan over nodes** when they are not draggable (`draggable=false` or `nodesDraggable` false)
  * you can disable this behavior by adding the class name `nopan` to a wrapper of a custom node
* **[`<BaseEdge />`](/api-reference/components/base-edge) component** that makes it easier to build custom edges
* **[Separately installable packages](/learn/concepts/built-in-components)**
  * @reactflow/core
  * @reactflow/background
  * @reactflow/controls
  * @reactflow/minimap

#### Breaking Changes

##### 1. New npm package name

The package `react-flow-renderer` has been renamed to `reactflow`.

###### Old API

```js
// npm install react-flow-renderer
import ReactFlow from 'react-flow-renderer';
```

###### New API

```js
// npm install reactflow
import { ReactFlow } from '@xyflow/react';
```

##### 2. Importing CSS is mandatory

We are not injecting CSS anymore. **React Flow won't work if you are not loading the styles!**

```js
// default styling
import '@xyflow/react/dist/style.css';

// or if you just want basic styles
import '@xyflow/react/dist/base.css';
```

###### 2.1. Removal of the nocss entrypoint

This change also means that there is no `react-flow-renderer/nocss` entry point anymore. If you used that, you need to adjust the CSS entry points as mentioned above.

##### 3. `defaultPosition` and `defaultZoom` have been merged to `defaultViewport`

###### Old API

```jsx
import ReactFlow from 'react-flow-renderer';

const Flow = () => {
  return <ReactFlow defaultPosition={[10, 15]} defaultZoom={5} />;
};

export default Flow;
```

###### New API

```jsx
import { ReactFlow } from '@xyflow/react';

const defaultViewport: Viewport = { x: 10, y: 15, zoom: 5 };

const Flow = () => {
  return <ReactFlow defaultViewport={defaultViewport} />;
};

export default Flow;
```

##### 4. Removal of `getBezierEdgeCenter`, `getSimpleBezierEdgeCenter` and `getEdgeCenter`

In v10 we had `getBezierEdgeCenter`, `getSimpleBezierEdgeCenter` and `getEdgeCenter` for getting the center of a certain edge type.
In v11 we changed the helper function for creating the path, so that it also returns the center / label position of an edge.

Let's say you want to get the path and the center / label position of a bezier edge:

###### Old API

```jsx
import { getBezierEdgeCenter, getBezierPath } from 'react-flow-renderer';

const path = getBezierPath(edgeParams);
const [centerX, centerY] = getBezierEdgeCenter(params);
```

###### New API

```jsx
import { getBezierPath } from '@xyflow/react';

const [path, labelX, labelY] = getBezierPath(edgeParams);
```

We avoid to call it `centerX` and `centerY` anymore, because it's actually the label position and not always the center for every edge type.

##### 5. Removal of `onClickConnectStop` and `onConnectStop`

###### Old API

```jsx
import ReactFlow from 'react-flow-renderer';

const Flow = () => {
  const onConnectStop = () => console.log('on connect stop');

  return (
    <ReactFlow
      defaultNodes={defaultNodes}
      defaultEdges={defaultEdges}
      onConnectStop={onConnectStop}
      onClickConnectStop={onConnectStop}
    />
  );
};

export default Flow;
```

###### New API

```jsx
import { ReactFlow } from '@xyflow/react';

const Flow = () => {
  const onConnectEnd = () => console.log('on connect stop');

  return (
    <ReactFlow
      defaultNodes={defaultNodes}
      defaultEdges={defaultEdges}
      onConnectEnd={onConnectEnd}
      onClickConnectEnd={onConnectEnd}
    />
  );
};

export default Flow;
```

##### 6. Pan over nodes

In the previous versions you couldn't pan over nodes even if they were not draggable. In v11, you can pan over nodes when `nodesDraggable=false` or node option `draggable=false`. If you want the old behavior back, you can add the class name `nopan` to the wrappers of your custom nodes.

### Migrate to React Flow 12

import { Callout } from 'nextra/components';

<Callout type="info">
  You can find the docs for old versions of React Flow here:
  [v11](https://v11.reactflow.dev), [v10](https://v10.reactflow.dev),
  [v9](https://v9.reactflow.dev)
</Callout>

Before you can use the **[new features](#new-features)** that come with React Flow 12 like server side rendering, computing flows, and dark mode, here are the breaking changes you'll have to address first. We tried to keep the breaking changes to a minimum, but some of them were necessary to implement the new features.

#### Migration guide

Before you start to migrate, you need to install the new package.

```bash npm2yarn
npm install @xyflow/react
```

##### 1. A new npm package name

The package `reactflow` has been renamed to `@xyflow/react` and it's not a default import anymore. You also need to adjust the style import. Before v12, React Flow was divided into multiple packages. That's not the case anymore. If you just used the core, you now need to install the `@xyflow/react` package.

**Old API**

```js
// npm install reactflow
import ReactFlow from 'reactflow';
```

**New API**

```js
// npm install @xyflow/react
import { ReactFlow } from '@xyflow/react';

// you also need to adjust the style import
import '@xyflow/react/dist/style.css';

// or if you just want basic styles
import '@xyflow/react/dist/base.css';
```

##### 2. Node <code>measured</code> attribute for measured <code>width</code> and <code>height</code>

All measured node values are now stored in `node.measured`. Besides the new package name, this is the biggest change. After React Flow measures your nodes, it writes the dimensions to `node.measured.width` and `node.measured.height`. If you are using any layouting library like dagre or elk, you now need to take the dimensions from `node.measured` instead of `node`. If you are using `width` and `height`, those values will now be used as inline styles to specify the node dimensions.

**Old API**

```js
// getting the measured width and height
const nodeWidth = node.width;
const nodeHeight = node.height;
```

**New API**

```js
// getting the measured width and height
const nodeWidth = node.measured?.width;
const nodeHeight = node.measured?.height;
```

##### 3. New dimension handling <code>node.width</code> / <code>node.height</code> vs <code>node.measured.width</code> / <code>node.measured.height</code>

In order to support server side rendering we had to restructure the API a bit, so that users can pass node dimensions more easily. For this we changed the behavior of the `node.width` and `node.height` attributes. In React Flow 11, those attributes were measured values and only used as a reference. In React Flow 12 those attributes are used as inline styles to specify the node dimensions. If you load nodes from a database, you probably want to remove the `width` and `height` attributes from your nodes, because the behavior is slightly different now. Using `width` and `height` now means that the dimensions are not dynamic based on the content but fixed.

**Old API**

```js
// in React Flow 11 you might have used node.style to set the dimensions
const nodes = [
  {
    id: '1',
    type: 'input',
    data: { label: 'input node' },
    position: { x: 250, y: 5 },
    style: { width: 180, height: 40 },
  },
];
```

**New API**

```js
// in React Flow 12 you can used node.width and node.height to set the dimensions
const nodes = [
  {
    id: '1',
    type: 'input',
    data: { label: 'input node' },
    position: { x: 250, y: 5 },
    width: 180,
    height: 40,
  },
];
```

If you want to read more about how to configure React Flow for server side rendering, you can read about it in the [server side rendering guide](/learn/advanced-use/ssr-ssg-configuration).

##### 4. Updating nodes and edges

We are not supporting node and edge updates with object mutations anymore. If you want to update a certain attribute, you need to create a new node / edge.

**Old API**

```js
setNodes((currentNodes) =>
  currentNodes.map((node) => {
    node.hidden = true;
    return node;
  }),
);
```

**New API**

```js
setNodes((currentNodes) =>
  currentNodes.map((node) => ({
    ...node,
    hidden: true,
  })),
);
```

##### 5. Rename <code>onEdgeUpdate</code> (and related APIs) to <code>onReconnect</code>

We renamed the `onEdgeUpdate` function to `onReconnect` and all related APIs (mentioned below). The new name is more descriptive and makes it clear that the function is used to reconnect edges.

* `updateEdge` renamed to `reconnectEdge`
* `onEdgeUpdateStart` renamed to `onReconnectStart`
* `onEdgeUpdate` renamed to `onReconnect`
* `onEdgeUpdateEnd` renamed to `onReconnectEnd`
* `edgeUpdaterRadius` renamed to `reconnectRadius`
* `edge.updatable` renamed to `edge.reconnectable`
* `edgesUpdatable` renamed to `edgesReconnectable`

**Old API**

```js
<ReactFlow
  onEdgeUpdate={onEdgeUpdate}
  onEdgeUpdateStart={onEdgeUpdateStart}
  onEdgeUpdateEnd={onEdgeUpdateEnd}
/>
```

**New API**

```js
<ReactFlow
  onReconnect={onReconnect}
  onReconnectStart={onReconnectStart}
  onReconnectEnd={onReconnectEnd}
/>
```

##### 6. Rename <code>parentNode</code> to <code>parentId</code>

If you are working with subflows, you need to rename `node.parentNode` to `node.parentId`. The `parentNode` attribute was a bit misleading, because it was not a reference to the parent node, but the `id` of the parent node.

**Old API**

```js
const nodes = [
  // some nodes ...
  {
    id: 'xyz-id',
    position: { x: 0, y: 0 },
    type: 'default',
    data: {},
    parentNode: 'abc-id',
  },
];
```

**New API**

```js
const nodes = [
  // some nodes ...
  {
    id: 'xyz-id',
    position: { x: 0, y: 0 },
    type: 'default',
    data: {},
    parentId: 'abc-id',
  },
];
```

##### 7. Custom node props

We renamed the `xPos` and `yPos` props to `positionAbsoluteX` and `positionAbsoluteY`

**Old API**

```js
function CustomNode({ xPos, yPos }) {
  ...
}
```

**New API**

```js
function CustomNode({ positionAbsoluteX, positionAbsoluteY }) {
  ...
}
```

##### 8. Handle component class names

We renamed some of the classes used to define the current state of a handle.

* `react-flow__handle-connecting` renamed to `connectingto` / `connectingfrom`
* `react-flow__handle-valid` renamed to `valid`

##### 9. <code>getNodesBounds</code> options

The type of the second param changed from `nodeOrigin` to `options.nodeOrigin`

**Old API**

```js
const bounds = getNodesBounds(nodes: Node[], nodeOrigin)
```

**New API**

```js
const bounds = getNodesBounds(nodes: Node[], { nodeOrigin })
```

##### 10. Typescript changes for defining nodes and edges

We simplified types and fixed issues about functions where users could pass a NodeData generic. The new way is to define your own node type with a union of all your nodes. With this change, you can now have multiple node types with different data structures and always be able to distinguish by checking the `node.type` attribute.

**New API**

```js
type NumberNode = Node<{ value: number }, 'number'>;
type TextNode = Node<{ text: string }, 'text'>;
type AppNode = NumberNode | TextNode;
```

You can then use the `AppNode` type as the following:

```js
const nodes: AppNode[] = [
  { id: '1', type: 'number', data: { value: 1 }, position: { x: 100, y: 100 } },
  { id: '2', type: 'text', data: { text: 'Hello' }, position: { x: 200, y: 200 } },
];
```

```js
const onNodesChange: onNodesChange<AppNode> = useCallback((changes) => setNodes(nds => applyChanges(changes, nds)), []);
```

You can read more about this in the [Typescript guide](/learn/advanced-use/typescript).

##### 11. Rename <code>nodeInternals</code>

If you are using `nodeInternals` you need to rename it to `nodeLookup`.

**Old API**

```js
const node = useStore((s) => s.nodeInternals.get(id));
```

**New API**

```js
const node = useStore((s) => s.nodeLookup.get(id));
```

##### 12. Removal of deprecated functions

We removed the following deprecated functions:

* `getTransformForBounds` (replaced by `getViewportForBounds`)
* `getRectOfNodes` (replaced by `getNodesBounds`)
* `project` (replaced by `screenToFlowPosition`)
* `getMarkerEndId`
* `updateEdge` (replaced by `reconnectEdge`)

##### 13. Custom <code>applyNodeChanges</code> and <code>applyEdgeChanges</code>

If you wrote your own function for applying changes, you need to handle the new "replace" event. We removed the "reset" event and added a "replace" event that replaces specific nodes or edges.

#### New features

Now that you successfully migrated to v12, you can use all the fancy features. As mentioned above, the biggest updates for v12 are:

##### 1. Server side rendering

You can define `width`, `height` and `handles` for the nodes. This makes it possible to render a flow on the server and hydrate on the client: [server side rendering guide](/learn/advanced-use/ssr-ssg-configuration).

* **Details:** In v11, `width` and `height` were set by the library as soon as the nodes got measured. This still happens, but we are now using `measured.width` and `measured.height` to store this information. In the previous versions there was always a lot of confusion about `width` and `height`. It’s hard to understand, that you can’t use it for passing an actual width or height. It’s also not obvious that those attributes get added by the library. We think that the new implementation solves both of the problems: `width` and `height` are optional attributes that can be used to define dimensions and everything that is set by the library, is stored in `measured`.

##### 2. Computing flows

The new hooks [`useHandleConnections`](/api-reference/hooks/use-handle-connections) and [`useNodesData`](/api-reference/hooks/use-nodes-data) and the new [`updateNode`](/api-reference/hooks/use-react-flow#update-node) and [`updateNodeData`](/api-reference/hooks/use-react-flow#update-node-data) functions (both are part of `useReactFlow`) can be used to manage the data flow between your nodes: [computing flows guide](/learn/advanced-use/computing-flows). We also added those helpers for edges (`updateEdge` and `updateEdgeData`)!

* **Details:** Working with flows where one node data relies on another node is super common. You update node A and want to react on those changes in the connected node B. Until now everyone had to come up with a custom solution. With this version we want to change this and give you performant helpers to handle use cases like this.

##### 3. Dark mode and CSS variables

React Flow now comes with a built-in dark mode, that can be toggled by using the new [`colorMode`](/api-reference/react-flow#color-mode) prop (”light”, “dark” or “system”): [dark mode example](/examples/styling/dark-mode)

* **Details:** With this version we want to make it easier to switch between dark and light modes and give you a better starting point for dark flows. If you pass `colorMode="dark"`, we add the class name "dark" to the wrapper and use it to adjust the styling. To make the implementation for this new feature easier on our ends, we switched to CSS variables for most of the styles. These variables can also be used in user land to customize a flow.

##### 4. A better DX with TSDoc

We started to use TSDoc for a better DX. While developing your IDE will now show you the documentation for the props and hooks. This is a big step for us to make the library more accessible and easier to use. We will also use TSDoc in the near future to generate the documentation.

##### More features and updates

There is more! Besides the new main features, we added some minor things that were on our list for a long time:

* **[`useConnection` hook](/api-reference/hooks/use-connection):** With this hook you can access the ongoing connection. For example, you can use it for colorizing handles styling a custom connection line based on the current start / end handles.
* **Controlled `viewport`:** This is an advanced feature. Possible use cases are to animate the viewport or round the transform for lower res screens for example. This features brings two new props: [`viewport`](/api-reference/react-flow#viewport) and [`onViewportChange`](/api-reference/react-flow#on-viewport-change).
* **[`ViewportPortal`](/api-reference/components/viewport-portal) component:** This makes it possible to render elements in the viewport without the need to implement a custom node.
* **[`onDelete`](/api-reference/react-flow#on-delete) handler**: We added a combined handler for `onDeleteNodes` and `onDeleteEdges` to make it easier to react to deletions.
* **[`onBeforeDelete`](/api-reference/react-flow#on-before-delete) handler**: With this handler you can prevent/ manage deletions.
* **[`isValidConnection`](/api-reference/react-flow#is-valid-connection) prop:** This makes it possible to implement one validation function for all connections. It also gets called for programmatically added edges.
* **[`autoPanSpeed`](/api-reference/react-flow#autoPanSpeed) prop:** For controlling the speed while auto panning.
* **[`paneClickDistance`](/api-reference/react-flow#paneClickDistance) prop:** max distance between mousedown/up that will trigger a click.
* **Background component**: add [`patternClassName`](/api-reference/components/background#pattern-class-name) prop to be able to style the background pattern by using a class name. This is useful if you want to style the background pattern with Tailwind for example.
* **`onMove` callback** gets triggered for library-invoked viewport updates (like fitView or zoom-in)
* **`deleteElements`** now returns deleted nodes and deleted edges
* add **`origin` attribute** for nodes
* add **`selectable` attribute** for edges
* **Node Resizer updates**: child nodes don't move when the group is resized, extent and expand is recognized correctly
* Correct types for `BezierEdge`, `StepEdge`, `SmoothStepEdge` and `StraightEdge` components
* New edges created by the library only have `sourceHandle` and `targetHandle` attributes when those attributes are set. (We used to pass `sourceHandle: null` and `targetHandle: null`)
* Edges do not mount/unmount when their z-index change
* connection line knows about the target handle position so that the path is drawn correctly
* `nodeDragThreshold` is 1 by default instead of 0
* a better selection box usability (capture while dragging out of the flow)
* add `selectable`, `deletable`, `draggable` and `parentId` to `NodeProps`
* add a warning when styles not loaded

##### Internal changes

These changes are not really user-facing, but it could be important for folks who are working with the internal React Flow store:

* The biggest internal change is that we created a new package **@xyflow/system with framework agnostic helpers** that can be used by React Flow and Svelte Flow
  * **XYDrag** for handling dragging node(s) and selection
  * **XYPanZoom** for controlling the viewport panning and zooming
  * **XYHandle** for managing new connections
* We renamed `nodeInternals` to `nodeLookup`. That map serves as a lookup, but we are not creating a new map object on any change so it’s really only useful as a lookup.
* We removed the internal "reset" event and added a "replace" event to be able to update specific nodes.
* We removed `connectionNodeId`, `connectionHandleId`, `connectionHandleType` from the store and added `connection.fromHandle.nodeId`, `connection.fromHandle.id`, …
* add `data-id` to edges
* `onNodeDragStart`, `onNodeDrag` and `onNodeDragStop` also get called when user drags a selection (in addition to `onSelectionDragStart`, `onSelectionDrag`, `onSelectionDragStop`)

import { Callout } from 'nextra/components';
import { RemoteCodeViewer } from 'xy-shared/server';

### Remove Attribution

This example demonstrates how you can remove the React Flow attribution from the renderer.

<Callout type="info">
  If you’re considering removing the attribution, we’d first like to mention:

  **If you’re using React Flow at your organization and making money from it**, we rely on your support to keep React Flow developed and maintained under an MIT License. Before you remove the attribution, [see the ways you can support React Flow to keep it running](/pro).

  **Are you using React Flow for a personal project?** Great! Go ahead and remove the attribution. You can support us by reporting any bugs you find, sending us screenshots of your projects, and starring us on [Github](https://github.com/xyflow/xyflow). If you start making money using React Flow or use it in an organization in the future, we would ask that you re-add the attribution or sign up for one of our subscriptions.

  Thank you for supporting us ✌🏻

  * [the xyflow team](https://xyflow.com/about)
</Callout>

<RemoteCodeViewer route="learn/remove-attribution" framework="react" />

### Getting started with React Flow UI

import { Emoji } from '@xyflow/xy-ui';
import { Callout } from 'nextra/components';
import { Image } from 'xy-shared';
import { RemoteCodeViewer } from 'xy-shared/server';

***Update July 2025**: "React Flow UI" was formerly known as "React Flow Components". We
renamed it because it now includes both components and templates. Additionally, since it's
built on shadcn/ui, the "UI" naming makes it easier for developers to recognize the
connection and understand what we offer.*

Recently, we launched an exciting new addition to our open-source roster: React Flow
Components. These are pre-built nodes, edges, and other ui elements that you can quickly
add to your React Flow applications to get up and running. The catch is these components
are built on top of [shadcn/ui](https://ui.shadcn.com) and the shadcn CLI.

We've previously written about our experience and what led us to choosing shadcn over on
the [xyflow blog](https://xyflow.com/blog/react-flow-components), but in this tutorial
we're going to focus on how to get started from scratch with shadcn, Tailwind CSS, and
React Flow Components.

<Callout>
  **Wait, what's shadcn?**

  No what, **who**! Shadcn is the author of a collection of pre-designed components known as
  `shadcn/ui`. Notice how we didn't say *library* there? Shadcn takes a different approach
  where components are added to your project's source code and are "owned" by you: once you
  add a component you're free to modify it to suit your needs!
</Callout>

#### Getting started

To begin with, we'll set up a new [`vite`](https://vitejs.dev) project along with all the
dependencies and config we'll need. Start by running the following command:

```bash copy npm2yarn
npx create-vite@latest
```

Vite is able to scaffold projects for many popular frameworks, but we only care about
React! Additionally, make sure to set up a **TypeScript** project. React Flow's
documentation is a mix of JavaScript and TypeScript, but for shadcn components TypeScript
is *required*!

All shadcn and React Flow components are styled with
[Tailwind CSS](https://tailwindcss.com/docs/utility-first), so we'll need to install that
and a few other dependencies next:

```bash copy npm2yarn
npm install -D tailwindcss postcss autoprefixer
```

Tailwind is a heavily customizable utility-first CSS framework and much of that
customization is done in a `tailwind.config.js` file. Fortunately, the package can
generate a default config for us:

```bash copy npm2yarn
npx tailwindcss init -p
```

Tailwind works by scanning your project's source code and building a CSS file that
contains only the utilities you're using. To make sure that happens we need to change two
things:

1. Update the `content` field in `tailwind.config.js` to include any source files that
   might contain Tailwind classes.

```js filename="tailwind.config.js" {3}
/** @type {import('tailwindcss').Config} */
export default {
  content: ['./index.html', './src/**/*.{ts,tsx,js,jsx}'],
  theme: {
    extend: {},
  },
  plugins: [],
};
```

2. Replace the generated `src/index.css` file with the Tailwind directives:

```css filename="src/index.css"
@tailwind base;
@tailwind components;
@tailwind utilities;
```

Finally, we can go ahead and delete the generated `src/App.css` file and update
`src/App.jsx` to just render an empty `div`:

```jsx filename="src/App.jsx"
function App() {
  return <div className="w-screen h-screen p-8"></div>;
}

export default App;
```

<Callout>
  The classes `w-screen` and `h-screen` are two examples of Tailwind's utility classes. If
  you're used to styling React apps using a different approach, you might find this a bit
  strange at first. You can think of Tailwind classes as supercharged inline styles:
  they're constrained to a set design system and you have access to responsive media
  queries or pseudo-classes like `hover` and `focus`.
</Callout>

##### Setting up shadcn/ui

Vite scaffolds some `tsconfig` files for us when generating a TypeScript project and we'll
need to make some changes to these so the shadcn components can work correctly. The shadcn
CLI is pretty clever (we'll get to that in a second) but it can't account for every
project structure so instead shadcn components that depend on one another make use of
TypeScript's import paths.

In both `tsconfig.json` and `tsconfig.app.json` add the following to the `compilerOptions`
object:

```json filename="tsconfig.json" {3-8}
{
  ...
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  }
}
```

And then we need to teach Vite how to resolve these paths:

```bash copy npm2yarn
npm i -D @types/node
```

```js filename="vite.config.js" {3, 7-11}
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import path from 'node:path';

export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    },
  },
});
```

At this point feel free to pat yourself on the back and take a tea break. There's a lot of
up-front configuration to get through but once we have the shadcn CLI set up we'll be able
to add new components to our project with a single command - even if they have
dependencies or need to modify existing files!

We can now run the following command to set up shadcn/ui in our project:

```bash copy npm2yarn
npx shadcn@latest init
```

The CLI will ask you a few questions about your project and then it will generate a
`components.json` file in the root of your project, and update your `tailwind.config.js`
with some extensions to your theme. We can take all the default options for now:

```
✔ Which style would you like to use? › New York
✔ Which color would you like to use as the base color? › Neutral
✔ Would you like to use CSS variables for theming? yes
```

#### Adding your first components

To demonstrate how powerful shadcn can be, let's dive right into making a new **React
Flow** app! Now everything is set up, we can add the
[`<BaseNode />`](/ui/components/base-node) component with a single command:

```bash copy npm2yarn
npx shadcn@latest add https://ui.reactflow.dev/base-node
```

This command will generate a new file `src/components/base-node.tsx` as well as update our
dependencies to include `@xyflow/react`!

That `<BaseNode />` component is not a React Flow node directly. Instead, as the name
implies, it's a base that many of our other nodes build upon. It also comes with
additional components that you can use to provide a header and content for your nodes.
These components are:

* `<BaseNodeHeader />`
* `<BaseNodeHeaderTitle />`
* `<BaseNodeContent />`
* `<BaseNodeFooter />`

You can use it to have a unified style for all of your nodes as well. Let's see what it
looks like by updating our `App.jsx` file:

```jsx filename="src/App.jsx"
import '@xyflow/react/dist/style.css';

import { BaseNode } from '@/components/base-node';

function App() {
  return (
    <div className="w-screen h-screen p-8">
      <BaseNode>
        <BaseNodeHeader>
          <BaseNodeHeaderTitle>Base Node</BaseNodeHeaderTitle>
        </BaseNodeHeader>
        <BaseNodeContent>
          This is a base node component that can be used to build other nodes.
        </BaseNodeContent>
      </BaseNode>
    </div>
  );
}

export default App;
```

Ok, not super exciting...

<Image
  src="/img/tutorials/components/base-node.png"
  alt="A screenshot of a simple React application. It renders one element, a
rounded container with a blue border and the text 'Hi! 👋' inside."
/>

Remember that the `<BaseNode />` component is used by any *other* React Flow components we
add using the shadcn CLI, so what happens if we change it? Let's update the `<BaseNode />`
component to render any text as bold monospace instead:

```jsx filename="src/components/base-node.tsx" {11}
import { cn } from "@/lib/utils";
import { forwardRef, HTMLAttributes } from "react";

export const BaseNode = forwardRef<HTMLDivElement, HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => (
    <div
      ref={ref}
      className={cn(
        'relative rounded-md border bg-card text-card-foreground',
        'hover:ring-1',
        // React Flow displays node elements inside of a `NodeWrapper` component,
        // which compiles down to a div with a the class `react-flow__node`.
        // When a node is selected, the class `selected` is added to the
        // `react-flow__node` element. This allows us to style the node when it
        // is selected, using Tailwind's `&` selector.
        '[.react-flow\\_\\_node.selected_&]:border-muted-foreground',
        '[.react-flow\\_\\_node.selected_&]:shadow-lg',
        className,
      )}
      tabIndex={0}
      {...props}
    />
  ),
);
BaseNode.displayName = 'BaseNode';

/**
 * A container for a consistent header layout intended to be used inside the
 * `<BaseNode />` component.
 */
export const BaseNodeHeader = forwardRef<HTMLElement, HTMLAttributes<HTMLElement>>(
  ({ className, ...props }, ref) => (
    <header
      ref={ref}
      {...props}
      className={cn(
        'mx-0 my-0 -mb-1 flex flex-row items-center justify-between gap-2 px-3 py-2',
        // Remove or modify these classes if you modify the padding in the
        // `<BaseNode />` component.
        className,
      )}
    />
  ),
);
BaseNodeHeader.displayName = 'BaseNodeHeader';

/**
 * The title text for the node. To maintain a native application feel, the title
 * text is not selectable.
 */
export const BaseNodeHeaderTitle = forwardRef<
  HTMLHeadingElement,
  HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h3
    ref={ref}
    data-slot="base-node-title"
    className={cn('user-select-none flex-1 font-semibold', className)}
    {...props}
  />
));
BaseNodeHeaderTitle.displayName = 'BaseNodeHeaderTitle';

export const BaseNodeContent = forwardRef<HTMLDivElement, HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => (
    <div
      ref={ref}
      data-slot="base-node-content"
      className={cn('flex flex-col gap-y-2 p-3', className)}
      {...props}
    />
  ),
);
BaseNodeContent.displayName = 'BaseNodeContent';

export const BaseNodeFooter = forwardRef<HTMLDivElement, HTMLAttributes<HTMLDivElement>>(
  ({ className, ...props }, ref) => (
    <div
      ref={ref}
      data-slot="base-node-footer"
      className={cn(
        'flex flex-col items-center gap-y-2 border-t px-3 pb-3 pt-2',
        className,
      )}
      {...props}
    />
  ),
);
BaseNodeFooter.displayName = 'BaseNodeFooter';

```

Now we'll add an actual node from the React Flow UI registry and see what happens:

```bash copy npm2yarn
npx shadcn@latest add https://ui.reactflow.dev/node-tooltip
```

And we'll update our `App.tsx` file to render a proper flow. We'll use the same basic
setup as most of our examples so we won't break down the individual pieces here. If you're
still new to React Flow and want to learn a bit more about how to set up a basic flow from
scratch, check out our [quickstart guide](/learn).

{/* TODO this could be linked to example app with RemoteCodeViewer editor */}

```tsx filename="src/App.tsx"
import React from 'react';
import { ReactFlow, type Node, Position, useNodesState } from '@xyflow/react';

import '@xyflow/react/dist/style.css';

import {
  NodeTooltip,
  NodeTooltipContent,
  NodeTooltipTrigger,
} from './components/node-tooltip';
import { BaseNodeContent } from './components/base-node';

function Tooltip() {
  return (
    <NodeTooltip>
      <NodeTooltipContent position={Position.Top}>Hidden Content</NodeTooltipContent>
      <BaseNode>
        <BaseNodeContent>
          <NodeTooltipTrigger>Hover</NodeTooltipTrigger>
        </BaseNodeContent>
      </BaseNode>
    </NodeTooltip>
  );
}

const nodeTypes = {
  tooltip: Tooltip,
};

const initialNodes: Node[] = [
  {
    id: '1',
    position: { x: 0, y: 0 },
    data: {},
    type: 'tooltip',
  },
];

function Flow() {
  const [nodes, , onNodesChange] = useNodesState(initialNodes);

  return (
    <div className="h-screen w-screen p-8 bg-gray-50 rounded-xl">
      <ReactFlow
        nodes={nodes}
        nodeTypes={nodeTypes}
        onNodesChange={onNodesChange}
        fitView
      />
    </div>
  );
}
export function App() {
  return <Flow />;
}
```

And would you look at that, the tooltip node we added automatically uses the
`<BaseNode />` component we customized!

<RemoteCodeViewer route="tutorials/components/tooltip" framework="react" />

#### Moving fast and making things

Now we've got a basic understanding of how shadcn/ui and the CLI works, we can begin to
see how easy it is to add new components and build out a flow. To see everything React
Flow Components has to offer let's build out a simple calculator flow.

First let's remove the `<NodeTooltip />` and undo our changes to `<BaseNode />`. In
addition to pre-made nodes, React Flow UI also contains building blocks for creating your
own custom nodes. To see them, we'll add the `labeled-handle` component:

```bash copy npm2yarn
npx shadcn@latest add https://ui.reactflow.dev/labeled-handle
```

The first node we'll create is a simple number node with some buttons to increment and
decrement the value and a handle to connect it to other nodes. Create a folder
`src/components/nodes` and then add a new file `src/components/nodes/num-node.tsx`.

Paste the following into the new file and install the following dependencies:

```bash copy npm2yarn
npx shadcn@latest add dropdown-menu button
```

```tsx filename="src/components/nodes/num-node.tsx"
import { type Node, type NodeProps, Position, useReactFlow } from '@xyflow/react';
import { useCallback } from 'react';

import {
  BaseNode,
  BaseNodeContent,
  BaseNodeFooter,
  BaseNodeHeader,
  BaseNodeHeaderTitle,
} from '@/components/base-node';
import { LabeledHandle } from '@/components/labeled-handle';

import { EllipsisVertical } from 'lucide-react';
import { Button } from '@/components/ui/button';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';

export type NumNode = Node<{
  value: number;
}>;

export function NumNode({ id, data }: NodeProps<NumNode>) {
  const { updateNodeData, setNodes } = useReactFlow();

  const handleReset = useCallback(() => {
    updateNodeData(id, { value: 0 });
  }, [id, updateNodeData]);

  const handleDelete = useCallback(() => {
    setNodes((nodes) => nodes.filter((node) => node.id !== id));
  }, [id, setNodes]);

  const handleIncr = useCallback(() => {
    updateNodeData(id, { value: data.value + 1 });
  }, [id, data.value, updateNodeData]);

  const handleDecr = useCallback(() => {
    updateNodeData(id, { value: data.value - 1 });
  }, [id, data.value, updateNodeData]);

  return (
    <BaseNode>
      <BaseNodeHeader className="border-b">
        <BaseNodeHeaderTitle>Num</BaseNodeHeaderTitle>

        <DropdownMenu>
          <DropdownMenuTrigger asChild>
            <Button
              variant="ghost"
              className="nodrag p-1"
              aria-label="Node Actions"
              title="Node Actions"
            >
              <EllipsisVertical className="size-4" />
            </Button>
          </DropdownMenuTrigger>
          <DropdownMenuContent>
            <DropdownMenuLabel>Node Actions</DropdownMenuLabel>
            <DropdownMenuItem onSelect={handleReset}>Reset</DropdownMenuItem>
            <DropdownMenuItem onSelect={handleDelete}>Delete</DropdownMenuItem>
          </DropdownMenuContent>
        </DropdownMenu>
      </BaseNodeHeader>

      <BaseNodeContent>
        <div className="flex gap-2 items-center">
          <Button onClick={handleDecr}>-</Button>
          <pre>{String(data.value).padStart(3, ' ')}</pre>
          <Button onClick={handleIncr}>+</Button>
        </div>
      </BaseNodeContent>

      <BaseNodeFooter className="bg-gray-100 items-end px-0 py-1 w-full">
        <LabeledHandle title="out" type="source" position={Position.Right} />
      </BaseNodeFooter>
    </BaseNode>
  );
}
```

<Callout>
  This isn't a tutorial for basic React Flow concepts like flows and custom nodes so we're
  **skipping over some of the basics**. If you're new to React Flow and want to learn how
  to add custom nodes and edges to a flow, check out the [guide on custom
  nodes](/learn/customization/custom-nodes).
</Callout>

In the snippet above we've highlighted the imports and components that come from shadcn/ui
and React Flow Components. In just a few lines of code we already have quite a capable
node:

<RemoteCodeViewer route="tutorials/components/num-node" framework="react" />

Our `<NumNode />` component...

* Has a header with a title and functional dropdown menu.
* Contains some simple controls to increment and decrement a value.
* Has a labelled handle to connect it to other nodes.

Next we'll create a second node that will compute the sum of two input values. We don't
need to add any additional components for this node, so go ahead and create a new file
`src/components/nodes/sum-node.tsx` and paste in the following:

```tsx filename="src/components/nodes/sum-node.tsx"
import {
  type Node,
  type NodeProps,
  Position,
  useReactFlow,
  useStore,
} from '@xyflow/react';
import { useEffect } from 'react';

import { BaseNode, BaseNodeHeader, BaseNodeHeaderTitle } from '../base-node';
import { LabeledHandle } from '../labeled-handle';

export type SumNode = Node<{
  value: number;
}>;

export function SumNode({ id }: NodeProps<SumNode>) {
  const { updateNodeData, getHandleConnections } = useReactFlow();
  const { x, y } = useStore((state) => ({
    x: getHandleValue(
      getHandleConnections({ nodeId: id, id: 'x', type: 'target' }),
      state.nodeLookup,
    ),
    y: getHandleValue(
      getHandleConnections({ nodeId: id, id: 'y', type: 'target' }),
      state.nodeLookup,
    ),
  }));

  useEffect(() => {
    updateNodeData(id, { value: x + y });
  }, [x, y]);

  return (
    <BaseNode className="w-32">
      <BaseNodeHeader>
        <BaseNodeHeaderTitle>Sum</BaseNodeHeaderTitle>
      </BaseNodeHeader>

      <footer className="bg-gray-100">
        <LabeledHandle title="x" id="x" type="target" position={Position.Left} />
        <LabeledHandle title="y" id="y" type="target" position={Position.Left} />
        <LabeledHandle title="out" type="source" position={Position.Right} />
      </footer>
    </BaseNode>
  );
}

function getHandleValue(
  connections: Array<{ source: string }>,
  lookup: Map<string, Node<any>>,
) {
  return connections.reduce((acc, { source }) => {
    const node = lookup.get(source)!;
    const value = node.data.value;

    return typeof value === 'number' ? acc + value : acc;
  }, 0);
}
```

React Flow UI doesn't just provide components for building nodes. We also provide
pre-built edges and other UI elements you can drop into your flows for quick building.

To better visualize data in our calculator flow, let's pull in the `data-edge` component.
This edge renders a field from the source node's data object as a label on the edge
itself. Add the `data-edge` component to your project:

```bash copy npm2yarn
npx shadcn@latest add https://ui.reactflow.dev/data-edge
```

The `<DataEdge />` component works by looking up a field from its source node's `data`
object. We've been storing the value of each node in our calculator field in a `"value"`
property so we'll update our `edgeType` object to include the new `data-edge` and we'll
update the `onConnect` handler to create a new edge of this type, making sure to set the
edge's `data` object correctly:

```tsx filename="src/App.tsx"
import '@xyflow/react/dist/style.css';

import {
  ReactFlow,
  OnConnect,
  Position,
  useNodesState,
  useEdgesState,
  addEdge,
  Edge,
  Node,
} from '@xyflow/react';

import { NumNode } from '@/components/nodes/num-node';
import { SumNode } from '@/components/nodes/sum-node';

import { DataEdge } from '@/components/data-edge';

const nodeTypes = {
  num: NumNode,
  sum: SumNode,
};

const initialNodes: Node[] = [
  { id: 'a', type: 'num', data: { value: 0 }, position: { x: 0, y: 0 } },
  { id: 'b', type: 'num', data: { value: 0 }, position: { x: 0, y: 200 } },
  { id: 'c', type: 'sum', data: { value: 0 }, position: { x: 300, y: 100 } },
  { id: 'd', type: 'num', data: { value: 0 }, position: { x: 0, y: 400 } },
  { id: 'e', type: 'sum', data: { value: 0 }, position: { x: 600, y: 400 } },
];

const edgeTypes = {
  data: DataEdge,
};

const initialEdges: Edge[] = [
  {
    id: 'a->c',
    type: 'data',
    data: { key: 'value' },
    source: 'a',
    target: 'c',
    targetHandle: 'x',
  },
  {
    id: 'b->c',
    type: 'data',
    data: { key: 'value' },
    source: 'b',
    target: 'c',
    targetHandle: 'y',
  },
  {
    id: 'c->e',
    type: 'data',
    data: { key: 'value' },
    source: 'c',
    target: 'e',
    targetHandle: 'x',
  },
  {
    id: 'd->e',
    type: 'data',
    data: { key: 'value' },
    source: 'd',
    target: 'e',
    targetHandle: 'y',
  },
];

function App() {
  const [nodes, , onNodesChange] = useNodesState(initialNodes);
  const [edges, setEdges, onEdgesChange] = useEdgesState(initialEdges);

  const onConnect: OnConnect = useCallback(
    (params) => {
      setEdges((edges) =>
        addEdge({ type: 'data', data: { key: 'value' }, ...params }, edges),
      );
    },
    [setEdges],
  );

  return (
    <div className="h-screen w-screen p-8">
      <ReactFlow
        nodes={nodes}
        edges={edges}
        onNodesChange={onNodesChange}
        onEdgesChange={onEdgesChange}
        onConnect={onConnect}
        nodeTypes={nodeTypes}
        edgeTypes={edgeTypes}
        fitView
      />
    </div>
  );
}

export default App;
```

Putting everything together we end up with quite a capable little calculator!

<RemoteCodeViewer route="tutorials/components/complete" framework="react" />

You could continue to improve this flow by adding nodes to perform other operations or to
take user input using additional components from the
[shadcn/ui registry](https://ui.shadcn.com/docs/components/slider). In fact, keep your
eyes peeled soon for a follow-up to this guide where we'll show a complete application
built using React Flow Components <Emoji content="👀" />.

#### Wrapping up

In just a short amount of time we've managed to build out a fairly complete flow using the
components and building blocks provided by shadcn React Flow Components. We've learned:

* How editing the [`<BaseNode />`](/ui/components/base-node) component will affect other
  nodes pulled from the React Flow UI registry.

* How to use building blocks like the [`<BaseNodeHeader />`](/ui/components/base-node) and
  [`<LabeledHandle />`](/ui/components/labeled-handle) components to build our own custom
  nodes without starting from scratch.

* That React Flow UI also provides custom edges like the
  [`<DataEdge />`](/ui/components/data-edge) to drop into our applications.

And thanks to the power of Tailwind, tweaking the visual style of these components is as
simple as editing `tailwind.config.js` and editing the variables in your CSS file.

That's all for now! You can see all the components we currently have available over on the
[UI docs page](/ui). The React Flow UI project is still in its infancy: if you have any
suggestions or requests for new components we'd love to hear about them. Or perhaps you're
already starting to build something with shadcn and React Flow UI. Either way make sure
you let us know on our [Discord server](https://discord.com/invite/RVmnytFmGW) or on
[Twitter](https://twitter.com/xyflowdev)!

### Build a Mind Map App with React Flow

import { Emoji } from '@xyflow/xy-ui';
import { RemoteCodeViewer } from 'xy-shared/server';

In this tutorial, you will learn to create a simple mind map tool with React Flow that can be used for brainstorming, organizing an idea, or mapping your thoughts in a visual way. To build this app, we'll be using state management, custom nodes and edges, and more.

#### <Emoji content="🎬" /> It's Demo Time!

Before we get our hands dirty, I want to show you the mind-mapping tool we'll have by the end of this tutorial:

<RemoteCodeViewer route="tutorials/mindmap/app" framework="react" />

If you'd like to live dangerously and dive right into the code, you can find the source code on [Github](https://github.com/xyflow/react-flow-mindmap-app).

#### <Emoji content="👩🏻‍💻" /> Getting started

To do this tutorial you will need some knowledge of [React](https://reactjs.org/docs/getting-started.html) and [React Flow](/learn/concepts/terms-and-definitions) (hi, that's us! <Emoji content="😁" /> it's an open source library for building node-based UIs like workflow tools, ETL pipelines, and [more](/showcase/).)

We'll be using [Vite](https://vitejs.dev/) to develop our app, but you can also use [Create React App](https://create-react-app.dev/) or any other tool you like. To scaffold a new React app with Vite you need to do:

```bash npm2yarn
npm create vite@latest reactflow-mind-map -- --template react
```

if you would like to use Typescript:

```bash npm2yarn
npm create vite@latest reactflow-mind-map -- --template react-ts
```

After the initial setup, you need to install some packages:

```bash npm2yarn
npm install reactflow zustand classcat nanoid
```

We are using [Zustand](https://github.com/pmndrs/zustand) for managing the state of our application. It's a bit like Redux but way smaller and there's less boilerplate code to write. React Flow also uses Zustand, so the installation comes with no additional cost. (For this tutorial we are using Typescript but you can also use plain Javascript.)

To keep it simple we are putting all of our code in the `src/App` folder. For this you need to create the `src/App` folder and add an index file with the following content:

###### src/App/index.tsx

```tsx
import { ReactFlow, Controls, Panel } from '@xyflow/react';

// we have to import the React Flow styles for it to work
import '@xyflow/react/dist/style.css';

function Flow() {
  return (
    <ReactFlow>
      <Controls showInteractive={false} />
      <Panel position="top-left">React Flow Mind Map</Panel>
    </ReactFlow>
  );
}

export default Flow;
```

This will be our main component for rendering the mind map. There are no nodes or edges yet, but we added the React Flow [`Controls`](/api-reference/components/controls) component and a [`Panel`](/api-reference/components/panel) to display the title of our app.

To be able to use React Flow hooks, we need to wrap the application with the [`ReactFlowProvider`](/api-reference/react-flow-provider) component in our main.tsx (entry file for vite). We are also importing the newly created `App/index.tsx` and render it inside the `ReactFlowProvider.` Your main file should look like this:

###### src/main.tsx

```tsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import { ReactFlowProvider } from '@xyflow/react';

import App from './App';

import './index.css';

ReactDOM.createRoot(document.getElementById('root') as HTMLElement).render(
  <React.StrictMode>
    <ReactFlowProvider>
      <App />
    </ReactFlowProvider>
  </React.StrictMode>,
);
```

The parent container of the React Flow component needs a width and a height to work properly. Our app is a fullscreen app, so we add these rules to the `index.css` file:

###### src/index.css

```css
body {
  margin: 0;
}

html,
body,
#root {
  height: 100%;
}
```

We are adding all styles of our app to the `index.css` file (you could also use [Tailwind](/examples/styling/tailwind)). Now you can start the development server with `npm run dev` and you should see the following:

<RemoteCodeViewer route="tutorials/mindmap/getting-started" framework="react" />

#### <Emoji content="🏪" /> A store for nodes and edges

As mentioned above, we are using Zustand for state management. For this, we create a new file in our `src/App` folder called `store.ts`:

###### src/App/store.ts

```ts
import {
  Edge,
  EdgeChange,
  Node,
  NodeChange,
  OnNodesChange,
  OnEdgesChange,
  applyNodeChanges,
  applyEdgeChanges,
} from '@xyflow/react';
import { createWithEqualityFn } from 'zustand/traditional';

export type RFState = {
  nodes: Node[];
  edges: Edge[];
  onNodesChange: OnNodesChange;
  onEdgesChange: OnEdgesChange;
};

const useStore = createWithEqualityFn<RFState>((set, get) => ({
  nodes: [
    {
      id: 'root',
      type: 'mindmap',
      data: { label: 'React Flow Mind Map' },
      position: { x: 0, y: 0 },
    },
  ],
  edges: [],
  onNodesChange: (changes: NodeChange[]) => {
    set({
      nodes: applyNodeChanges(changes, get().nodes),
    });
  },
  onEdgesChange: (changes: EdgeChange[]) => {
    set({
      edges: applyEdgeChanges(changes, get().edges),
    });
  },
}));

export default useStore;
```

It seems like a lot of code, but it's mostly types <Emoji content="😇" /> The store keeps track of the nodes and edges and handles the change events. When a user drags a node, React Flow fires a change event, the store then applies the changes and the updated nodes get rendered. (You can read more about this in our [state management library guide](/api-reference/hooks/use-store).)

As you can see we start with one initial node placed at `{ x: 0, y: 0 }` of type 'mindmap'. To connect the store with our app, we use the `useStore` hook:

###### src/App/index.tsx

```tsx
import { ReactFlow, Controls, Panel, NodeOrigin } from '@xyflow/react';
import { shallow } from 'zustand/shallow';

import useStore, { RFState } from './store';

// we have to import the React Flow styles for it to work
import '@xyflow/react/dist/style.css';

const selector = (state: RFState) => ({
  nodes: state.nodes,
  edges: state.edges,
  onNodesChange: state.onNodesChange,
  onEdgesChange: state.onEdgesChange,
});

// this places the node origin in the center of a node
const nodeOrigin: NodeOrigin = [0.5, 0.5];

function Flow() {
  // whenever you use multiple values, you should use shallow to make sure the component only re-renders when one of the values changes
  const { nodes, edges, onNodesChange, onEdgesChange } = useStore(selector, shallow);

  return (
    <ReactFlow
      nodes={nodes}
      edges={edges}
      onNodesChange={onNodesChange}
      onEdgesChange={onEdgesChange}
      nodeOrigin={nodeOrigin}
      fitView
    >
      <Controls showInteractive={false} />
      <Panel position="top-left">React Flow Mind Map</Panel>
    </ReactFlow>
  );
}

export default Flow;
```

We access the nodes, edges and change handlers from the store and pass them to the React Flow component. We also use the `fitView` prop to make sure that the initial node is centered in the view and set the node origin to `[0.5, 0.5]` to set the origin to the center of a node. After this, your app should look like this:

<RemoteCodeViewer route="tutorials/mindmap/store-nodes-edges" framework="react" />

You can move the node around and zoom in and out, we are getting somewhere <Emoji content="🚀" /> Now let's add some more functionality.

#### <Emoji content="✨" /> Custom nodes and edges

We want to use a custom type called 'mindmap' for our nodes. We need to add a new component for this. Let's create a new folder called `MindMapNode` with an index file under `src/App` with the following content:

###### src/App/MindMapNode/index.tsx

```tsx
import { Handle, NodeProps, Position } from '@xyflow/react';

export type NodeData = {
  label: string;
};

function MindMapNode({ id, data }: NodeProps<NodeData>) {
  return (
    <>
      <input defaultValue={data.label} />

      <Handle type="target" position={Position.Top} />
      <Handle type="source" position={Position.Bottom} />
    </>
  );
}

export default MindMapNode;
```

We are using an input for displaying and editing the labels of our mind map nodes, and two handles for connecting them. This is necessary for React Flow to work; the handles are used as the start and end position of the edges.

We also add some CSS to the `index.css` file to make the nodes look a bit prettier:

###### src/index.css

```css
.react-flow__node-mindmap {
  background: white;
  border-radius: 2px;
  border: 1px solid transparent;
  padding: 2px 5px;
  font-weight: 700;
}
```

(For more on this, you can read the [guide to custom nodes](/learn/customization/custom-nodes) in our docs.)

Let's do the same for the custom edge. Create a new folder called `MindMapEdge` with an index file under `src/App`:

###### src/App/MindMapEdge/index.tsx

```tsx
import { BaseEdge, EdgeProps, getStraightPath } from '@xyflow/react';

function MindMapEdge(props: EdgeProps) {
  const { sourceX, sourceY, targetX, targetY } = props;

  const [edgePath] = getStraightPath({
    sourceX,
    sourceY,
    targetX,
    targetY,
  });

  return <BaseEdge path={edgePath} {...props} />;
}

export default MindMapEdge;
```

I will get into more detail about the custom nodes and edges in the next section. For now it's important that we can use the new types in our app, by adding the following to our `Flow` component:

```tsx
import MindMapNode from './MindMapNode';
import MindMapEdge from './MindMapEdge';

const nodeTypes = {
  mindmap: MindMapNode,
};

const edgeTypes = {
  mindmap: MindMapEdge,
};
```

and then pass the newly created types to the React Flow component.

<RemoteCodeViewer route="tutorials/mindmap/custom-nodes-edges" framework="react" />

Nice! We can already change the labels of our nodes by clicking in the input field and typing something.

#### <Emoji content="🆕" /> New nodes

We want to make it super quick for a user to create a new node. The user should be able to add a new node by clicking on a node and drag to the position where a new node should be placed. This functionality is not built into React Flow, but we can implement it by using the [`onConnectStart` and `onConnectEnd`](/api-reference/react-flow#onconnectstart) handlers.

We are using the start handler to remember the node that was clicked and the end handler to create the new node:

###### Add to src/App/index.tsx

```tsx
const connectingNodeId = useRef<string | null>(null);

const onConnectStart: OnConnectStart = useCallback((_, { nodeId }) => {
  connectingNodeId.current = nodeId;
}, []);

const onConnectEnd: OnConnectEnd = useCallback((event) => {
  // we only want to create a new node if the connection ends on the pane
  const targetIsPane = (event.target as Element).classList.contains('react-flow__pane');

  if (targetIsPane && connectingNodeId.current) {
    console.log(`add new node with parent node ${connectingNodeId.current}`);
  }
}, []);
```

Since our nodes are managed by the store, we create an action to add a new node and its edge. This is how our `addChildNode` action looks:

###### New action in src/store.ts

```ts
addChildNode: (parentNode: Node, position: XYPosition) => {
  const newNode = {
    id: nanoid(),
    type: 'mindmap',
    data: { label: 'New Node' },
    position,
    parentNode: parentNode.id,
  };

  const newEdge = {
    id: nanoid(),
    source: parentNode.id,
    target: newNode.id,
  };

  set({
    nodes: [...get().nodes, newNode],
    edges: [...get().edges, newEdge],
  });
};
```

We are using the passed node as a parent. Normally this feature is used to implement [grouping](/examples/nodes/dynamic-grouping) or [sub flows](/examples/grouping/sub-flows). Here we are using it to move all child nodes when their parent is moved. It enables us to clean up and re-order the mind map so that we don't have to move all child nodes manually. Let's use the new action in our `onConnectEnd` handler:

###### Adjustments in src/App/index.tsx

```tsx
const store = useStoreApi();

const onConnectEnd: OnConnectEnd = useCallback(
  (event) => {
    const { nodeLookup } = store.getState();
    const targetIsPane = (event.target as Element).classList.contains('react-flow__pane');

    if (targetIsPane && connectingNodeId.current) {
      const parentNode = nodeLookup.get(connectingNodeId.current);
      const childNodePosition = getChildNodePosition(event, parentNode);

      if (parentNode && childNodePosition) {
        addChildNode(parentNode, childNodePosition);
      }
    }
  },
  [getChildNodePosition],
);
```

First we are getting the `nodeLookup` from the React Flow store via `store.getState()`. `nodeLookup` is a map that contains all nodes and their current state. We need it to get the position and dimensions of the clicked node. Then we check if the target of the onConnectEnd event is the React Flow pane. If it is, we want to add a new node. For this we are using our `addChildNode` and the newly created `getChildNodePosition` helper function.

###### Helper function in src/App/index.tsx

```tsx
const getChildNodePosition = (event: MouseEvent, parentNode?: Node) => {
  const { domNode } = store.getState();

  if (
    !domNode ||
    // we need to check if these properties exist, because when a node is not initialized yet,
    // it doesn't have a positionAbsolute nor a width or height
    !parentNode?.computed?.positionAbsolute ||
    !parentNode?.computed?.width ||
    !parentNode?.computed?.height
  ) {
    return;
  }

  const panePosition = screenToFlowPosition({
    x: event.clientX,
    y: event.clientY,
  });

  // we are calculating with positionAbsolute here because child nodes are positioned relative to their parent
  return {
    x:
      panePosition.x -
      parentNode.computed?.positionAbsolute.x +
      parentNode.computed?.width / 2,
    y:
      panePosition.y -
      parentNode.computed?.positionAbsolute.y +
      parentNode.computed?.height / 2,
  };
};
```

This function returns the position of the new node we want to add to our store. We are using the [`project` function](/api-reference/types/react-flow-instance#project) to convert screen coordinates into React Flow coordinates. As mentioned earlier, child nodes are positioned relative to their parents. That's why we need to subtract the parent position from the child node position. That was a lot to take in, let's see it in action:

<RemoteCodeViewer route="tutorials/mindmap/create-nodes" framework="react" />

To test the new functionality you can start a connection from a handle and then end it on the pane. You should see a new node being added to the mind map.

#### <Emoji content="🤝" /> Keep data in sync

We can already update the labels but we are not updating the nodes data object. This is important to keep our app in sync and if we want to save our nodes on the server for example. To achieve this we add a new action called `updateNodeLabel` to the store. This action takes a node id and a label. The implementation is pretty straight forward: we iterate over the existing nodes and update the matching one with the passed label:

###### src/store.ts

```ts
updateNodeLabel: (nodeId: string, label: string) => {
  set({
    nodes: get().nodes.map((node) => {
      if (node.id === nodeId) {
        // it's important to create a new object here, to inform React Flow about the changes
        node.data = { ...node.data, label };
      }

      return node;
    }),
  });
},
```

Let's use the new action in our `MindmapNode` component:

###### src/App/MindmapNode/index.tsx

```tsx
import { Handle, NodeProps, Position } from '@xyflow/react';

import useStore from '../store';

export type NodeData = {
  label: string;
};

function MindMapNode({ id, data }: NodeProps<NodeData>) {
  const updateNodeLabel = useStore((state) => state.updateNodeLabel);

  return (
    <>
      <input
        // from now on we can use value instead of defaultValue
        // this makes sure that the input always shows the current label of the node
        value={data.label}
        onChange={(evt) => updateNodeLabel(id, evt.target.value)}
        className="input"
      />

      <Handle type="target" position={Position.Top} />
      <Handle type="source" position={Position.Top} />
    </>
  );
}

export default MindMapNode;
```

That was quick! The input fields of the custom nodes now display the current label of the nodes. You could take your nodes data, save it on the server and then load it again.

#### <Emoji content="💅" /> Simpler UX and nicer styling

Functionality-wise we are finished with our mind map app! We can add new nodes, update their labels and move them around. But the UX and styling could use some improvements. Let's make it easier to drag the nodes and to create new nodes!

##### 1. A node as handle

Let's use the whole node as a handle, rather than displaying the default handles. This makes it easier to create nodes, because the area where you can start a new connection gets bigger. We need to style the source handle to be the size of the node and hide the target handle visually. React Flow still needs it to connect the nodes but we don't need to display it since we are creating new nodes by dropping an edge on the pane. We use plain old CSS to hide the target handle and position it in the center of the node:

###### src/index.css

```css
.react-flow__handle.target {
  top: 50%;
  pointer-events: none;
  opacity: 0;
}
```

In order to make the whole node a handle, we also update the style of the source:

###### src/index.css

```css
.react-flow__handle.source {
  top: 0;
  left: 0;
  transform: none;
  background: #f6ad55;
  height: 100%;
  width: 100%;
  border-radius: 2px;
  border: none;
}
```

<RemoteCodeViewer route="tutorials/mindmap/node-as-handle" framework="react" />

This works but we can't move the nodes anymore because the source handle is now the whole node and covers the input field. We fix that by using the [`dragHandle` node option](/api-reference/types/node#drag-handle). It allows us to specify a selector for a DOM element that should be used as a drag handle. For this we adjust the custom node a bit:

###### src/App/MindmapNode/index.tsx

```tsx
import { Handle, NodeProps, Position } from '@xyflow/react';

import useStore from '../store';

export type NodeData = {
  label: string;
};

function MindMapNode({ id, data }: NodeProps<NodeData>) {
  const updateNodeLabel = useStore((state) => state.updateNodeLabel);

  return (
    <>
      <div className="inputWrapper">
        <div className="dragHandle">
          {/* icon taken from grommet https://icons.grommet.io */}
          <svg viewBox="0 0 24 24">
            <path
              fill="#333"
              stroke="#333"
              strokeWidth="1"
              d="M15 5h2V3h-2v2zM7 5h2V3H7v2zm8 8h2v-2h-2v2zm-8 0h2v-2H7v2zm8 8h2v-2h-2v2zm-8 0h2v-2H7v2z"
            />
          </svg>
        </div>
        <input
          value={data.label}
          onChange={(evt) => updateNodeLabel(id, evt.target.value)}
          className="input"
        />
      </div>

      <Handle type="target" position={Position.Top} />
      <Handle type="source" position={Position.Top} />
    </>
  );
}

export default MindMapNode;
```

We add a wrapper div with the class name `inputWrapper` and a div with the class name `dragHandle` that acts as the drag handle (surprise!). Now we can style the new elements:

###### src/index.css

```css
.inputWrapper {
  display: flex;
  height: 20px;
  z-index: 1;
  position: relative;
}

.dragHandle {
  background: transparent;
  width: 14px;
  height: 100%;
  margin-right: 4px;
  display: flex;
  align-items: center;
}

.input {
  border: none;
  padding: 0 2px;
  border-radius: 1px;
  font-weight: 700;
  background: transparent;
  height: 100%;
  color: #222;
}
```

<RemoteCodeViewer route="tutorials/mindmap/node-as-handle-2" framework="react" />

##### 2. Activate input on focus

We are almost there but we need to adjust some more details. We want to start our new connection from the center of the node. For this we set the pointer events of the input to "none" and check if the user releases the button on top of the node. Only then we want to activate the input field. We can use our `onConnectEnd` function to achieve this:

###### src/App/index.tsx

```tsx
const onConnectEnd: OnConnectEnd = useCallback(
  (event) => {
    const { nodeLookup } = store.getState();
    const targetIsPane = (event.target as Element).classList.contains('react-flow__pane');
    const node = (event.target as Element).closest('.react-flow__node');

    if (node) {
      node.querySelector('input')?.focus({ preventScroll: true });
    } else if (targetIsPane && connectingNodeId.current) {
      const parentNode = nodeLookup.get(connectingNodeId.current);
      const childNodePosition = getChildNodePosition(event, parentNode);

      if (parentNode && childNodePosition) {
        addChildNode(parentNode, childNodePosition);
      }
    }
  },
  [getChildNodePosition],
);
```

As you see we are focusing the input field if the user releases the mouse button on top of a node. We can now add some styling so that the input field is activated (pointerEvents: all) only when it's focused:

```css
/* we want the connection line to be below the node */
.react-flow .react-flow__connectionline {
  z-index: 0;
}

/* pointer-events: none so that the click for the connection goes through */
.inputWrapper {
  display: flex;
  height: 20px;
  position: relative;
  z-index: 1;
  pointer-events: none;
}

/* pointer-events: all so that we can use the drag handle (here the user cant start a new connection) */
.dragHandle {
  background: transparent;
  width: 14px;
  height: 100%;
  margin-right: 4px;
  display: flex;
  align-items: center;
  pointer-events: all;
}

/* pointer-events: none by default */
.input {
  border: none;
  padding: 0 2px;
  border-radius: 1px;
  font-weight: 700;
  background: transparent;
  height: 100%;
  color: #222;
  pointer-events: none;
}

/* pointer-events: all when it's focused so that we can type in it */
.input:focus {
  border: none;
  outline: none;
  background: rgba(255, 255, 255, 0.25);
  pointer-events: all;
}
```

<RemoteCodeViewer route="tutorials/mindmap/node-as-handle-3" framework="react" />

##### 3. Dynamic width and auto focus

Almost done! We want to have a dynamic width for the nodes based on the length of the text. To keep it simple we do a calculation based on the length of text for this:

###### Added effect in src/app/MindMapNode.tsx

```jsx
useLayoutEffect(() => {
  if (inputRef.current) {
    inputRef.current.style.width = `${data.label.length * 8}px`;
  }
}, [data.label.length]);
```

We also want to focus / activate a node right after it gets created:

###### Added effect in src/app/MindMapNode.tsx

```jsx
useEffect(() => {
  setTimeout(() => {
    if (inputRef.current) {
      inputRef.current.focus({ preventScroll: true });
    }
  }, 1);
}, []);
```

<RemoteCodeViewer route="tutorials/mindmap/node-as-handle-4" framework="react" activeFile="MindMapNode.tsx" />

Now when you adjust a node label, the width of the node will adjust accordingly. You can also create a new node and it will be focused right away.

##### 4. Centered edges and styling details

You may have noticed that the edges are not centered. We created a custom edge at the beginning for this, and now we can adjust it a bit so that the edge starts in the center of the node and not at the top of the handle (the default behavior):

###### src/App/MindMapEdge.tsx

```tsx
import { BaseEdge, EdgeProps, getStraightPath } from '@xyflow/react';

function MindMapEdge(props: EdgeProps) {
  const { sourceX, sourceY, targetX, targetY } = props;

  const [edgePath] = getStraightPath({
    sourceX,
    sourceY: sourceY + 20,
    targetX,
    targetY,
  });

  return <BaseEdge path={edgePath} {...props} />;
}

export default MindMapEdge;
```

We are passing all props to the [`getStraightPath`](/api-reference/utils/get-straight-path) helper function but adjust the sourceY so that it is in the center of the node.

More over we want the title to be a bit more subtle and choose a color for our background. We can do this by adjusting the color of the panel (we added the class name `"header"`) and the background color of the body element:

```css
body {
  margin: 0;
  background-color: #f8f8f8;
  height: 100%;
}

.header {
  color: #cdcdcd;
}
```

Nicely done! <Emoji content="💯" /> You can find the final code here:

<RemoteCodeViewer route="tutorials/mindmap/node-as-handle-4" framework="react" activeFile="MindMapNode.tsx" />

#### <Emoji content="👋" /> Final thoughts

What a trip! We started with an empty pane and ended with a fully functional mind map app. If you want to move on you could work on some of the following features:

* Add new nodes by clicking on the pane
* Save and restore button to store current state to local storage
* Export and import UI
* Collaborative editing

I hope you enjoyed this tutorial and learned something new! If you have any questions or feedback, feel free to reach out to me on [Twitter](https://twitter.com/moklick) or join our [Discord server](https://discord.com/invite/RVmnytFmGW). React Flow is an independent company financed by its users. If you want to support us you can [sponsor us on Github](https://github.com/sponsors/xyflow) or [subscribe to one of our Pro plans](/pro/).

### Integrating React Flow and the Web Audio API

import { Emoji } from '@xyflow/xy-ui';
import { Callout, Tabs } from 'nextra/components';
import { Embed, Image } from 'xy-shared';
import { RemoteCodeViewer } from 'xy-shared/server';

Today we'll be looking at how to create an interactive audio playground using React
Flow and the Web Audio API. We'll start from scratch, first learning about the Web
Audio API before looking at how to handle many common scenarios in React Flow:
state management, implementing custom nodes, and adding interactivity.

<Image
  src="/img/tutorials/webaudio/bleep-cafe.png"
  alt="A screenshot of bleep.cafe, a visual audio programming environment. In it,
there are four nodes connected together: an xy pad, an oscillator node, a
volume node, and a master output."
  wide
  caption="This is bleep.cafe. We're going to learn everything we need to know to
build something just like it!"
/>

A while back I shared a project I was working on to the React Flow [discord
server](https://discord.com/invite/RVmnytFmGW). It's called
[bleep.cafe](https://bleep.cafe) and it's a little web app for learning digital synthesis
all inside the browser. A lot of folks were interested to see how something like that was
put together: most people don't even know **their browser has a whole synth engine built
in!**

This tutorial will take us step-by-step to build something similar. We may skip
over some bits here and there, but for the most part if you're new to React Flow
*or* the Web Audio API you should be able to follow along and have something
working by the end.

If you're already a React Flow wizard you might want to read the first section
covering the Web Audio API and then jump to the third to see how things are tied
together!

But first...

#### A demo!

<Embed src="https://xyflow.github.io/react-flow-web-audio/" />

<Callout type="warning">
  This and other examples in this tutorial *make sound*. To avoid creating an avant-garde
  masterpiece, remember to mute each example before moving on!
</Callout>

#### The Web Audio API

Before we get stuck in to React Flow and interactive node editor goodness, we need
to take a crash course on the [Web Audio API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API).
Here are the highlights you need to know:

* The Web Audio API provides a variety of different audio nodes, including sources
  (e.g. [OscillatorNode](https://developer.mozilla.org/en-US/docs/Web/API/OscillatorNode),
  [MediaElementAudioSourceNode](https://developer.mozilla.org/en-US/docs/Web/API/MediaElementAudioSourceNode)),
  effects (e.g. [GainNode](https://developer.mozilla.org/en-US/docs/Web/API/GainNode),
  [DelayNode](https://developer.mozilla.org/en-US/docs/Web/API/DelayNode),
  [ConvolverNode](https://developer.mozilla.org/en-US/docs/Web/API/ConvolverNode)),
  and outputs (e.g. [AudioDestinationNode](https://developer.mozilla.org/en-US/docs/Web/API/AudioDestinationNode)).
* Audio nodes can be connected together to form a (potentially cyclic) graph.
  We tend to call this the audio-processing graph, signal graph, or signal chain.
* Audio processing is handled in a separate thread by native code. This means we
  can keep generating sounds even when the main UI thread is busy or blocked.
* An [AudioContext](https://developer.mozilla.org/en-US/docs/Web/API/AudioContext)
  acts as the brain of an audio-processing graph. We can use it to create new audio
  nodes and suspend or resume audio processing entirely.

##### Hello, sound!

Let's see some of this stuff in action and build our first Web Audio app! We won't
be doing anything too wild: we'll make a simple mouse
[theremin](http://www.thereminworld.com/Article/14232/what-s-a-theremin-). We'll
use React for these examples and everything else moving forward (we're called React
Flow after all!) and [`vite`](https://vitejs.dev) to handle bundling and hot
reloading.

If you prefer another bundler like parcel or Create React App that's cool too, they
all do largely the same thing. You could also choose to use TypeScript instead
of JavaScript. To keep things simple we won't use it today, but React Flow is
fully typed (and written entirely in TypeScript) so it's a breeze to use!

```bash npm2yarn
npm create vite@latest -- --template react
```

Vite will scaffold out a simple React application for us, but can delete the assets
and jump right into `App.jsx`. Remove the demo component generated for us and start
by creating a new AudioContext and putting together the nodes we need. We want
an OscillatorNode to generate some tones and a GainNode to control the volume.

```js filename="./src/App.jsx"
// Create the brain of our audio-processing graph
const context = new AudioContext();

// Create an oscillator node to generate tones
const osc = context.createOscillator();

// Create a gain node to control the volume
const amp = context.createGain();

// Pass the oscillator's output through the gain node and to our speakers
osc.connect(amp);
amp.connect(context.destination);

// Start generating those tones!
osc.start();
```

<Callout type="info">
  Oscillator nodes need to be started.

  Don't forget that call to `osc.start`. The oscillator won't start generating
  tones without it!
</Callout>

For our app, we'll track the mouse's position on the screen and use that to set
the pitch of the oscillator node and the volume of the gain node.

```jsx filename="./src/App.jsx" {12-27}
import React from 'react';

const context = new AudioContext();
const osc = context.createOscillator();
const amp = context.createGain();

osc.connect(amp);
amp.connect(context.destination);

osc.start();

const updateValues = (e) => {
  const freq = (e.clientX / window.innerWidth) * 1000;
  const gain = e.clientY / window.innerHeight;

  osc.frequency.value = freq;
  amp.gain.value = gain;
};

export default function App() {
  return <div style={{ width: '100vw', height: '100vh' }} onMouseMove={updateValues} />;
}
```

<Callout type="info">
  `osc.frequency.value`, `amp.gain.value`...

  The Web Audio API makes a distinction between simple object properties and audio
  node *parameters*. That distinction appears in the form of an `AudioParam`. You
  can read up on them in the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/API/AudioParam)
  but for now it's enough to know that you need to use `.value` to set the value
  of an `AudioParam` rather than just assigning a value to the property directly.
</Callout>

If you try this example as it is, you'll probably find that nothing happens. An
AudioContext often starts in a suspended state in an attempt to avoid ads hijacking
our speakers. We can fix that easily by adding a click handler on the `<div />`
to resume the context if it's suspended.

```jsx filename="./src/App.jsx" {1-7,12}
const toggleAudio = () => {
  if (context.state === 'suspended') {
    context.resume();
  } else {
    context.suspend();
  }
};

export default function App() {
  return (
    <div ...
      onClick={toggleAudio}
    />
  );
};
```

And that's everything we need to start making some sounds with the Web Audio API!
Here's what we put together, in case you weren't following along at home:

<RemoteCodeViewer route="tutorials/webaudio/mouse-theremin" framework="react" />

Now let's put this knowledge to one side and take a look at how to build a React Flow
project from scratch.

<Callout type="info">
  Already a React Flow pro? If you're already familiar with React Flow, you can
  comfortably skip over the next section and head straight on over to [making some
  sounds](#do-sound-to-it). For everyone else, let's take a look at how to build a React
  Flow project from scratch.
</Callout>

#### Scaffolding a React Flow project

Later on we'll take what we've learned about the Web Audio API, oscillators, and
gain nodes and use React Flow to interactively build audio-processing graphs.
For now though, we need to put together an empty React Flow app.

We already have a React app set up with Vite, so we'll keep using that. If you
skipped over the last section, we ran `npm create vite@latest -- --template react`
to get started. You can use whatever bundler and/or dev server you like, though.
Nothing here is vite specific.

We only need three additional dependencies for this project: `@xyflow/react` for our
UI (obviously!), `zustand` as our simple state management library (that's what we use
under the hood at React Flow) and `nanoid` as a lightweight id generator.

```bash npm2yarn
npm install @xyflow/react zustand nanoid
```

We're going to remove everything from our Web Audio crash course and start from
scratch. Start by modifying `main.jsx` to match the following:

```jsx filename="./src/main.jsx"
import App from './App';
import React from 'react';
import ReactDOM from 'react-dom/client';
import { ReactFlowProvider } from '@xyflow/react';

// 👇 Don't forget to import the styles!
import '@xyflow/react/dist/style.css';
import './index.css';

const root = document.querySelector('#root');

ReactDOM.createRoot(root).render(
  <React.StrictMode>
    {/* React flow needs to be inside an element with a known height and width to work */}
    <div style={{ width: '100vw', height: '100vh' }}>
      <ReactFlowProvider>
        <App />
      </ReactFlowProvider>
    </div>
  </React.StrictMode>,
);
```

There are three important things to pay attention to here:

1. You need to remember to **import the React Flow CSS styles** to make sure everything
   works correctly.
2. The React Flow renderer needs to be inside an element with a known height and width,
   so we've set the containing `<div />` to take up the entire screen.
3. To use some of the hooks React Flow provides, your components need to be inside a
   `<ReactFlowProvider />` or inside the `<ReactFlow />` component itself, so we've
   wrapped the entire app in the provider to be sure.

Next, hop into `App.jsx` and create an empty flow:

```jsx filename="./src/App.jsx"
import React from 'react';
import { ReactFlow, Background } from '@xyflow/react';

export default function App() {
  return (
    <ReactFlow>
      <Background />
    </ReactFlow>
  );
}
```

We'll expand and add on to this component over time. For now, we've added one of
React Flow's built-in components - [`<Background />`](/api-reference/components/background) -
to check if everything is setup correctly. Go ahead and run `npm run dev` (or
whatever you need to do to spin up a dev server if you didn't choose vite) and
check out your browser. You should see an empty flow:

<Image src="/img/tutorials/webaudio/empty-flow.png" alt="Screenshot of an empty React Flow graph" />

Leave the dev server running. We can keep checking back on our progress as we add
new bits and bobs.

##### 1. State management with Zustand

A Zustand store will hold all the UI state for our application. In practical terms
that means it'll hold the nodes and edges of our React Flow graph, a few other
pieces of state, and a handful of *actions* to update that state.

To get a basic interactive React Flow graph going we need three actions:

1. `onNodesChange` to handle nodes being moved around or deleted.
2. `onEdgesChange` to handle *edges* being moved around or deleted.
3. `addEdge` to connect two nodes in the graph.

Go ahead and create a new file, `store.js`, and add the following:

```js filename="./src/store.js"
import { applyNodeChanges, applyEdgeChanges } from '@xyflow/react';
import { nanoid } from 'nanoid';
import { createWithEqualityFn } from 'zustand/traditional';

export const useStore = createWithEqualityFn((set, get) => ({
  nodes: [],
  edges: [],

  onNodesChange(changes) {
    set({
      nodes: applyNodeChanges(changes, get().nodes),
    });
  },

  onEdgesChange(changes) {
    set({
      edges: applyEdgeChanges(changes, get().edges),
    });
  },

  addEdge(data) {
    const id = nanoid(6);
    const edge = { id, ...data };

    set({ edges: [edge, ...get().edges] });
  },
}));
```

Zustand is dead simple to use. We create a function that receives both a `set` and
a `get` function and returns an object with our initial state along with the actions
we can use to update that state. Updates happen immutably and we can use the `set`
function for that. The `get` function is how we read the current state. And...
that's it for zustand.

The `changes` argument in both `onNodesChange` and `onEdgesChange` represents
events like a node or edge being moved or deleted. Fortunately, React Flow provides
some [helper](/api-reference/utils/apply-node-changes)
[functions](/api-reference/utils/apply-edge-changes) to apply those changes
for us. We just need to update the store with the new array of nodes.

`addEdge` will be called whenever two nodes get connected. The `data` argument is
*almost* a valid edge, it's just missing an id. Here we're getting nanoid to
generate a 6 character random id and then adding the edge to our graph, nothing
exciting.

If we hop back over to our `<App />` component we can hook React Flow up to our
actions and get something working.

```jsx filename="./src/App.jsx" {3,5,7-13,16,20-24}
import React from 'react';
import { ReactFlow, Background } from '@xyflow/react';
import { shallow } from 'zustand/shallow';

import { useStore } from './store';

const selector = (store) => ({
  nodes: store.nodes,
  edges: store.edges,
  onNodesChange: store.onNodesChange,
  onEdgesChange: store.onEdgesChange,
  addEdge: store.addEdge,
});

export default function App() {
  const store = useStore(selector, shallow);

  return (
    <ReactFlow
      nodes={store.nodes}
      edges={store.edges}
      onNodesChange={store.onNodesChange}
      onEdgesChange={store.onEdgesChange}
      onConnect={store.addEdge}
    >
      <Background />
    </ReactFlow>
  );
}
```

So what's this `selector` thing all about? Zustand let's us supply a selector
function to pluck out the exact bits of state we need from the store. Combined
with the `shallow` equality function, this means we typically don't have re-renders
when state we don't care about changes.

Right now, our store is small and we actually want everything from it to help
render our React Flow graph, but as we expand on it this selector will make sure
we're not re-rendering *everything* all the time.

This is everything we need to have an interactive graph: we can move nodes around,
connect them together, and remove them. To demonstrate, *temporarily* add some
dummy nodes to your store:

```js filename="./store.jsx" {2-6}
const useStore = createWithEqualityFn((set, get) => ({
  nodes: [
    { id: 'a', data: { label: 'oscillator' }, position: { x: 0, y: 0 } },
    { id: 'b', data: { label: 'gain' }, position: { x: 50, y: 50 } },
    { id: 'c', data: { label: 'output' }, position: { x: -50, y: 100 } }
  ],
  ...
}));
```

<RemoteCodeViewer route="tutorials/webaudio/state-management" framework="react" />

##### 2. Custom nodes

OK great, we have an interactive React Flow instance we can start playing with.
We added some dummy nodes but they're just the default unstyled ones right now.
In this step we'll add three custom nodes with interactive controls:

1. An oscillator node and controls for the pitch and waveform type.
2. A gain node and a control for the volume
3. An output node and a button to toggle audio processing on and off.

Let's create a new folder, `nodes/`, and create a file for each custom node we
want to create. Starting with the oscillator we need two controls and a source
handle to connect the output of the oscillator to other nodes.

```jsx filename="./src/nodes/Osc.jsx"
import React from 'react';
import { Handle } from '@xyflow/react';

import { useStore } from '../store';

export default function Osc({ id, data }) {
  return (
    <div>
      <div>
        <p>Oscillator Node</p>

        <label>
          <span>Frequency</span>
          <input
            className="nodrag"
            type="range"
            min="10"
            max="1000"
            value={data.frequency} />
          <span>{data.frequency}Hz</span>
        </label>

        <label>
          <span>Waveform</span>
          <select className="nodrag" value={data.type}>
            <option value="sine">sine</option>
            <option value="triangle">triangle</option>
            <option value="sawtooth">sawtooth</option>
            <option value="square">square</option>
          </select>
      </div>

      <Handle type="source" position="bottom" />
    </div>
  );
};
```

<Callout type="info">
  "nodrag" is important.

  Pay attention to the `"nodrag"` class being added to both the `<input />` and
  `<select />` elements. It's *super important* that you remember to add this class
  otherwise you'll find that React Flow intercepts the mouse events and you'll be
  stuck dragging the node around forever!
</Callout>

If we try rendering this custom node we'll find that the inputs don't do anything.
That's because the input values are fixed by `data.frequency` and `data.type` but
we have no event handlers listening to changes and no mechanism to update a node's
data!

To fix the situation we need to jump back to our store and add an `updateNode` action:

```js filename="./src/store.js"
export const useStore = createWithEqualityFn((set, get) => ({
  ...

  updateNode(id, data) {
    set({
      nodes: get().nodes.map(node =>
        node.id === id
          ? { ...node, data: { ...node.data, ...data } }
          : node
      )
    });
  },

  ...
}));
```

This action will handle partial data updates, such that if we only want to update a
node's `frequency`, for example, we could just call `updateNode(id, { frequency: 220 }`.
Now we just need to bring the action into our `<Osc />` component and call it
whenever an input changes.

```jsx filename="./src/nodes/Osc.jsx" {3,7-10,13,28,35}
import React from 'react';
import { Handle } from '@xyflow/react';
import { shallow } from 'zustand/shallow';

import { useStore } from '../store';

const selector = (id) => (store) => ({
  setFrequency: (e) => store.updateNode(id, { frequency: +e.target.value }),
  setType: (e) => store.updateNode(id, { type: e.target.value }),
});

export default function Osc({ id, data }) {
  const { setFrequency, setType } = useStore(selector(id), shallow);

  return (
    <div>
      <div>
        <p>Oscillator Node</p>

        <label>
          <span>Frequency:</span>
          <input
            className="nodrag"
            type="range"
            min="10"
            max="1000"
            value={data.frequency}
            onChange={setFrequency}
          />
          <span>{data.frequency}Hz</span>
        </label>

        <label>
          <span>Waveform:</span>
          <select className="nodrag" value={data.type} onChange={setType}>
            <option value="sine">sine</option>
            <option value="triangle">triangle</option>
            <option value="sawtooth">sawtooth</option>
            <option value="square">square</option>
          </select>
        </label>
      </div>

      <Handle type="source" position="bottom" />
    </div>
  );
}
```

Hey, that `selector` is back! Notice how this time we're using it to derive
two event handlers, `setFrequency` and `setType`, from the general `updateNode`
action.

The last piece of the puzzle is to tell React Flow how to render our custom node.
For that we need to create a `nodeTypes` object: the keys should correspond to a
node's `type` and the value will be the React component to render.

```jsx filename="./src/App.jsx" {5,16-18,26}
import React from 'react';
import { ReactFlow } from '@xyflow/react';
import { shallow } from 'zustand/shallow';

import { useStore } from './store';
import Osc from './nodes/Osc';

const selector = (store) => ({
  nodes: store.nodes,
  edges: store.edges,
  onNodesChange: store.onNodesChange,
  onEdgesChange: store.onEdgesChange,
  addEdge: store.addEdge,
});

const nodeTypes = {
  osc: Osc,
};

export default function App() {
  const store = useStore(selector, shallow);

  return (
    <ReactFlow
      nodes={store.nodes}
      nodeTypes={nodeTypes}
      edges={store.edges}
      onNodesChange={store.onNodesChange}
      onEdgesChange={store.onEdgesChange}
      onConnect={store.addEdge}
    >
      <Background />
    </ReactFlow>
  );
}
```

<Callout type="info">
  Avoid unnecessary renders.

  It's important to define `nodeTypes` outside of the `<App />` component (or use
  React's [`useMemo`](https://react.dev/reference/react/useMemo)) to avoid recomputing
  it every render.
</Callout>

If you've got the dev server running, don't panic if things haven't changed yet!
None of our temporary nodes have been given the right type yet, so React Flow
just falls back to rendering the default node. If we change one of those nodes to
be an `osc` with some initial values for `frequency` and `type` we should see
our custom node being rendered.

```js title"./src/store.js"
const useStore = createWithEqualityFn((set, get) => ({
  nodes: [
    { type: 'osc',
      id: 'a',
      data: { frequency: 220, type: 'square' },
      position: { x: 0, y: 0 }
    },
    ...
  ],
  ...
}));
```

<RemoteCodeViewer route="tutorials/webaudio/custom-node" framework="react" />

<Callout type="info">
  Stuck on styling?

  If you're just implementing the code from this post as you go along, you'll
  see that your custom node doesn't look like the one in the preview above. To keep
  things easy to digest, we've left out styling in the code snippets.

  To learn how to style your custom nodes, check out our docs on
  [theming](/learn/customization/theming) or our example using
  [Tailwind](/examples/styling/tailwind).
</Callout>

Implementing a gain node is pretty much the same process, so we'll leave that one
to you. Instead, we'll turn our attention to the output node. This node will
have no parameters control, but we do want to toggle signal processing on and off.
That's a bit difficult right now when we haven't implemented any audio code yet,
so in the meantime we'll add just a flag to our store and an action to toggle it.

```js filename="./src/store.js"
const useStore = createWithEqualityFn((set, get) => ({
  ...

  isRunning: false,

  toggleAudio() {
    set({ isRunning: !get().isRunning });
  },

  ...
}));
```

The custom node itself is then pretty simple:

```jsx filename="./src/nodes/Out.jsx"
import React from 'react';
import { Handle } from '@xyflow/react';
import { shallow } from 'zustand/shallow';
import { useStore } from '../store';

const selector = (store) => ({
  isRunning: store.isRunning,
  toggleAudio: store.toggleAudio,
});

export default function Out({ id, data }) {
  const { isRunning, toggleAudio } = useStore(selector, shallow);

  return (
    <div>
      <Handle type="target" position="top" />

      <div>
        <p>Output Node</p>

        <button onClick={toggleAudio}>
          {isRunning ? (
            <span role="img" aria-label="mute">
              🔇
            </span>
          ) : (
            <span role="img" aria-label="unmute">
              🔈
            </span>
          )}
        </button>
      </div>
    </div>
  );
}
```

Things are starting to shape up quite nicely!

<RemoteCodeViewer route="tutorials/webaudio/custom-nodes" framework="react" />

The next step, then, is to…

#### Do sound to it

We have an interactive graph and we're able to update node data, now let's add
in what we know about the Web Audio API. Start by creating a new file, `audio.js`,
and create a new audio context and an empty `Map`.

```js filename="./src/audio.js"
const context = new AudioContext();
const nodes = new Map();
```

The way we'll manage our audio graph is by hooking into the different actions in
our store. So we might connect two audio nodes when the `addEdge` action is called,
or update an audio node's properties when `updateNode` is called, and so on.

<Callout type="warning">
  Hardcoded nodes

  We hardcoded a couple of nodes in our store earlier on in this post but our audio
  graph doesn't know anything about them! For the finished project we can do away
  with all these hardcoded bits, but for now it's **really important** that we also
  hardcode some audio nodes.

  Here's how we did it:

  ```js filename="./src/audio.js" {4-7,9-10,12,14-16}
  const context = new AudioContext();
  const nodes = new Map();

  const osc = context.createOscillator();
  osc.frequency.value = 220;
  osc.type = 'square';
  osc.start();

  const amp = context.createGain();
  amp.gain.value = 0.5;

  const out = context.destination;

  nodes.set('a', osc);
  nodes.set('b', amp);
  nodes.set('c', out);
  ```
</Callout>

##### 1. Node changes

Right now, there are two types of node changes that can happen in our graph and
that we need to respond to: updating a node's `data`, and removing a node from the
graph. We already have an action for the former, so let's handle that first.

In `audio.js` we'll define a function, `updateAudioNode`, that we'll call with a
node's id and a partial `data` object and use it to update an existing node in
the `Map`:

```js filename="./src/audio.js"
export function updateAudioNode(id, data) {
  const node = nodes.get(id);

  for (const [key, val] of Object.entries(data)) {
    if (node[key] instanceof AudioParam) {
      node[key].value = val;
    } else {
      node[key] = val;
    }
  }
}
```

<Callout type="info">
  Remember that properties on an audio node may be special `AudioParams` that must be
  updated differently to regular object properties.
</Callout>

Now we'll want to update our `updateNode` action in the store to call this function
as part of the update:

```js filename="./src/store.js"
import { updateAudioNode } from './audio';

export const useStore = createWithEqualityFn((set, get) => ({
  ...

  updateNode(id, data) {
    updateAudioNode(id, data);
    set({ nodes: ... });
  },

  ...
}));

```

The next change we need to handle is removing a node from the graph. If you select
a node in the graph and hit backspace, React Flow will remove it. This is implicitly
handled for us by the `onNodesChange` action we hooked up, but now we want some
additional handling we'll need to wire up a new action to React Flow's `onNodesDelete`
event.

This is actually pretty simple, so I'll save you some reading and present the next
three snippets of code without comment.

<Tabs items={['./src/audio.js', './src/store.js', './src/App.jsx']}>
  <Tabs.Tab>
    ```js
    export function removeAudioNode(id) {
      const node = nodes.get(id);

      node.disconnect();
      node.stop?.();

      nodes.delete(id);
    }
    ```
  </Tabs.Tab>

  <Tabs.Tab>
    ```js
    import { ..., removeAudioNode } from './audio';

    export const useStore = createWithEqualityFn((set, get) => ({
      ...

      removeNodes(nodes) {
        for (const { id } of nodes) {
          removeAudioNode(id)
        }
      },

      ...
    }));
    ```
  </Tabs.Tab>

  <Tabs.Tab>
    ```jsx
    const selector = store => ({
      ...,
      onNodesDelete: store.removeNodes
    });

    export default function App() {
      const store = useStore(selector, shallow);

      return (
        <ReactFlow
          onNodesDelete={store.onNodesDelete}
          ...
        >
          <Background />
        </ReactFlow>
      )
    };
    ```
  </Tabs.Tab>
</Tabs>

The only thing to note is that `onNodesDelete` calls the provided callback with
an *array* of deleted nodes, because it is possible to delete more than one node
at once!

##### 2. Edge changes

We're getting super close to actually making some sounds! All that's left is to
handle changes to our graph's edges. Like with node changes, we already have an
action to handle creating new edges and we're also implicitly handling removed
edges in `onEdgesChange`.

To handle new connections, we just need the `source` and `target` ids from the
edge created in our `addEdge` action. Then we can just look up the two nodes in
our `Map` and connect them up.

<Tabs items={["./src/audio.js", "./src/store.js"]}>
  <Tabs.Tab>
    ```js
    export function connect(sourceId, targetId) {
      const source = nodes.get(sourceId);
      const target = nodes.get(targetId);

      source.connect(target);
    }
    ```
  </Tabs.Tab>

  <Tabs.Tab>
    ```js
    import { ..., connect } from './audio';

    export const useStore = createWithEqualityFn((set, get) => ({
      ...

      addEdge(data) {
        ...

        connect(data.source, data.target);
      },

      ...
    }));
    ```
  </Tabs.Tab>
</Tabs>

We saw React Flow accepted an `onNodesDelete` handler and wouldn't you know it,
there's an `onEdgesDelete` handler too! The approach we'd take to implement `disconnect`
and hook it up to our store and React Flow instance is pretty much the same as
before, so we'll leave that one down to you as well!

##### 3. Switching the speakers on

You'll remember that our `AudioContext` probably begins in a suspended state to
prevent potentially annoying autoplay issues. We already faked the data and actions
we need for our `<Out />` component in the store, now we just need to replace
them with the real context's state and resume/suspend methods.

```js filename="./src/audio.js"
export function isRunning() {
  return context.state === 'running';
}

export function toggleAudio() {
  return isRunning() ? context.suspend() : context.resume();
}
```

Although we haven't been returning anything from our audio functions up until now,
we need to return from `toggleAudio` because those methods are
asynchronous and we don't want to update the store prematurely!

```js filename="./src/store.js"
import { ..., isRunning, toggleAudio } from './audio'

export const useStore = createWithEqualityFn((set, get) => ({
  ...

  isRunning: isRunning(),

  toggleAudio() {
    toggleAudio().then(() => {
      set({ isRunning: isRunning() });
    });
  }
}));
```

Et voilà, we did it! We've now put enough together to actually *make sounds*!
Let's see what we have in action.

<RemoteCodeViewer route="tutorials/webaudio/hardcoded-audio" framework="react" />

##### 4. Creating new nodes

Up until now we have been dealing with a hard-coded set of nodes in our graph.
This has been fine for prototyping but for it to actually be useful we'll want a
way to add new nodes to the graph dynamically. Our final task will be adding this
functionality: we'll work backwards starting with the audio code and ending by
creating a basic toolbar.

Implementing a `createAudioNode` function will be simple enough. All we need is
an id for the new node, the type of node to create, and its initial data:

```js filename="./src/audio.js"
export function createAudioNode(id, type, data) {
  switch (type) {
    case 'osc': {
      const node = context.createOscillator();
      node.frequency.value = data.frequency;
      node.type = data.type;
      node.start();

      nodes.set(id, node);
      break;
    }

    case 'amp': {
      const node = context.createGain();
      node.gain.value = data.gain;

      nodes.set(id, node);
      break;
    }
  }
}
```

Next we'll need a `createNode` function in our store. The node id will be generated
by nanoid and we'll hardcode some initial data for each of the node types, so the
only thing we need to pass in is the type of node to create:

```js filename="./src/store.js"
import { ..., createAudioNode } from './audio';

export const useStore = createWithEqualityFn((set, get) => ({
  ...

  createNode(type) {
    const id = nanoid();

    switch(type) {
      case 'osc': {
        const data = { frequency: 440, type: 'sine' };
        const position = { x: 0, y: 0 };

        createAudioNode(id, type, data);
        set({ nodes: [...get().nodes, { id, type, data, position }] });

        break;
      }

      case 'amp': {
        const data = { gain: 0.5 };
        const position = { x: 0, y: 0 };

        createAudioNode(id, type, data);
        set({ nodes: [...get().nodes, { id, type, data, position }] });

        break;
      }
    }
  }
}));
```

We could be a bit smarter about calculating the position of the new node, but
to keep things simple we'll just hardcode it to `{ x: 0, y: 0 }` for now.

The final piece of the puzzle is to create a toolbar component that can trigger
the new `createNode` action. To do that we'll jump back to `App.jsx` and make use
of the [`<Panel />`](/docs//api-reference/components/panel/)
built-in component.

```jsx filename="./src/App.jsx"
...
import { ReactFlow,  Panel } from '@xyflow/react';
...

const selector = (store) => ({
  ...,
  createNode: store.createNode,
});

export default function App() {
  const store = useStore(selector, shallow);

  return (
    <ReactFlow>
      <Panel position="top-right">
        ...
      </Panel>
      <Background />
    </ReactFlow>
  );
};
```

We don't need anything fancy here, just a couple of buttons that trigger the
`createNode` action with the appropriate type:

```jsx filename="./src/App.jsx"
<Panel position="top-right">
  <button onClick={() => store.createNode('osc')}>osc</button>
  <button onClick={() => store.createNode('amp')}>amp</button>
</Panel>
```

And that's... everything! We've now got a fully functional audio graph editor
that can:

* Create new audio nodes
* Update node data with some UI controls
* Connect nodes together
* Delete nodes and connections
* Start and stop audio processing

Here's the demo from the beginning, but this time you can see the source code to
make sure you haven't missed anything.

<RemoteCodeViewer route="tutorials/webaudio/demo" framework="react" />

#### Final thoughts

Whew that was a long one, but we made it! For our efforts we've come out the other
side with a fun little interactive audio playground, learned a little bit about
the Web Audio API along the way, and have a better idea of one approach to "running"
a React Flow graph.

If you've made it this far and are thinking "Hayleigh, I'm never going to write
a Web Audio app. Did I learn *anything* useful?" Then you're in luck, because you
did! You could take our approach to connecting to the Web Audio API and apply it
to some other graph-based computation engine like [behave-graph](https://github.com/bhouston/behave-graph).
In fact, some has done just that and created [behave-flow](https://github.com/beeglebug/behave-flow)!

There are still plenty of ways to expand on this project. If you'd like to keep
working on it, here are some ideas:

* Add more node types.
* Allow nodes to connect to `AudioParams` on other nodes.
* Use the [`AnalyserNode`](https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode)
  to visualize the output of a node or signal.
* Anything else you can think of!

And if you're looking for inspiration, there are quite a few projects out in the
wild that are using node-based UIs for audio things. Some of my favorites are
[Max/MSP](https://cycling74.com/products/max/),
[Reaktor](https://www.native-instruments.com/en/products/komplete/synths/reaktor-6/),
and [Pure Data](https://puredata.info/). Max and Reaktor are closed-source commercial
software, but you can still steal some ideas from them <Emoji content="🕵️" />.

You can use the completed [source code](https://github.com/xyflow/react-flow-web-audio)
as a starting point, or you can just keep building on top of what we've made today.
We'd love to see what you build so please share it with us over on our
[Discord server](https://discord.com/invite/RVmnytFmGW)
or [Twitter](https://twitter.com/xyflowdev).

React Flow is an independent company financed by its users. If you want to support
us you can [sponsor us on Github](https://github.com/sponsors/xyflow) or
[subscribe to one of our Pro plans](/pro/).

### Create a slide show presentation with React Flow

import { Emoji } from '@xyflow/xy-ui';
import { Callout, Cards } from 'nextra/components';
import { Image } from 'xy-shared';
import { RemoteCodeViewer } from 'xy-shared/server';

We recently published the findings from our React Flow 2023 end-of-year survey with an
[interactive presentation](/developer-survey-2023) of the key findings, using React Flow
itself. There were lots of useful bits built into this slideshow app, so we wanted to
share how we built it!

<Image src="/img/tutorials/presentation/survey.png" caption="Our 2023 end of year survey app was made up of many static nodes and buttons to navigate between them." alt="Screenshot of slides laid out on an infinite canvas, each with information pulled from a survey of React Flow users" />

By the end of this tutorial, you will have built a presentation app with

* Support for markdown slides
* Keyboard navigation around the viewport
* Automatic layouting
* Click-drag panning navigation (à la Prezi)

Along the way, you'll learn a bit about the basics of layouting algorithms, creating
static flows, and custom nodes.

Once you're done, the app will look like this!

<RemoteCodeViewer route="tutorials/presentation/app" framework="react" />

To follow along with this tutorial we'll assume you have a basic understanding of
[React](https://reactjs.org/docs/getting-started.html) and
[React Flow](/learn/concepts/terms-and-definitions), but if you get stuck on the way feel
free to reach out to us on [Discord](https://discord.com/invite/RVmnytFmGW)!

Here's the [repo with the final code](https://github.com/xyflow/react-flow-slide-show) if
you'd like to skip ahead or refer to it as we go.

Let's get started!

#### Setting up the project

We like to recommend using [Vite](https://vitejs.dev) when starting new React Flow
projects, and this time we'll use TypeScript too. You can scaffold a new project with the
following command:

```bash npm2yarn
npm create vite@latest -- --template react-ts
```

If you'd prefer to follow along with JavaScript feel free to use the `react` template
instead. You can also follow along in your browser by using our Codesandbox templates:

<Cards num={2}>
  <Cards.Card
    title="new.reactflow.dev/js"
    href="https://new.reactflow.dev/js"
    icon={
    <div className="rounded-full w-10 h-10 bg-yellow-200 text-gray-700 font-black flex items-center justify-center">
      JS
    </div>
  }
  />

  <Cards.Card
    title="new.reactflow.dev/ts"
    href="https://new.reactflow.dev/ts"
    icon={
    <div className="rounded-full w-10 h-10 bg-blue-500 text-white font-black flex items-center justify-center">
      TS
    </div>
  }
  />
</Cards>

Besides React Flow we only need to pull in one dependency,
[`react-remark`](https://www.npmjs.com/package/react-remark), to help us render markdown
in our slides.

```bash npm2yarn
npm install @xyflow/react react-remark
```

We'll modify the generated `main.tsx` to include React Flow's styles, as well as wrap the
app in a `<ReactFlowProvider />` to make sure we can access the React Flow instance inside
our components;

```tsx filename="main.tsx" {3,7,12,20}
import React from 'react';
import ReactDOM from 'react-dom/client';
import { ReactFlowProvider } from '@xyflow/react';

import App from './App';

import '@xyflow/react/dist/style.css';
import './index.css';

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <ReactFlowProvider>
      {/* The parent element of the React Flow component needs a width and a height
          to work properly. If you're styling your app as you follow along, you
          can remove this div and apply styles to the #root element in your CSS.
       */}
      <div style={{ width: '100vw', height: '100vh' }}>
        <App />
      </div>
    </ReactFlowProvider>
  </React.StrictMode>,
);
```

This tutorial is going to gloss over the styling of the app, so feel free to use any CSS
framework or styling solution you're familiar with. If you're going to style your app
differently from just writing CSS, [Tailwind CSS](/examples/styling/tailwind), you can
skip the import to `index.css`.

<Callout>
  How you style your app is up to you, but you must **always** include React Flow's
  styles! If you don't need the default styles, at a minimum you should include the base
  styles from `@xyflow/react/dist/base.css`.
</Callout>

Each slide of our presentation will be a node on the canvas, so let's create a new file
`Slide.tsx` that will be our custom node used to render each slide.

```tsx filename="Slide.tsx"
import { type Node, type NodeProps } from '@xyflow/react';

export const SLIDE_WIDTH = 1920;
export const SLIDE_HEIGHT = 1080;

export type SlideNode = Node<SlideData, 'slide'>;

export type SlideData = {};

const style = {
  width: `${SLIDE_WIDTH}px`,
  height: `${SLIDE_HEIGHT}px`,
} satisfies React.CSSProperties;

export function Slide({ data }: NodeProps<SlideNode>) {
  return (
    <article className="slide nodrag" style={style}>
      <div>Hello, React Flow!</div>
    </article>
  );
}
```

We're setting the slide width and height as constants here (rather than styling the node
in CSS) because we'll want access to those dimensions later on. We've also stubbed out the
`SlideData` type so we can properly type the component's props.

The last thing to do is to register our new custom node and show something on the screen.

```tsx filename="App.tsx"
import { ReactFlow } from '@xyflow/react';
import { Slide } from './Slide.tsx';

const nodeTypes = {
  slide: Slide,
};

export default function App() {
  const nodes = [{ id: '0', type: 'slide', position: { x: 0, y: 0 }, data: {} }];

  return <ReactFlow nodes={nodes} nodeTypes={nodeTypes} fitView />;
}
```

<Callout>
  It's important to remember to define your `nodeTypes` object *outside* of the component
  (or to use React's `useMemo` hook)! When the `nodeTypes` object changes, the entire flow
  is re-rendered.
</Callout>

With the basics put together, you can start the development server by running
`npm run dev` and see the following:

<RemoteCodeViewer route="tutorials/presentation/scaffold" framework="react" />

Not super exciting yet, but let's add markdown rendering and create a few slides side by
side!

#### Rendering markdown

We want to make it easy to add content to our slides, so we'd like the ability to write
[Markdown](https://www.markdownguide.org/basic-syntax/) in our slides. If you're not
familiar, Markdown is a simple markup language for creating formatted text documents. If
you've ever written a README on GitHub, you've used Markdown!

Thanks to the `react-remark` package we installed earlier, this step is a simple one. We
can use the `<Remark />` component to render a string of markdown content into our slides.

```tsx filename="Slide.tsx" {2,9-11,21}
import { type Node, type NodeProps } from '@xyflow/react';
import { Remark } from 'react-remark';

export const SLIDE_WIDTH = 1920;
export const SLIDE_HEIGHT = 1080;

export type SlideNode = Node<SlideData, 'slide'>;

export type SlideData = {
  source: string;
};

const style = {
  width: `${SLIDE_WIDTH}px`,
  height: `${SLIDE_HEIGHT}px`,
} satisfies React.CSSProperties;

export function Slide({ data }: NodeProps<SlideNode>) {
  return (
    <article className="slide nodrag" style={style}>
      <Remark>{data.source}</Remark>
    </article>
  );
}
```

In React Flow, nodes can have data stored on them that can be used during rendering. In
this case we're storing the markdown content to display by adding a `source` property to
the `SlideData` type and passing that to the `<Remark />` component. We can update our
hardcoded nodes with some markdown content to see it in action:

```tsx filename="App.tsx" {2, 10-27, 34}
import { ReactFlow } from '@xyflow/react';
import { Slide, SLIDE_WIDTH } from './Slide';

const nodeTypes = {
  slide: Slide,
};

export default function App() {
  const nodes = [
    {
      id: '0',
      type: 'slide',
      position: { x: 0, y: 0 },
      data: { source: '# Hello, React Flow!' },
    },
    {
      id: '1',
      type: 'slide',
      position: { x: SLIDE_WIDTH, y: 0 },
      data: { source: '...' },
    },
    {
      id: '2',
      type: 'slide',
      position: { x: SLIDE_WIDTH * 2, y: 0 },
      data: { source: '...' },
    },
  ];

  return <ReactFlow nodes={nodes} nodeTypes={nodeTypes} fitView minZoom={0.1} />;
}
```

Note that we've added the `minZoom` prop to the `<ReactFlow />` component. Our slides are
quite large, and the default minimum zoom level is not enough to zoom out and see multiple
slides at once.

<RemoteCodeViewer route="tutorials/presentation/rendering-markdown" framework="react" />

In the nodes array above, we've made sure to space the slides out by doing some manual
math with the `SLIDE_WIDTH` constant. In the next section we'll come up with an algorithm
to automatically lay out the slides in a grid.

#### Laying out the nodes

We often get asked how to automatically lay out nodes in a flow, and we have some
documentation on how to use common layouting libraries like dagre and d3-hierarchy in our
[layouting guide](/learn/layouting/layouting). Here you'll be writing your own
super-simple layouting algorithm, which gets a bit nerdy, but stick with us!

For our presentation app we'll construct a simple grid layout by starting from 0,0 and
updating the x or y coordinates any time we have a new slide to the left, right, up, or
down.

First, we need to update our `SlideData` type to include optional ids for the slides to
the left, right, up, and down of the current slide.

```tsx filename="Slide.tsx" {3-6}
export type SlideData = {
  source: string;
  left?: string;
  up?: string;
  down?: string;
  right?: string;
};
```

Storing this information on the node data directly gives us some useful benefits:

* We can write fully declarative slides without worrying about the concept of nodes and
  edges

* We can compute the layout of the presentation by visiting connecting slides

* We can add navigation buttons to each slide to navigate between them automatically.
  We'll handle that in a later step.

The magic happens in a function we're going to define called `slidesToElements`. This
function will take an object containing all our slides addressed by their id, and an id
for the slide to start at. Then it will work through each connecting slide to build an
array of nodes and edges that we can pass to the `<ReactFlow />` component.

The algorithm will go something like this:

* Push the initial slide's id and the position `{ x: 0, y: 0 }` onto a stack.
* While that stack is not empty...
  * Pop the current position and slide id off the stack.

  * Look up the slide data by id.

  * Push a new node onto the nodes array with the current id, position, and slide data.

  * Add the slide's id to a set of visited slides.

  * For every direction (left, right, up, down)...
    * Make sure the slide has not already been visited.

    * Take the current position and update the x or y coordinate by adding or subtracting
      `SLIDE_WIDTH` or `SLIDE_HEIGHT` depending on the direction.

    * Push the new position and the new slide's id onto a stack.

    * Push a new edge onto the edges array connecting the current slide to the new slide.

    * Repeat for the remaining directions...

If all goes to plan, we should be able to take a stack of slides shown below and turn them
into a neatly laid out grid!

<Image src="/img/tutorials/presentation/ideal-layout.png" wide />

Let's see the code. In a file called `slides.ts` add the following:

```tsx filename="slides.ts"
import { SlideData, SLIDE_WIDTH, SLIDE_HEIGHT } from './Slide';

export const slidesToElements = (initial: string, slides: Record<string, SlideData>) => {
  // Push the initial slide's id and the position `{ x: 0, y: 0 }` onto a stack.
  const stack = [{ id: initial, position: { x: 0, y: 0 } }];
  const visited = new Set();
  const nodes = [];
  const edges = [];

  // While that stack is not empty...
  while (stack.length) {
    // Pop the current position and slide id off the stack.
    const { id, position } = stack.pop();
    // Look up the slide data by id.
    const data = slides[id];
    const node = { id, type: 'slide', position, data };

    // Push a new node onto the nodes array with the current id, position, and slide
    // data.
    nodes.push(node);
    // add the slide's id to a set of visited slides.
    visited.add(id);

    // For every direction (left, right, up, down)...
    // Make sure the slide has not already been visited.
    if (data.left && !visited.has(data.left)) {
      // Take the current position and update the x or y coordinate by adding or
      // subtracting `SLIDE_WIDTH` or `SLIDE_HEIGHT` depending on the direction.
      const nextPosition = {
        x: position.x - SLIDE_WIDTH,
        y: position.y,
      };

      // Push the new position and the new slide's id onto a stack.
      stack.push({ id: data.left, position: nextPosition });
      // Push a new edge onto the edges array connecting the current slide to the
      // new slide.
      edges.push({ id: `${id}->${data.left}`, source: id, target: data.left });
    }

    // Repeat for the remaining directions...
  }

  return { nodes, edges };
};
```

We've left out the code for the right, up, and down directions for brevity, but the logic
is the same for each direction. We've also included the same breakdown of the algorithm as
comments, to help you navigate the code.

Below is a demo app of the layouting algorithm, you can edit the `slides` object to see
how adding slides to different directions affects the layout. For example, try extending
4's data to include `down: '5'` and see how the layout updates.

<RemoteCodeViewer route="tutorials/presentation/layout-demo" framework="react" />

If you spend a little time playing with this demo, you'll likely run across two
limitations of this algorithm:

1. It is possible to construct a layout that overlaps two slides in the same position.

2. The algorithm will ignore nodes that cannot be reached from the initial slide.

Addressing these shortcomings is totally possible, but a bit beyond the scope of this
tutorial. If you give a shot, be sure to share your solution with us on the
[discord server](https://discord.com/invite/RVmnytFmGW)!

With our layouting algorithm written, we can hop back to `App.tsx` and remove the
hardcoded nodes array in favor of the new `slidesToElements` function.

```tsx filename="App.tsx" {2,3,5-9,15-16,24}
import { ReactFlow } from '@xyflow/react';
import { slidesToElements } from './slides';
import { Slide, SlideData, SLIDE_WIDTH } from './Slide';

const slides: Record<string, SlideData> = {
  '0': { source: '# Hello, React Flow!', right: '1' },
  '1': { source: '...', left: '0', right: '2' },
  '2': { source: '...', left: '1' },
};

const nodeTypes = {
  slide: Slide,
};

const initialSlide = '0';
const { nodes, edges } = slidesToElements(initialSlide, slides);

export default function App() {
  return (
    <ReactFlow
      nodes={nodes}
      nodeTypes={nodeTypes}
      fitView
      fitViewOptions={{ nodes: [{ id: initialSlide }] }}
      minZoom={0.1}
    />
  );
}
```

The slides in our flow are static, so we can move the `slidesToElements` call *outside*
the component to make sure we're not recalculating the layout if the component re-renders.
Alternatively, you could use React's `useMemo` hook to define things inside the component
but only calculate them once.

Because we have the idea of an "initial" slide now, we're also using the `fitViewOptions`
to ensure the initial slide is the one that is focused when the canvas is first loaded.

#### Navigating between slides

So far we have our presentation laid out in a grid but we have to manually pan the canvas
to see each slide, which isn't very practical for a presentation! We're going to add three
different ways to navigate between slides:

* Click-to-focus on nodes for jumping to different slides by clicking on them.

* Navigation buttons on each slide for moving sequentially between slides in any valid
  direction.

* Keyboard navigation using the arrow keys for moving around the presentation without
  using the mouse or interacting with a slide directly.

##### Focus on click

The `<ReactFlow />` element can receive an
[`onNodeClick`](/api-reference/react-flow#on-node-click) callback that fires when *any*
node is clicked. Along with the mouse event itself, we also receive a reference to the
node that was clicked on, and we can use that to pan the canvas thanks to the `fitView`
method.

[`fitView`](/api-reference/types/react-flow-instance#fit-view) is a method on the React
Flow instance, and we can get access to it by using the
[`useReactFlow`](/api-reference/types/react-flow-instance#use-react-flow) hook.

```tsx filename="App.tsx" {1-2,17-23,29}
import { useCallback } from 'react';
import { ReactFlow, useReactFlow, type NodeMouseHandler } from '@xyflow/react';
import { Slide, SlideData, SLIDE_WIDTH } from './Slide';

const slides: Record<string, SlideData> = {
  ...
}

const nodeTypes = {
  slide: Slide,
};

const initialSlide = '0';
const { nodes, edges } = slidesToElements(initialSlide, slides);

export default function App() {
  const { fitView } = useReactFlow();
  const handleNodeClick = useCallback<NodeMouseHandler>(
    (_, node) => {
      fitView({ nodes: [node], duration: 150 });
    },
    [fitView],
  );

  return (
    <ReactFlow
      ...
      fitViewOptions={{ nodes: [{ id: initialSlide }] }}
      onNodeClick={handleNodeClick}
    />
  );
}
```

<Callout>
  It's important to remember to include `fitView` as in the dependency array of our
  `handleNodeClick` callback. That's because the `fitView` function is replaced once React
  Flow has initialized the viewport. If you forget this step you'll likely find out that
  `handleNodeClick` does nothing at all (and yes, we also forget this ourselves sometimes
  too <Emoji content="🫠" />
  ).
</Callout>

Calling `fitView` with no arguments would attempt to fit every node in the graph into
view, but we only want to focus on the node that was clicked! The
[`FitViewOptions`](/api-reference/types/fit-view-options) object lets us provide an array
of just the nodes we want to focus on: in this case, that's just the node that was
clicked.

<RemoteCodeViewer route="tutorials/presentation/focus-on-click" framework="react" />

##### Slide controls

Clicking to focus a node is handy for zooming out to see the big picture before focusing
back in on a specific slide, but it's not a very practical way for navigating around a
presentation. In this step we'll add some controls to each slide that allow us to move to
a connected slide in any direction.

Let's add a `<footer>` to each slide that conditionally renders a button in any direction
with a connected slide. We'll also preemptively create a `moveToNextSlide` callback that
we'll use in a moment.

```tsx filename="Slide.tsx" {3,8,13-18}
import { type NodeProps, fitView } from '@xyflow/react';
import { Remark } from 'react-remark';
import { useCallback } from 'react';

...

export function Slide({ data }: NodeProps<SlideNide>) {
  const moveToNextSlide = useCallback((id: string) => {}, []);

  return (
    <article className="slide nodrag" style={style}>
      <Remark>{data.source}</Remark>
      <footer className="slide__controls nopan">
        {data.left && (<button onClick={() => moveToNextSlide(data.left)}>←</button>)}
        {data.up && (<button onClick={() => moveToNextSlide(data.up)}>↑</button>)}
        {data.down && (<button onClick={() => moveToNextSlide(data.down)}>↓</button>)}
        {data.right && (<button onClick={() => moveToNextSlide(data.right)}>→</button>)}
      </footer>
    </article>
  );
}
```

You can style the footer however you like, but it's important to add the `"nopan"` class
to prevent prevent the canvas from panning as you interact with any of the buttons.

To implement `moveToSlide`, we'll make use of `fitView` again. Previously we had a
reference to the actual node that was clicked on to pass to `fitView`, but this time we
only have a node's id. You might be tempted to look up the target node by its id, but
actually that's not necessary! If we look at the type of
[`FitViewOptions`](/api-reference/types/fit-view-options) we can see that the array of
nodes we pass in only *needs* to have an `id` property:

```ts filename="https://reactflow.dev/api-reference/types/fit-view-options" {7}
export type FitViewOptions = {
  padding?: number;
  includeHiddenNodes?: boolean;
  minZoom?: number;
  maxZoom?: number;
  duration?: number;
  nodes?: (Partial<Node> & { id: Node['id'] })[];
};
```

`Partial<Node>` means that all of the fields of the `Node` object type get marked as
optional, and then we intersect that with `{ id: Node['id'] }` to ensure that the `id`
field is always required. This means we can just pass in an object with an `id` property
and nothing else, and `fitView` will know what to do with it!

```tsx filename="Slide.tsx" {1,4,6-9}
import { type NodeProps, useReactFlow } from '@xyflow/react';

export function Slide({ data }: NodeProps<SlideNide>) {
  const { fitView } = useReactFlow();

  const moveToNextSlide = useCallback(
    (id: string) => fitView({ nodes: [{ id }] }),
    [fitView],
  );

  return (
    <article className="slide" style={style}>
      ...
    </article>
  );
}
```

<RemoteCodeViewer route="tutorials/presentation/slide-controls" framework="react" />

##### Keyboard navigation

The final piece of the puzzle is to add keyboard navigation to our presentation. It's not
very convenient to have to *always* click on a slide to move to the next one, so we'll add
some keyboard shortcuts to make it easier. React Flow lets us listen to keyboard events on
the `<ReactFlow />` component through handlers like
[`onKeyDown`](/api-reference/react-flow#on-key-down).

Up until now the slide currently focused is implied by the position of the canvas, but if
we want to handle key presses on the entire canvas we need to *explicitly* track the
current slide. We need to this because we need to know which slide to navigate to when an
arrow key is pressed!

```tsx filename="App.tsx" {1,2,13-14,17,23}
import { useState, useCallback } from 'react';
import { ReactFlow, useReactFlow } from '@xyflow/react';
import { Slide, SlideData, SLIDE_WIDTH } from './Slide';

const slides: Record<string, SlideData> = {
  ...
}

const nodeTypes = {
  slide: Slide,
};

const initialSlide = '0';
const { nodes, edges } = slidesToElements(initialSlide, slides)

export default function App() {
  const [currentSlide, setCurrentSlide] = useState(initialSlide);
  const { fitView } = useReactFlow();

  const handleNodeClick = useCallback<NodeMouseHandler>(
    (_, node) => {
      fitView({ nodes: [node] });
      setCurrentSlide(node.id);
    },
    [fitView],
  );

  return (
    <ReactFlow
      ...
      onNodeClick={handleNodeClick}
    />
  );
}
```

Here we've added a bit of state, `currentSlide`, to our flow component and we're making
sure to update it whenever a node is clicked. Next, we'll write a callback to handle
keyboard events on the canvas:

```tsx filename="App.tsx"
export default function App() {
  const [currentSlide, setCurrentSlide] = useState(initialSlide);
  const { fitView } = useReactFlow();

  ...

  const handleKeyPress = useCallback<KeyboardEventHandler>(
    (event) => {
      const slide = slides[currentSlide];

      switch (event.key) {
        case 'ArrowLeft':
        case 'ArrowUp':
        case 'ArrowDown':
        case 'ArrowRight':
          const direction = event.key.slice(5).toLowerCase();
          const target = slide[direction];

          if (target) {
            event.preventDefault();
            setCurrentSlide(target);
            fitView({ nodes: [{ id: target }] });
          }
      }
    },
    [currentSlide, fitView],
  );

  return (
    <ReactFlow
      ...
      onKeyPress={handleKeyPress}
    />
  );
}
```

To save some typing we're extracting the direction from the key pressed - if the user
pressed `'ArrowLeft'` we'll get `'left'` and so on. Then, if there is actually a slide
connected in that direction we'll update the current slide and call `fitView` to navigate
to it!

We're also preventing the default behavior of the arrow keys to prevent the window from
scrolling up and down. This is necessary for this tutorial because the canvas is only one
part of the page, but for an app where the canvas is the entire viewport you might not
need to do this.

And that's everything! To recap let's look at the final result and talk about what we've
learned.

<RemoteCodeViewer route="tutorials/presentation/app" framework="react" />

#### Final thoughts

Even if you're not planning on making the next [Prezi](https://prezi.com), we've still
looked at a few useful features of React Flow in this tutorial:

* The [`useReactFlow`](/api-reference/hooks/use-react-flow) hook to access the `fitView`
  method.

* The [`onNodeClick`](/api-reference/react-flow#on-node-click) event handler to listen to
  clicks on every node in a flow.

* The [`onKeyPress`](/api-reference/react-flow#on-key-press) event handler to listen to
  keyboard events on the entire canvas.

We've also looked at how to implement a simple layouting algorithm ourselves. Layouting is
a *really* common question we get asked about, but if your needs aren't that complex you
can get quite far rolling your own solution!

If you're looking for ideas on how to extend this project, you could try addressing the
issues we pointed out with the layouting algorithm, coming up with a more sophisticated
`Slide` component with different layouts, or something else entirely.

You can use the completed [source code](https://github.com/xyflow/react-flow-slide-show)
as a starting point, or you can just keep building on top of what we've made today. We'd
love to see what you build so please share it with us over on our
[Discord server](https://discord.com/invite/RVmnytFmGW) or
[Twitter](https://twitter.com/reactflowdev).

## UI

### React Flow UI

Ready-to-use React Flow components built with [shadcn/ui](https://ui.shadcn.com/)
components and [Tailwind CSS](https://tailwindcss.com/). Useful for new projects, MVPs, or
when you need to get up and running quickly.

#### Prerequisites

You need to have **shadcn and tailwind configured in your project**. If you haven't
installed it, you can follow the steps explained in the
[shadcn installation guide](https://ui.shadcn.com/docs/installation). If shadcn and
tailwind are part of your project, you can initialize shadcn-ui by running:

```bash copy npm2yarn
npx shadcn@latest init
```

If you want to learn more about the motivation behind this project, you can find a
detailed blog post [here](https://xyflow.com/blog/react-flow-components). For a more
in-depth tutorial, we also recently published a new guide on
[getting started with React Flow UI](/learn/tutorials/getting-started-with-react-flow-components).

#### Usage

Find a component you like and run the command to add it to your project.

```bash copy npm2yarn
npx shadcn@latest add https://ui.reactflow.dev/component-name
```

* This command copies the component code inside your components folder. You can change
  this folder by adding an alias inside your `components.json`.

* It automatically installs all necessary dependencies

* It utilizes previously added and even modified components or asks you if you'd like to
  overwrite them.

* It uses your existing tailwind configuration.

* The components are **not black-boxes** and can be **modified and extended** to fit your
  needs.

For more information visit the [shadcn documentation](https://ui.shadcn.com/docs).

import { Callout } from 'nextra/components';
import UiComponentViewer from '@/components/ui-component-viewer.mdx';

### Animated SVG Edge

An edge that animates a custom SVG element along the edge's path. This component
is based on the [animating SVG elements example](/examples/edges/animating-edges).

<UiComponentViewer id="animated-svg-edge" />

#### Custom shapes

It is intended that you add your own SVG shapes to the module. Each shape should
be a React component that takes one prop, `animateMotionProps`, and returns some
SVG.

You can define these shapes in a separate file or in the same file as the edge
component. In order to use them, you need to add them to the `shapes` record like
so:

```tsx
const shapes = {
  box: ({ animateMotionProps }) => (
    <rect width="5" height="5" fill="#ff0073">
      <animateMotion {...animateMotionProps} />
    </rect>
  ),
} satisfies Record<string, AnimatedSvg>;
```

The keys of the `shapes` record are valid values for the `shape` field of the
edge's data:

```ts
const initialEdges = [
  {
    // ...
    type: "animatedSvgEdge",
    data: {
      duration: 2,
      shape: "box",
    },
  } satisfies AnimatedSvgEdge,
];
```

<Callout type="info">
  If you want to render regular HTML elements, be sure to wrap them in an SVG
  `<foreignObject />` element. Make sure to give the `<foreignObject />` an `id`
  attribute and use that as the `href` attribute when rendering the  `<animateMotion />`
  element.
</Callout>

import UiComponentViewer from '@/components/ui-component-viewer.mdx';

### Base Handle

A handle with some basic styling used for creating a shared design among all handles in your application.

<UiComponentViewer id="base-handle" />

import UiComponentViewer from '@/components/ui-component-viewer.mdx';

### Base Node

A node wrapper with some basic styling used for creating a shared design among all nodes in your application.
Similarly to [shadcn ui's card](https://ui.shadcn.com/docs/components/card) the components file exports:

* The `BaseNode` main container,
* The `BaseNodeHeader` container where you would usually add actions and a `BaseNodeHeaderTitle`
* The `BaseNodeContent` container where you would add the main contents of the node.
* The `BaseNodeFooter` container where you may want to add extra information, or visible actions.

In case you need to fine-tune how interactions like dragging and scrolling work with your custom components,
React Flow provides [several CSS utility classes](/learn/customization/utility-classes)

You should use the `nodrag` [React Flow utility class](/learn/customization/utility-classes)
in interactive components of your node such as buttons, to disable dragging
the node inside the flow when the user is interacting with buttons or sliders.

<UiComponentViewer id="base-node" />

#### Theming

To customize the visual appearance of your custom nodes, you can simply use
[Tailwind CSS](https://tailwindcss.com/) classes. All of the React Flow
components are based on [shadcn UI](https://ui.shadcn.com/), and you should follow
the [shadcn UI theming guide](https://ui.shadcn.com/docs/theming) to customize aspects like typography and colors
in your application.

In most occasions though, when developing custom nodes, you may simply need to
add custom Tailwind CSS classes. All of the `BaseNode` components are just light wrappers around `<div>`.

For example, to change the border color of a node, based on an hypothetical execution status,
you can pass extra `className`s:

```tsx
// Assuming your component is receiving a `data` prop
export const BaseNodeSimpleDemo = memo(({ data }: NodeProps) => {
  return (
    <BaseNode
      className={cn('w-[350px] p-0 hover:ring-orange-500', {
        'border-orange-500': data.status === 'loading',
        'border-red-500': data.status === 'error',
      })}
    >
      {/* Your custom node definiton goes here */}
    </BaseNode>
  );
});
```

import UiComponentViewer from '@/components/ui-component-viewer.mdx';

### Button Edge

An edge with a button that can be used to trigger a custom action.

<UiComponentViewer id="button-edge" />

import UiComponentViewer from '@/components/ui-component-viewer.mdx';

### Button Handle

A handle component with a button attached.

<UiComponentViewer id="button-handle" />

import UiComponentViewer from '@/components/ui-component-viewer.mdx';

### Data Edge

An edge that displays one field from the source node's `data` object.

<UiComponentViewer id="data-edge" />

#### Additional type safety

When creating new edges of this type, you can use TypeScript's `satisfies` predicate
along with the specific type of a node in your application to ensure the `key`
property of the edge's data is a valid key of the node's data.

```ts
type CounterNode = Node<{ count: number }>;

const initialEdges = [
  {
    id: 'edge-1',
    source: 'node-1',
    target: 'node-2',
    type: 'dataEdge',
    data: {
      key: 'count',
    } satisfies DataEdge<CounterNode>,
  },
];
```

If you try to use a key that is not present in the node's data, TypeScript will
show an error message like:

> ts: Type '"value"' is not assignable to type '"count"'.

import UiComponentViewer from '@/components/ui-component-viewer.mdx';

### Database Schema Node

A node that can be used to visualize a database schema.

<UiComponentViewer id="database-schema-node" />

### DevTools

import UiComponentViewer from '@/components/ui-component-viewer.mdx';

### DevTools

A debugging tool that provides data on the viewport, the state of each node, and logs change events. This component
is based on [DevTools and Debugging](/learn/advanced-use/devtools-and-debugging) under Advanced Use.

You can import the entire `<DevTools />` component, or optionally, import individual components for greater flexibility. These components include:

* A `<ViewportLogger />` component that shows the current position and zoom level of the viewport.
* A `<NodeInspector />` component that reveals the state of each node.
* A `<ChangeLogger />` that wraps your flow’s onNodesChange handler and logs each change as it is dispatched.

You can read more about the individual components at [DevTools and Debugging](/learn/advanced-use/devtools-and-debugging). While we find these tools useful for making sure React Flow is working properly, you might also find them useful for debugging your applications as your flows and their interactions become more complex.

<UiComponentViewer id="devtools" />

import UiComponentViewer from '@/components/ui-component-viewer.mdx';

### Labeled Group Node

A group node with an optional label.

<UiComponentViewer id="labeled-group-node" />

import UiComponentViewer from '@/components/ui-component-viewer.mdx';

### Labeled Handle

A handle with a label that can be used to display additional information.

<UiComponentViewer id="labeled-handle" />

import UiComponentViewer from '@/components/ui-component-viewer.mdx';

### Node Appendix

A wrapper component for dynamically appending information to nodes in an absolutely positioned container.

<UiComponentViewer id="node-appendix" />

import UiComponentViewer from '@/components/ui-component-viewer.mdx';

### Node Status Indicator

A node wrapper that has multiple states for indicating the status of a node. Status can be one of the following: `"success"`, `"loading"`, `"error"` and `"initial"`.

Additionally, the `NodeStatusIndicator` component supports different loading variants: `"border"` and `"overlay"`, which can be set using the `loadingVariant` prop.

* The `"border"` variant is the default and shows a spinning border around the node when it is in loading state.
* The `"overlay"` variant shows a full overlay, with an animated spinner on the node when it is in loading state.

<UiComponentViewer id="node-status-indicator" />

import UiComponentViewer from '@/components/ui-component-viewer.mdx';

### Node Tooltip

A wrapper for node components that displays a tooltip when hovered.
Built on top of the [NodeToolbar](/api-reference/components/node-toolbar) component that comes with React Flow.

<UiComponentViewer id="node-tooltip" />

import UiComponentViewer from '@/components/ui-component-viewer.mdx';

### Placeholder Node

A custom node that can be clicked to create a new node.

<UiComponentViewer id="placeholder-node" />

import UiComponentViewer from '@/components/ui-component-viewer.mdx';

### Zoom Select

A zoom control that lets you zoom in and out seamlessly using a select dropdown.

<UiComponentViewer id="zoom-select" />

import UiComponentViewer from '@/components/ui-component-viewer.mdx';

### Zoom Slider

A zoom control that lets you zoom in and out seamlessly using a slider.

<UiComponentViewer id="zoom-slider" />

### Workflow Editor

import ProExampleViewer from '@/components/pro-example-viewer';

### Workflow Editor

The Workflow Editor template is a Next.js-based application designed to help you quickly
create, manage, and visualize workflows. Built with [React Flow UI](/ui) and styled using
[Tailwind CSS](https://tailwindcss.com/) and [shadcn/ui](https://ui.shadcn.com/), this
project provides a highly customizable foundation for building and extending workflow
editors.

<ProExampleViewer slug="workflow-editor" type="template" />

#### Tech Stack

* **React Flow UI**: The project uses [React Flow UI](/ui) to build nodes. These
  components are designed to help you quickly get up to speed on projects.

* **shadcn CLI**: The project uses the [shadcn CLI](https://ui.shadcn.com/docs/cli) to
  manage UI components. This tool builds on top of
  [Tailwind CSS](https://tailwindcss.com/) and [shadcn/ui](https://ui.shadcn.com/)
  components, making it easy to add and customize UI elements.

* **State Management with Zustand**: The application uses Zustand for state management,
  providing a simple and efficient way to manage the state of nodes, edges, and other
  workflow-related data.

#### Features

* **Automatic Layouting**: Utilizes the [ELKjs](https://github.com/kieler/elkjs) layout
  engine to automatically arrange nodes and edges.
* **Drag-and-Drop Sidebar**: Add and arrange nodes using a drag-and-drop mechanism.
* **Customizable Components**: Uses React Flow UI and the shadcn library to create
  highly-customizable nodes and edges.
* **Dark Mode**: Toggles between light and dark themes, managed through the Zustand store.
* **Runner Functionality**: Executes and monitors nodes sequentially with a workflow
  runner.

