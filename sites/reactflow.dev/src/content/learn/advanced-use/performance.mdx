---
description: Strategies to optimize React Flow performance for large graphs.
---

# Performance

When dealing with a large number of nodes or complex components, managing performance can be challenging. Here are a few effective strategies to optimize the performance of React Flow.

## Use Memoization

One of the main reasons for performance issues in React Flow is unnecessary re-renders. Since node movements trigger frequent state updates, this can lead to performance bottlenecks, especially in larger diagrams. To mitigate this, it’s crucial to properly memoize objects and functions passed as props to the `<ReactFlow>` component.

### Memoizing Objects

Objects provided as props to the `<ReactFlow>` component should either be memoized using `useMemo` or declared outside the component. This ensures that React does not create a new reference for the object on every render, which would otherwise trigger unnecessary re-renders.

```tsx
import React, { useMemo } from 'react';

const MyDiagram = () => {
  const nodes = useMemo(
    () => [
      { id: '1', data: { label: 'Node 1' }, position: { x: 0, y: 0 } },
      { id: '2', data: { label: 'Node 2' }, position: { x: 100, y: 100 } },
    ],
    [],
  );

  return <ReactFlow nodes={nodes} />;
};

export default MyDiagram;
```

In this example, the `nodes` array is memoized using `useMemo`, ensuring that its reference remains stable unless its dependencies change.

### Memoizing Functions

Similarly, functions passed as props to `<ReactFlow>` should be memoized using `useCallback`. This prevents React from creating a new function reference on every render, which could also trigger unnecessary re-renders.

```tsx
import React, { useCallback } from 'react';

const MyDiagram = () => {
  const onNodeClick = useCallback((event, node) => {
    console.log('Node clicked:', node);
  }, []);

  return <ReactFlow onNodeClick={onNodeClick} />;
};

export default MyDiagram;
```

Here, the `onNodeClick` function is wrapped in `useCallback`, ensuring that its reference remains stable across renders.

## Render Only Visible Nodes

Rendering a large number of nodes in React Flow can lead to severe performance degradation. By default, React Flow renders all nodes, even if they are offscreen. You can use the `onlyRenderVisibleElements` prop to to allow only visible elements to be rendered.

```tsx
<ReactFlow onlyRenderVisibleElements={true} />
```

This ensures that only the nodes in the viewport are rendered, dramatically improving performance when working with large node graphs.

## Enable Snap To Grid

By default, moving a node triggers a high number of state updates, leading to sluggish interactions. React Flow offers two props `snapToGrid`and `snapGrid`. By enabling snapping, we ensure that state updates occur only when a node moves by a fixed number of pixels.

```tsx
<ReactFlow snapToGrid={true} snapGrid={[50, 50]} />
```

This limits state updates, making interactions smoother, especially with large graphs.

## Collapse Large Node Trees

If your node tree is deeply nested, rendering all nodes at once can be inefficient. Instead, show only a limited number of nodes and allow users to expand them as needed. You can do this by modifying the node’s `hidden` property dynamically to toggle visibility.

```tsx
const handleNodeClick = (targetNode) => {
  if (targetNode.data.children) {
    setNodes((prevNodes) =>
      prevNodes.map((node) =>
        targetNode.data.children.includes(node.id)
          ? { ...node, hidden: !node.hidden }
          : node,
      ),
    );
  }
};
```

By hiding nodes initially and rendering them only when expanded, we optimize performance while maintaining usability.

## Reducing Uncontrolled Dependencies

One of the most common performance pitfalls in React Flow applications is uncontrolled dependencies on the `nodes` and `edges` arrays. These arrays are frequently updated during operations like dragging, which can cause unnecessary re-renders of components that depend on them.

For example, if you fetch the entire `nodes` array from the store and filter it to display selected node IDs, this approach can lead to performance degradation. Every update to the `nodes` array triggers a re-render of all dependent components, even if the change is unrelated to the selected nodes.

### Inefficient Example

```tsx
const SelectedNodeIds = () => {
  const nodes = useStore((state) => state.nodes);

  const selectedNodeIds = nodes.filter((node) => node.selected).map((node) => node.id);

  return (
    <div>
      {selectedNodeIds.map((id) => (
        <div key={id}>{id}</div>
      ))}
    </div>
  );
};
```

In this example, every update to the `nodes` array causes the `SelectedNodeIds` component to re-render, even if the selection hasn’t changed.

### Optimized Solution

To avoid unnecessary re-renders, store the selected nodes in a separate field in the state. This ensures that the component only re-renders when the selection changes.

```tsx
const SelectedNodeIds = () => {
  const selectedNodeIds = useStore((state) => state.selectedNodeIds);

  return (
    <div>
      {selectedNodeIds.map((id) => (
        <div key={id}>{id}</div>
      ))}
    </div>
  );
};
```

By decoupling the selected nodes from the `nodes` array, you prevent unnecessary updates and improve performance.

### Alternative Approach with Zustand

If you need to extract primitive values (like IDs) from the `nodes` array, you can use Zustand's shallow comparison to memoize the result. This ensures that the selector only updates when the values actually change.

```tsx
import { createWithEqualityFn } from 'zustand/traditional';

const useStore = createWithEqualityFn(
  (set) => ({
    nodes: [],
    selectedNodeIds: [],
  }),
  shallow,
);

const SelectedNodeIds = () => {
  const selectedNodeIds = useStore((state) => state.selectedNodeIds);

  return (
    <div>
      {selectedNodeIds.map((id) => (
        <div key={id}>{id}</div>
      ))}
    </div>
  );
};
```
