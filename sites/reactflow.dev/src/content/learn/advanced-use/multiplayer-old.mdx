---
description: Learn how to use React Flow with realtime multiplayer collaboration features.
---

# Realtime Multiplayer Collaboration Best Practices

In our [Collaborative Flow Pro Example](/examples/interaction/collaborative), we
show a realtime multiplayer collaboration flow using [React Flow](/) and
[Yjs](https://github.com/yjs/yjs). While this is a great example, you may be
wondering how to implement realtime multiplayer collaboration with React Flow
and other libraries and backends.

{/* TODO? Multiplayer done right is hard. Whenever you want to achieve
persistence and realtime collaboration, you will need to handle conflicts when
multiple clients try to update the same state, and the case where a client is
offline and needs to catch up with the latest state when it comes back online.
*/}

In this guide, we will explore some best practices for integrating multiplayer
collaboration in your React Flow application, focusing mainly on **the
high-level application logic** you need to implement.

We will answer the following questions:
- What is multiplayer? A few words about live updates, local first, and CRDTs?
- What React Flow state should I sync with the backend?
- Consolidating shared and local state.
- How to handle conflicts when multiple clients try to update the same state?
- How to display the collaboration state to the users?
- What libraries or data structures to use for realtime collaboration?

## What is multiplayer?

A **multiplayer application** is an application that allows multiple users to
interact with the same data. In a multiplayer application, the data is most
commonly stored on a server and share between all users. In most multiplayer
applications, the data is updated in realtime. **Live updates** are a concept
orthogonal to multiplayer, and can be implemented with or without multiplayer.
Live updates are the process of updating the data on the client in realtime, and
is usually achieved with a [websocket
connection](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket) to the
server. Modern multiplayer applications combine both live updates and
multiplayer interaction. *You want multiple users interacting with the same data
in realtime, and seeing each other's changes.*

Lately, there has been a trend on building multiplayer application with a
**Local First** approach, meaning that the *client is the source of truth for
the data*, and the server can only used to sync the data between clients. In a
multiplayer or P2P application context, the data is thus replicated between all
clients. The pro, is that an user can work offline, and when their client
reconnects, the data is synced with the server and other users. This introduces
a challenge: *how to handle conflicts when multiple clients try to update the
same state?*. The conflict resolution logic for a multiplayer, realtime, local
first application is absolutely **a non-trivial task**.

This is where **Conflict Free Replicated Data Types** (CRDTs) come to the
rescue! CRDTs are a popular data structure for local first applications, and can
help you achieve realtime collaboration without having to implement conflict
resolution logic manually. CRDTs trade some complexity for availability: they
simplify conflict resolution and offline collaboration, but require careful
design to ensure that merge functions and operations preserve the necessary
properties.

Some modern multiplayer solutions, like [Yjs](https://github.com/yjs/yjs), and
[Jazz](https://jazz.tools), use a CRDT to achieve realtime collaboration. You
can treat CRDT-backed structures as having an intrinsic notion of mutation: each
update you perform on the CRDT is already a well-defined, conflict-free
operation.


## Multiplayer React Flow: High level architecture 

Let's briefly discuss what you need to implement for adding multiplayer
collaboration to your React Flow application:

As seen in our [State Management](/learn/advanced-use/state-management) guide,
React Flow uses a [Zustand store](https://github.com/pmndrs/zustand) internally
to manage the state of flows. Ideally, you would want to define your store logic
in a way that is decoupled from rendering logic. To achieve modularity Zustand
allows you to split the application store into smaller chunks, each responsible
for a specific part of the application state. You can read more about slices in
the [Zustand documentation](https://zustand.docs.pmnd.rs/guides/slices-pattern).

###  Syncing nodes and edges


**React Flow nodes and edges have properties that you do not want to sync between multiplayer clients,** 
and are part of the client-only specific state.

When you are **syncing nodes**, we recommend to sync at least the node's `id`,
`position`, size (`width` and `height`), `data`. You can
additionally sync properties of a node like `selectable`, `disabled`,
and others, **but we recommend to not sync the `selected` and `measured`
properties**: If Bob and Alice are connected to the same flow on two different
devices, Bob selects a node, and Alice selects another node, Bob will see
Alice's node selected, and Alice will see Bob's node as selected, as if both of them
did select both nodes on their devices, which was clearly not the case. 

Analogously you can safely **sync edges** by syncing their `id`, `source`,
`target`, `sourceHandle`, `targetHandle`, `type`, and so on, and as with nodes,
we **recommend to not sync the `selected` prop**.

Here is a table summarizing which fields are **safe to sync** vs. **keep client-side**:

| Field | Sync Node | Sync Edge | Reason |
|-------|-----------|-----------|--------|
| `selected` | ❌ | ❌ | Per-user UI state |
| `measured` | ❌ | N/A | Computed from DOM |
| `dragging` | ❌ | N/A | Transient interaction state |
| `resizing` | ❌ | N/A | Transient interaction state |
| `id` | ✅ | ✅ | Core identifier to share |
| `type` | ✅| ✅ | Node and edge type |
| `data` | ✅ | ✅ | Core shared data |
| `selectable` | ✅ | ✅ | Shared interaction capability |
| `position` | ✅ | N/A | Node layout position |
| `width`, `height` | ✅ | N/A | Node size |
| `source`, `target` | N/A| ✅ | Core edge node identifiers |
| `sourceHandle`, `targetHandle` | N/A| ✅ | Edge handle identifiers |

When you use custom callbacks such as `onNodesChange`, `onEdgesChange`, or
`onConnect`, React Flow expects you to **apply the changes** to the store after
you have added your custom logic.  (TODO: some solutions might not require to
directly apply the changes to the store, but to apply mutations to the shared
data structures, and then expect the solutions to be directly derived from a
reactive query.)



TODO: you must implement these functions in your store logic:
- onNodesChange
- onEdgesChange
- onConnect
- addNode
- addEdge
- updateNodeData

### Cursors, presence and incomplete connections

To improve the UX of your multiplayer application, you may want to store and
sync an additional list of users connected to the flow, their mouse cursor
positions, and the incomplete connections (edges) that they are dragging between
nodes. Many existing solutions provide presence features for rooms, which you
can use to retrieve the list of users connected to the flow. 

Syncing the cursor position between clients is simple, but you should avoid
storing it permanently, and to  avoid sending too many updates to the backend,
and to save bandwidth and processing power you should throttle the cursor
updates (we had success with 64ms). You can use a library like
[perfect-cursors](https://github.com/steveruizok/perfect-cursors) to smooth the
movements of other users' cursors when their position updates are received at a
low frequency. A similar approach can be used for syncing the incomplete
connections between nodes, or whiteboarding features.

We recommend using a separate Zustand slice that stores an array of cursor
objects, each containing the user's ID, position, dragging state, and color.
When an user connects to a flow, you should add their cursor to the array, and
when an user leaves the flow, you should remove their cursor from the array.

