---
description: Learn how to use React Flow with realtime multiplayer collaboration features.
---

# Realtime Multiplayer Collaboration Best Practices

In our [Collaborative Flow Pro Example](/examples/interaction/collaborative), we
show a realtime multiplayer collaboration flow using [React Flow](/) and
[Yjs](https://github.com/yjs/yjs). While this is a great example, you may be
wondering how to implement realtime multiplayer collaboration with React Flow
and other libraries and backends.

{/* TODO? Multiplayer done right is hard. Whenever you want to achieve persistence and
realtime collaboration, you will need to handle conflicts when multiple clients
try to update the same state, and the case where a client is offline and needs
to catch up with the latest state when it comes back online. */}

In this guide, we will explore some best practices for integrating multiplayer
collaboration in your React Flow application, focusing mainly on **the
high-level application logic** you need to implement.

We will answer the following questions:
- What React Flow state should I sync with the backend?
- What can be safely persisted in a database, and what should be broadcasted to other clients?
- How to handle conflicts when multiple clients try to update the same state?
- How to display the collaboration state to the users?
- What libraries or data structures to use for realtime collaboration?

## High Level Architecture 

As seen in our [State Management](/learn/advanced-use/state-management) guide,
React Flow uses a [Zustand store](https://github.com/pmndrs/zustand) internally
to manage the state of flows.
To implement multiplayer collaboration, we recommend using a Zustand store to
manage the nodes and edges in the flow, and passing them to the React Flow
component, as well as storing additional state that you want to sync between
clients connected to the same multiplayer flow.
To achieve modularity Zustand allows you to split the application store into
smaller chunks, each responsible for a specific part of the application state.
You can read more about slices in the [Zustand
documentation](https://zustand.docs.pmnd.rs/guides/slices-pattern).

We recommend using the following slices for multiplayer:
- `flow` slice responsible for the nodes and edges in the flow.
- `cursor` slice responsible for syncing the users' cursor positions.
- `connection` slice responsible to draw the incomplete connections between
  nodes.

## State Management - The Flow Slice 

Instances of the React Flow component, expect to receive two array props:
`nodes` and `edges`, and various callback props to let you intercept and add custom
functionality when users interact with the flow. 

When you use custom callbacks such as `onNodesChange`, `onEdgesChange`, or
`onConnect`, React Flow expects you to **apply the changes** to the store after
you have added your custom logic.
It is thus a good pattern to store the nodes and edges in the `flow` slice,
together with the callbacks definitions, so that they can access the `set` and
`get` functions that Zustand provides when creating a store or slice.

The goal is to be able to define your store logic in a way that is decoupled from rendering logic.

Here is an example of the `flow` slice. This is where you will want to add your multiplayer-related code.
We will see how to add multiplayer logic to this slice in the next sections.
```tsx
import type { StateCreator } from "zustand";
import {
  applyNodeChanges,
  applyEdgeChanges,
  addEdge,
  type Edge,
  type OnConnect,
  type OnEdgesChange,
  type OnNodesChange,
} from "@xyflow/react";

// You should define the store type combining all different slices of your app
// import type { Store } from "./";


export interface FlowSlice {
  nodes: Node[];
  edges: Edge[];
  onNodesChange: OnNodesChange;
  onEdgesChange: OnEdgesChange;
  onConnect: OnConnect;
  addNode: (node: Omit<Node, "id">) => void;
  addEdge: (edge: Omit<Edge, "id">) => void;
  updateNodeData: (nodeId: string, newData: Node["data"]) => void;
}

export const createFlowSlice: StateCreator<Store, [], [], FlowSlice> = (
  set,
  get
) => {
  return {
    nodes: [],
    edges: [],
    onNodesChange: (changes) => {
      set({
        nodes: applyNodeChanges(changes, get().nodes),
      });
    },
    onEdgesChange: (changes) => {
      set({
        edges: applyEdgeChanges(changes, get().edges),
      });
    },
    onConnect: (connection) => {
      set({
        edges: addEdge(connection, get().edges),
      });
    },
    addNode: (node) => {
      set({
        nodes: [...get().nodes, { ...node, id: crypto.randomUUID() }],
      });
    },
    addEdge: (edge) => {
      set({
        edges: [...get().edges, { ...edge, id: crypto.randomUUID() }],
      });
    },
    updateNodeData: (nodeId, newData) => {
      set({
        nodes: get().nodes.map((node) =>
          node.id === nodeId
            ? { ...node, data: { ...node.data, ...newData } }
            : node
        ),
      });
    },
  };
};
```

## What to sync or not to sync? 

You can confidently sync whenever an user adds a node or an edge, inside of
`addNode` or `addEdge`, `onConnect`. 

### Syncing nodes

When you are syncing nodes, we recommend to sync at least the node's `id`,
`position`, size (`width` and `height`), `data` and `dragging`. You can
additionally sync properties of a node like `selectable`, `disabled`, `dragging`
and others, **but we recommend to not sync the `selected` property**: If Bob and
Alice are connected to the same flow on two different devices, Bob selects a
node, and Alice selects another node, Bob will see Alice's node selected, and
Alice will see Bob's node selected, as if they both selected both nodes on their
devices, which was clearly not the case.

If you want to display what other users connected to the same flow are doing,
such as mouse cursors, selection states or new incompleted edges, we recommend
**creating a custom Zustand slice** for each feature, for example:

- A slice storing and syncing a list of `(x,y)` positions for each connected
user to display their mouse cursor
- Another slice storing a list of which nodes each user has selected, without
  syncing the main nodes `selected` property.

In the end, you should be able to create custom components such as [custom
nodes](/learn/customization/custom-nodes) that *consume your Zustand store* and
render a different UI for synced state.

For example, for displaying if another user has selected one or more nodes,
instead of syncing the `selected` prop (for the reasons discussed above), you
may want to implement a component wrapping node components and displaying an
outer glow with the color assigned to the different user.

### Syncing edges

You can safely sync edges by syncing their `id`, `source`, `target`,
`sourceHandle`, `targetHandle`, `type`, and so on, and as with nodes, we
**recommend to not sync the `selected` prop**.

Additionally, if you want to display the incomplete connections between nodes,
in other workds new edges being created, connected to a single handle and
"dangling" from an user's mouse cursor, you should store the incomplete
connections in a separate slice, and sync them to other clients via ephemeral broadcasting, 
and not persist them in the database.

### Syncing cursors

To sync mouse cursors, we recommend using a custom Zustand slice that stores an array of 
cursor objects, each containing the user's id, position, dragging state, and color.
When an user connects to a flow, you should add their cursor to the array, and
when an user leaves the flow, you should remove their cursor from the array.

When an user moves their own mouse cursor, you should update the cursor position
and broadcast the update to other clients, so they can display the cursor in
their UI. To avoid sending too many updates to the backend, you should throttle
the cursor updates (we had success with 64ms) , and you can use a library like
[perfect-cursors](https://github.com/steveruizok/perfect-cursors) to smooth the
cursor movements. 

---


Some solutions,
like [Yjs](https://github.com/yjs/yjs), and [Jazz](https://jazz.tools), use a
CRDT (Conflict-Free Replicated Data Type) to achieve realtime collaboration. You
can treat CRDT-backed structures as having an intrinsic notion of mutation: each
update you perform on the CRDT is already a well-defined, conflict-free
operation. This means that you can broadcast the updates to other clients as soon
as you perform the operation, and the other clients will be able to apply the
update to their local state, resolving conflicts automatically.

On the other hand, other solutions involving relational or object databases,
like [Supabase](https://supabase.com), may not offer a CRDT-like functionality,
and automatic conflict resolution. In this case, you will need to decide when to
broadcast changes via realtime, a less expensive, ephemeral and faster
operation, and when to commit them to the database, a more expensive, persistent
and slower operation. This causes issues when you want to display the
collaboration state to the users,


TODO: write limitations of supabase


## What solution to use for realtime collaboration?

TODO: write about CRDT solutions (yjs, jazz)

TODO: write about non-CRDT solutions (partykit) 

### Supabase and direct SQL database pros and cons 

Supabase Realtime is a great solution for some realtime collaboration tasks, but
it has some limitations. We have implemented a solution that uses Supabase
Realtime with React Flow and Zustand, and we have encountered various problems
that need to be addressed individually by the application, while some other 
multiplayer solutions like Yjs and Jazz solve those hard synchronization issues 
automatically by design.

#### Supabase Pros 

**Persistence.** Supabase is a great solution for persistence, as data is
automatically persisted to [Postgres](https://www.postgresql.org/), a mature and
battle-tested relational database.

**SQL querying.** If you are familiar with relational databases, you can use the
full power of SQL to query the data. Complex views and queries are possible, and
easy to implement, but usually, for flow based applications, you will not need
to use the full power of SQL.

In contrast, CRDT libraries often require you to implement your own persistence
and querying logic, which can be a more complex task.

#### Supabase Cons 

**Manual conflict resolution required.** When multiple users edit the same node
simultaneously, you must implement some form of conflict resolution manually. In
contrast, CRDT libraries provide built-in conflict resolution logic.

**Database operations are expensive. Broadcasting is cheaper.** This means that
you will need to decide when to broadcast changes via realtime, and when to
commit them to the database. If your application requires to sync high-frequency
updates, such as text fields, you now have to decide when you want to broadcast
the changes to other clients, and when you want to commit them to the database.
CRDT libraries often provide multiplayer data structures that are optimized for
such kind of high-frequency updates.

**Offline edits are not supported.** Supabase does not support offline edits,
and you need to detect when you lose connection to the server and implement a
full state sync manually when you reconnect. 
This is a tedious task, and users, while they are editing the flow offline, 
want their changes to be uploaded to the server as soon as they regain connection, 
while receiving the changes from other users that were made while they were offline.
Supabase broadcast messages are not ordered, and might be enqueued, while 
supabase postgres transactions are one-shot operations which might fail without 
a rollback mechanism or a message queuing system.
This means that you will need to implement a custom transaction logic to ensure that
the changes are applied in the correct order, and that the changes are not lost
if the transactions fails.

**Debugging difficulty.** When state gets out of sync, the above points make it
harder to debug the synchronization logic, compared to CRDTs' built-in deterministic
merge behavior.


