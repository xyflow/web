---
title: Migrate to v1
description: Use this guide to migrate from Svelte Flow v0 to v1.
---

# Migrate to Svelte Flow 1.0

## Migration Guide

### `nodes` & `edges` are now using `$state.raw` instead of `writable`

Svelte 5 introduces runes which are now getting used for nodes and edges.

**Old API**

```js
const nodes = writable([...]);
const edges = writable([...]);
```

**New API**

```js
let nodes = $state.raw([...]);
let edges = $state.raw([...]);
```

### Updating Nodes & Edges

Previously it was possible to update single node properties. Theoretically, this would also be possible with `$state`, however the [performance implications](https://svelte.dev/playground/e6f804ba6da348bc8b6a0a13c59672cb?version=5.19.0) of this are unfortunately too great, so we opted to using `$state.raw`.

This means that `nodes` and `edges` are to be treated as immutable from now on. If you are making updates manually make sure you:

1. create a new node/edge object, when updating a property.
2. reassign the nodes/edges array (this was technically required before anyway)

### `nodes` & `edges` need to be bound from `<SvelteFlow />`

**Old API**

```js
<SvelteFlow {nodes} {edges} />
```

**New API**

```js
<SvelteFlow bind:nodes bind:edges />
```

If `nodes` and `edges` live in a separate module, you can use [function bindings](https://svelte.dev/docs/svelte/bind#Function-bindings).

```js
// store.svelte.js

let nodes = $state.raw([...]);
let edges = $state.raw([...]);

export const getNodes = () => nodes;
export const getEdges = () => edges;
export const setNodes = (newNodes) => nodes = newNodes;
export const setEdges = (newEdges) => edges = newEdges;
```
```js
// BaseComponent.svelte

<script>
  import { getNodes, getEdges, setNodes, setEdges } from 'store.svelte.js';
</script>

<SvelteFlow bind:nodes={getNodes, setNodes} bind:edges={getEdges, setEdges} />
```

### Custom Node & Edge Props

This is by enlarge a general change in Svelte 5 but it does have quite a big impact on typing the props of Custom Nodes & Edges.

**Old API**

```js
// CustomNode.svelte

type $$Props = NodeProps;

export let data: $$Props['data'];
export let position: $$Props['position'];
export let selected: $$Props['selected'];
```

**New API**

```js
let { data, position, selected } : NodeProps = $props();
```

### Hooks

Hooks now return reactive values instead of writables. Because `$state` values cannot be [returned by functions directly](https://svelte.dev/docs/svelte/$state#Passing-state-into-functions) we have to return an object with a `.current` property to keep reactivity. In this regard, we are [following the official trend](https://svelte.dev/docs/svelte/svelte-reactivity#MediaQuery) set by the Svelte library authors.

**Old API**

```js
const edges = useEdges();
$: console.log(edges);
```

**New API**

```js
const edges = useEdges();
$inspect(edges.current);
```

Note that in case of `useNodes`, `useEdges` and `useViewport` reassignments to `.current` work!

```js
const nodes = useNodes();

function updateNodes() {
   nodes.current = [...]
}
```

### useSvelteFlow

`useSvelteFlow` provides access functions that operate on the internal state. When using the hook inside descendants of the `<SvelteFlow />` component (probably custom nodes/edges), apart from changes to some of the functions it exports there is nothing you have to change.

```js
// CustomNode.svelte

const { updateNode, screenToFlowPosition } = useSvelteFlow(); //still works
```

However, if you are using the `<SvelteFlowProvider />` to extend the scope of internal store to components outside of the main `<SvelteFlow />` component, you will have to wrap the hook call in a `$derived`.

**Old API**

```js
// Sidebar.svelte

const { addNode, deleteNodes, fitView } = useSvelteFlow();
```

**New API**

```js
// Sidebar.svelte

let { addNode, deleteNodes, fitView } = $derived(useSvelteFlow());
```

### Binding the viewport

**Old API**

```js
const viewport = writable<Viewport>({ x: 100, y: 100, zoom: 1.25 });

<SvelteFlow {viewport} />
```

**New API**

```js
let viewport = $state < Viewport > { x: 100, y: 100, zoom: 1.25 };

<SvelteFlow bind:viewport />;
```

### Custom Connection Line

Using a custom Connection Line was possible before by passing it to a slot. In Svelte Flow 1.0 we introduced a `connectionLineComponent` prop for this:

**Old API**

```js
<SvelteFlow {nodes} {edges}>
  <ConnectionLine slot="connectionLine" />
  <Background variant={BackgroundVariant.Lines} />
</SvelteFlow>
```

**New API**

```js
<SvelteFlow {nodes} {edges} connectionLineComponent={ConnectionLine}>
  <Background variant={BackgroundVariant.Lines} />
</SvelteFlow>
```

## New Features

### colorModeSSR

You can pass a fallback color mode for server side rendering when `colorMode` is set to `'system'`.
