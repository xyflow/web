---
title: ''
htmlTitle: ''
description: ''
intro: ''
date: 7 November 2025
authors: ['peter']
tags: []
image: ''
---

Itâ€™s been a thrilling month for node-based UI enjoyers.

Letâ€™s do a quick highlight reel:

- [**Fuser**](https://fuser.studio/) officially launched (ðŸŽ‰), and I _highly_ recommend
  their essay:
  [Why Every Creative Tool Is Becoming a Node Canvas](https://fuser.studio/blog/the-graph-will-set-you-free-why-every).
- [**Weavy**](https://www.weavy.ai/) got **acquired by Figma** â€” a bold bet on flow-based
  UIs to integrate generative AI right into the design toolchain.
- **Vercel** rolled out an [AI SDK](https://ai-sdk.dev/) complete with shiny new
  [Workflow UI Elements](https://ai-sdk.dev/elements/examples/workflow).
- And just to keep everyone on their toes, **OpenAI** dropped a node-based
  [Agent Builder](https://platform.openai.com/docs/guides/agent-builder).

The best part? Every single one of these is built with **React Flow**!

### U can't touch this

Like proud parents checking in on their kidâ€™s science fair project, we went to see what
our baby was up to. While exploring OpenAIâ€™s Agent Builder, we got _nerd-sniped_ almost
instantly...

[video]

You see, weâ€™ve been keeping a long-running mental backlog of ideas â€” and seeing one of
them out in the wild like that finally pushed us to tackle **how we can prevent
overlapping nodes**.

As with pretty much anything you try to build these days, you can expect someone,
somewhere, has already done it. So down the rabbit hole we went. From 2D physics engines
to force-directed graphs, there are many different applications and solutions for keeping
things from awkwardly overlapping.

But, as savvy programmers, we know of the ancient wisdom passed down by our ancestors:

1. Premature optimization is the root of all evil.
2. You canâ€™t optimize what you donâ€™t measure.
3. Computers iterate over arrays _frickinâ€™ dang fast._

So, we knew exactly what to do: build a benchmark to compare any algorithms, and â€” most
importantly â€” **start with embracing your inner child** by writing the most naÃ¯ve solution
with arrays.

### The algorithm they are telling you not to worry about

Letâ€™s break down what weâ€™re actually trying to do here:

1. Check if two nodes are overlapping (plus a margin).
2. Figure out which dimension has the smallest overlap.
3. Move both nodes in opposite directions along that dimension.
4. Repeat, because we might have introduced new overlaps.
5. Stop once there are no overlaps left.

First, we derive some boxes from our nodes and add a bit of margin:

```ts
const boxes = new Array(nodes.length);

for (let i = 0; i < nodes.length; i++) {
	const node = nodes[i];
	boxes[i] = {
		x: node.position.x - margin,
		y: node.position.y - margin,
		width: (node.width ?? node.measured.width) + margin * 2,
		height: (node.height ?? node.measured.width) + margin * 2,
		moved: false
		node,
	}
}
```

Next, we create a juicy O(n^2) algorithm by checking every node against every other one.
It might seem a little unintuitive at first to detect overlaps using center points, but
the resulting values tell us _how much_ theyâ€™re overlapping, which will come in handy
later.

```ts
let moved = true;
// Re-check until none of them are moving anymore
while (moved) {
  moved = false;
  for (let i = 0; i < boxes.length; i++) {
    for (let j = i + 1; j < boxes.length; j++) {
      const A = boxes[i];
      const B = boxes[j];

      // Calculate center positions
      const centerAX = A.x + A.width * 0.5;
      const centerAY = A.y + A.height * 0.5;
      const centerBX = B.x + B.width * 0.5;
      const centerBY = B.y + B.height * 0.5;

      // Calculate distance between centers
      const dx = centerAX - centerBX;
      const dy = centerAY - centerBY;

      // Calculate overlap along each axis
      const px = (A.width + B.width) * 0.5 - Math.abs(dx);
      const py = (A.height + B.height) * 0.5 - Math.abs(dy);

      // Check if there's overlap
      if (px > 0 && py > 0) {
        // TODO: move the nodes
      }
    }
  }
}
```

Then we calculate how far to move each node and mark which ones were changed to avoid
unnecessary updates later.

```ts
// [...]
// Check if there's overlap
if (px > 0 && py > 0) {
  // mark moved nodes to prevent unnecessary updates
  moved = A.moved = B.moved = true;
  // Resolve along the smallest overlap axis
  if (px < py) {
    // Move along x-axis
    const sx = dx > 0 ? 1 : -1;
    const moveAmount = (px / 2) * sx;
    A.x += moveAmount;
    B.x -= moveAmount;
  } else {
    // Move along y-axis
    const sy = dy > 0 ? 1 : -1;
    const moveAmount = (py / 2) * sy;
    A.y += moveAmount;
    B.y -= moveAmount;
  }
}
```

Finally, we create a new array of nodes and remove the margin again to restore the correct
positions.

```ts
const newNodes = boxes.map((box) => {
  if (box.moved) {
    return {
      ...box.node,
      position: {
        x: box.x + margin,
        y: box.y + margin,
      },
    };
  }
  return box.node;
});
```
