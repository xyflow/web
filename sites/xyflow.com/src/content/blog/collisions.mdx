Itâ€™s been a thrilling month for node-based UI enjoyers.

Letâ€™s do a quick highlight reel:

- [**Fuser**](https://fuser.studio/) officially launched ðŸŽ‰, and I _highly_ recommend
  their essay:
  [Why Every Creative Tool Is Becoming a Node Canvas](https://fuser.studio/blog/the-graph-will-set-you-free-why-every).
- [**Weavy**](https://www.weavy.ai/) got acquired by **Figma** in a bet on flow-based UIs
  to integrate generative AI into the design toolchain.
- **Vercel** rolled out an [AI SDK](https://ai-sdk.dev/) complete with shiny new
  [Workflow UI Elements](https://ai-sdk.dev/elements/examples/workflow).
- And just to keep everyone on their toes, **OpenAI** dropped a node-based
  [Agent Builder](https://platform.openai.com/docs/guides/agent-builder).

The best part? Every single one of these is built with **React Flow**!

### U can't touch this

While exploring OpenAIâ€™s Agent Builder and discovering they are preventing node overlaps,
obviously we got _nerd-sniped_ immediately.

[video]

You see, weâ€™ve been keeping a long-running mental backlog of ideas and seeing one of them
out in the wild like that finally pushed us to tackle this one.

#### TLDR;

- We created a [showcase](https://node-collision-algorithms.vercel.app/) and
  [benchmark](https://github.com/xyflow/node-collision-algorithms) to compare different
  node overlap resolution algorithms
- The naive solution is very hard to beat
- Vitest Bench and tinybench are pretty neat
- The WASM toolchain has become very sleek
- flatbush is an impressive feat

As with pretty much anything you try to build these days, you can expect someone,
somewhere, has already done it. So down the rabbit hole we went. From 2D physics engines
to force-directed graphs, there are many different applications and solutions for keeping
things from awkwardly overlapping.

But, as savvy programmers, we know of the ancient wisdom passed down by our ancestors:

1. Premature optimization is the root of all evil.
2. You canâ€™t optimize what you donâ€™t measure.
3. Computers iterate over arrays _pretty dang fast._

So, we knew exactly what to do: create some data, build a benchmark and, most importantly,
**embrace your inner child** and start by writing the most naive solution you can come up
with. Oh and of course, just use arrays.

### The algorithm they are telling you not to worry about

Close your eyes; breathe in; let the pent-up peer pressure from your professors,
colleagues and some random dude on the internet leave your body; breathe out. What do you
see?

1. Check if two nodes are overlapping (add a small margin).
2. Figure out which dimension (x or y) has the smallest overlap.
3. Move both nodes in opposite directions along that dimension.
4. We might have introduced new overlaps, so repeat.
5. Stop once there are no more overlapping nodes.

Or if you prefer pseudo code:

```ts
function resolveOverlaps(nodes, margin):

    overlapFound = true

    while overlapFound:
        overlapFound = false

        for each pair of nodes (A, B):
            if A and B overlap (considering margin):
                overlapFound = true

                overlapX = amount of overlap along x-axis
                overlapY = amount of overlap along y-axis

                if overlapX < overlapY:
                    # Move along x-axis
                    move A left by overlapX / 2
                    move B right by overlapX / 2
                else:
                    # Move along y-axis
                    move A up by overlapY / 2
                    move B down by overlapY / 2

    return nodes
```

_If you are interested in a complete technical rundown and actual implementation, head
over to the [repository](https://github.com/xyflow/node-collision-algorithms)._

### Choosing the right datasets

Much like my ambitious plan to run a Kubernetes cluster for a website with ten monthly
visitors (one of them being my mum), benchmarking a dataset made up of an absurd number of
elements is a foolâ€™s errand in the real world. If you know, for example, that 95% of your
flows contain fewer than 25 nodes, your benchmark should reflect that reality.

The same goes for overlap density. In most cases, flows arenâ€™t so tightly packed that
resolving a single overlap causes a full-on cascade of nodes moving around. So it makes
sense to include a dataset where nodes are more reasonably spaced apart.

Lastly, testing on a dataset with _no_ overlaps at all is a good way to measure the
baseline cost â€” the performance youâ€™d expect when there are no overlaps to resolve.

Hereâ€™s an overview of what our synthetic data looks like:

```text
+----------------+----------------+----------------+----------------+
|                | Separated      | Clustered      | Packed         |
+----------------+----------------+----------------+----------------+
| 15 Nodes       |  â€¢          â€¢  |  â€¢â€¢            |        â€¢â€¢      |
|                |                |           â€¢â€¢   |       â€¢â€¢â€¢      |
|                |         â€¢      |      â€¢â€¢        |       â€¢â€¢       |
+----------------+----------------+----------------+----------------+
| 100 Nodes      | â€¢  â€¢   â€¢   â€¢   |  â€¢â€¢         â€¢â€¢ |     â€¢â€¢â€¢â€¢â€¢â€¢â€¢    |
|                |   â€¢     â€¢   â€¢  |    â€¢â€¢   â€¢â€¢     |     â€¢â€¢â€¢â€¢â€¢â€¢     |
|                | â€¢   â€¢   â€¢   â€¢  |  â€¢â€¢         â€¢â€¢ |      â€¢â€¢â€¢â€¢â€¢â€¢    |
+----------------+----------------+----------------+----------------+
| 500 Nodes      | â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢  | â€¢â€¢  â€¢â€¢  â€¢â€¢  â€¢â€¢ | â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢  |
|                |  â€¢ â€¢ â€¢ â€¢ â€¢ â€¢   |   â€¢â€¢  â€¢â€¢  â€¢â€¢   | â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢  |
|                | â€¢ â€¢ â€¢ â€¢ â€¢ â€¢ â€¢  | â€¢â€¢  â€¢â€¢  â€¢â€¢  â€¢â€¢ | â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢  |
+----------------+----------------+----------------+----------------+
```

See how I just dropped the word _synthetic_ in there to sound smarter? One goal you should
always keep in mind is to use **real-world data** in your benchmarks whenever possible.
Unfortunately, we are just humble library authors with no access to production dataâ€¦ but
_maybe you_ can help us out?

If youâ€™d like to see your real-world data included in our benchmarks, feel free to open a
pull request! Itâ€™s super easy, just add another array of trimmed down nodes
`{ position: { x: number, y: number }, width: number, height: number }[]` and give it a
name!

### Benchmark

Thankfully, [Vitest](https://vitest.dev/) got our back with their
[`bench`](https://vitest.dev/api/#bench) command based on
[tinybench](https://github.com/tinylibs/tinybench). We simply create a new test file that
ends with "bench.ts" and we are ready to go!

```ts
datasets.forEach((dataset) => {
  describe.concurrent(dataset, () => {
    bench(
      'naive',
      () => {
        naive(nodes, options);
      },
      benchOptions,
    );
  });
});
```

Running `vitest bench` gives us the following mean results on a 14-Core M4 Pro for
resolving collision on different datasets.

Seperated (single iteration, no overlaps)

- 15 nodes: **~0.3Âµs**
- 100 nodes: **~8Âµs**
- 500 nodes: **~0.2ms**

Clustered (separated clusters, few overlaps)

- 15 nodes: 5 iterations **~0.7Âµs**
- 100 nodes: 9 iterations **~0.5ms**
- 500 nodes: 9 iterations **~1.1ms**

Packed (many overlaps, tightly packed)

- 15 nodes: 12 iterations **~2Âµs**
- 100 nodes: 80 iterations **~0.5ms**
- 500 nodes: 618 iterations **~150ms**

**Spoiler Alert:** It seem like we just created a (blazingly) fast algorithm that's going
to be fairly hard to beat.

### Putting results into perspective

To understand what these results actually mean and how well the algorithm performs, we
need to consider when it would realistically run and whether any delay would even be
noticeable. We wouldnâ€™t run this on every frame while dragging a node (which, on modern
high-refresh displays, can mean 120 times a second with \<8.3ms of frame budget). Instead,
it would only trigger when a node is dropped or when changes to nodes are submitted.

Looking at the data, we can see:

- working with fewer than 500 nodes should never cause any issues
- in a more realistic scenario of 500 clustered nodes, 1.1 ms seems acceptable
- resolving 500 tightly packed nodes is definitely noticeable but this happening out in
  the wild will arguably very rare (only when pasting high number of nodes into tightly
  packed flow)

Note: This benchmark was run on a processor with a very high single-core performance and
we should test on more representative machines in the future.

### Optimize

If a single iteration (in our case, calculating the overlap) doesnâ€™t seem very complex,
the easiest way to optimize any \(O(n^2)\) algorithm is to bring that \(n\) down â€” ideally
to \(n \log n\), or, if weâ€™re lucky, even \(\log n\).

Right now, our \(n\) is defined by us comparing every single node with every other node
like the hairless ape we are. This, however, is a perfect use case for a

âœ¨**Spatial Acceleration Structures**âœ¨

While it might sound like technobabble straight out of _Mission: Impossible_, itâ€™s really
just a group of clever data structures. They let us exchange some linear cost up front for
the ability to make cheap spatial queries later. Those queries can range from "What are
the 10 closest neighbours of node X?" to "What nodes lie in region X".

### quadtree-ts, rbush and flatbush

Our first contender is [quadtree-ts](https://github.com/timohausmann/quadtree-ts). Like
the name implies, it's a library utilizing quadtrees, which work by subdividing the space
recursively and storing only a limited number of nodes in every leaf.

Both [rbush](https://github.com/mourner/rbush) and
[flatbush](https://github.com/mourner/flatbush) are implementations of
[packed Hilbert-R-trees](https://en.wikipedia.org/wiki/Hilbert_R-tree#Packed_Hilbert_R-trees),
however flatbush is entirely static (updating a single node is not possible) and it stores
its data structure in a single array buffer, enabling efficient data transfer between
threads.

In short we can replace our main n-squared loop with a simple iterator over the nodes and
a spatial query.

```diff
- for each pair of nodes (A, B):
-    if A and B overlap (considering margin):
+ for each node (A):
+    for every overlapping node (B):
```

**For a more detailed rundown of the algorithms head over to the
[repository](https://github.com/xyflow/node-collision-algorithms).**
