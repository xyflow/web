---
title: 'When Nodes Collide: Collision Algorithms and the Latest Node UI Buzz'
htmlTitle: ''
description: ''
intro: ''
date: 13 November 2025
authors: ['peter', 'abbey']
tags: []
image: ''
---

It‚Äôs been a thrilling month for node-based UI enjoyers.

Let‚Äôs do a quick highlight reel:

- [**Fuser**](https://fuser.studio/) officially launched üéâ, and I _highly_ recommend
  their essay:
  [Why Every Creative Tool Is Becoming a Node Canvas](https://fuser.studio/blog/the-graph-will-set-you-free-why-every).
- [**Weavy**](https://www.weavy.ai/) as part of their push into flow-based UIs, with the
  goal of integrating generative AI directly into the design toolchain.
- **Vercel** rolled out an [AI SDK](https://ai-sdk.dev/) complete with shiny new
  [Workflow UI Elements](https://ai-sdk.dev/elements/examples/workflow).
- And just to keep everyone on their toes, **OpenAI** dropped a node-based
  [Agent Builder](https://platform.openai.com/docs/guides/agent-builder).

The best part? Every single one of these is built with **React Flow**!

### U can't touch this

While exploring OpenAI‚Äôs new Agent Builder, we noticed they‚Äôd solved a surprisingly tricky
problem, preventing node overlaps. It‚Äôs something that had been on our backlog for a
while, and as soon as we saw it, we knew we had to recreate it ourselves.

[video]

There are a few different ways to approach node overlap resolution, and we wanted to
compare them side by side, so we put together a small
[showcase](https://node-collision-algorithms.vercel.app/) to see how different algorithms
stack up.

<div style={{ margin: '2rem 0' }}>
  <iframe
    src="https://node-collision-algorithms.vercel.app/"
    title="Node Collision Algorithms Demo"
    loading="lazy"
    allowFullScreen
    style={{ width: '100%', height: '80vh', border: 0, borderRadius: '12px' }}
  />
</div>

TL;DR ‚Äî We learned that while the naive solution is hard to beat, the WASM toolchain and
flatbush are potent tools, and Vitest Bench with tinybench provides excellent performance
insights.

### Implementing our naive solution

As seasoned programmers, we like to follow a few timeless truths passed down through the
ages:

1. Premature optimization is the root of all evil.
2. You can‚Äôt optimize what you don‚Äôt measure.
3. Computers iterate over arrays _pretty dang fast._

So we knew exactly what to do: generate some data, build a benchmark, and most
importantly, embrace our inner child by starting with the most naive solution we could
imagine.

For our naive algorithm, we first define bounding boxes for each node, adding a small
buffer to account for visual spacing.

Next, it traverses each node in **O(n¬≤)**, checking for collisions with other nodes. We
measure collisions from the nodes‚Äô center points, which yields a precise measure of how
much each pair overlaps, which helps guide the next step.

Then, we calculate how far each overlapping node needs to move and track which nodes have
changed to avoid unnecessary updates. For each overlapping pair, we determine the axis (x
or y) with the smallest overlap and move the nodes in opposite directions along that axis.
We repeat this process as needed, since resolving one overlap can sometimes create
another.

Finally, we generate a new array of nodes with their corrected positions, ensuring all
nodes are neatly spaced without introducing unnecessary movement.

Here's the breakdown in pseudo code:

```ts
function resolveOverlaps(nodes, margin):

    overlapFound = true

    while overlapFound:
        overlapFound = false

        for each pair of nodes (A, B):
            if A and B overlap (considering margin):
                overlapFound = true

                overlapX = amount of overlap along x-axis
                overlapY = amount of overlap along y-axis

                if overlapX < overlapY:
                    # Move along x-axis
                    move A left by overlapX / 2
                    move B right by overlapX / 2
                else:
                    # Move along y-axis
                    move A up by overlapY / 2
                    move B down by overlapY / 2

    return nodes
```

_If you are interested in a complete technical rundown and actual implementation, head
over to the [repository](https://github.com/xyflow/node-collision-algorithms)._

### Benchmarking

With the algorithm in place, the next step was to see how it actually performs. To do
that, we turned to [Vitest](https://vitest.dev/), which makes benchmarking surprisingly
straightforward with its [`bench`](https://vitest.dev/api/#bench) command based on
[tinybench](https://github.com/tinylibs/tinybench). All we had to do was create a new test
file ending in `bench.ts`, and we were good to go.

```ts
datasets.forEach((dataset) => {
  describe.concurrent(dataset, () => {
    bench(
      'naive',
      () => {
        naive(nodes, options);
      },
      benchOptions,
    );
  });
});
```

Running `vitest bench` for our naive algorithm gave us the following mean results on a
14-Core M4 Pro for resolving collisions on different datasets.

Separated (single iteration, no overlaps)

- 15 nodes: **~0.3¬µs**
- 100 nodes: **~8¬µs**
- 500 nodes: **~0.2ms**

Clustered (separated clusters, few overlaps)

- 15 nodes: 5 iterations **~0.7¬µs**
- 100 nodes: 9 iterations **~0.5ms**
- 500 nodes: 9 iterations **~1.1ms**

Packed (many overlaps, tightly packed)

- 15 nodes: 12 iterations **~2¬µs**
- 100 nodes: 80 iterations **~0.5ms**
- 500 nodes: 618 iterations **~150ms**

**Spoiler Alert:** It turns out we may have just created a blazingly fast algorithm ‚Äî one
that‚Äôs going to be pretty hard to beat.

### Putting results into perspective

To understand these results, it helps to consider when the algorithm actually runs. This
function isn‚Äôt running continuously or on every frame; it only executes when a node is
dropped or when changes are submitted. That means runtimes in the millisecond range are
acceptable. Looking at the data, we can see:

- There should never be any issues if you're working with fewer than 500 nodes.
- At around 500 clustered nodes, the algorithm resolves in ~1.1 ms. This is acceptable for
  most use cases.
- Resolving more than 500 nodes simultaneously can lead to noticeable performance issues,
  but this is mostly limited to edge cases, like pasting a large number of nodes into an
  already tightly packed flow.

**Note:** This benchmark was run on a processor with a very high single-core performance
and we will test on more representative machines in the future.

### Choosing the right datasets

Of course, raw numbers only tell part of the story. To get meaningful insights, your
benchmark datasets need to reflect realistic scenarios. Testing on an absurdly large
number of nodes ‚Äî kind of like running a Kubernetes cluster for a website with ten monthly
visitors (one of them being my mum) ‚Äî doesn‚Äôt tell you much about everyday performance.

If, for instance, 95% of your flows contain fewer than 25 nodes, your benchmarks should
focus on that reality. The same logic applies to overlap density: in most cases, nodes
aren‚Äôt so tightly packed that resolving one overlap will trigger a cascade of movements.
Including datasets with reasonable spacing, as well as a dataset with no overlaps, gives
you both a baseline and a realistic range of performance.

Here‚Äôs an overview of what our synthetic data looks like:

```text
+----------------+----------------+----------------+----------------+
|                | Separated      | Clustered      | Packed         |
+----------------+----------------+----------------+----------------+
| 15 Nodes       |  ‚Ä¢          ‚Ä¢  |  ‚Ä¢‚Ä¢            |        ‚Ä¢‚Ä¢      |
|                |                |           ‚Ä¢‚Ä¢   |       ‚Ä¢‚Ä¢‚Ä¢      |
|                |         ‚Ä¢      |      ‚Ä¢‚Ä¢        |       ‚Ä¢‚Ä¢       |
+----------------+----------------+----------------+----------------+
| 100 Nodes      | ‚Ä¢  ‚Ä¢   ‚Ä¢   ‚Ä¢   |  ‚Ä¢‚Ä¢         ‚Ä¢‚Ä¢ |     ‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢    |
|                |   ‚Ä¢     ‚Ä¢   ‚Ä¢  |    ‚Ä¢‚Ä¢   ‚Ä¢‚Ä¢     |     ‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢     |
|                | ‚Ä¢   ‚Ä¢   ‚Ä¢   ‚Ä¢  |  ‚Ä¢‚Ä¢         ‚Ä¢‚Ä¢ |      ‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢    |
+----------------+----------------+----------------+----------------+
| 500 Nodes      | ‚Ä¢ ‚Ä¢ ‚Ä¢ ‚Ä¢ ‚Ä¢ ‚Ä¢ ‚Ä¢  | ‚Ä¢‚Ä¢  ‚Ä¢‚Ä¢  ‚Ä¢‚Ä¢  ‚Ä¢‚Ä¢ | ‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢  |
|                |  ‚Ä¢ ‚Ä¢ ‚Ä¢ ‚Ä¢ ‚Ä¢ ‚Ä¢   |   ‚Ä¢‚Ä¢  ‚Ä¢‚Ä¢  ‚Ä¢‚Ä¢   | ‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢  |
|                | ‚Ä¢ ‚Ä¢ ‚Ä¢ ‚Ä¢ ‚Ä¢ ‚Ä¢ ‚Ä¢  | ‚Ä¢‚Ä¢  ‚Ä¢‚Ä¢  ‚Ä¢‚Ä¢  ‚Ä¢‚Ä¢ | ‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢  |
+----------------+----------------+----------------+----------------+
```

We like to use real-world data to benchmark whenever possible. As humble library authors,
we don‚Äôt have access to production datasets‚Ä¶ but _maybe you_ can help us out!

If you‚Äôd like to see your own data included, it‚Äôs super easy: just open a pull request and
add an array of trimmed-down nodes like this:

```ts
{ position: { x: number, y: number }, width: number, height: number }[]
```

### Optimizing with quadtree-ts, rbush and flatbush

The easiest way to optimize **O(n¬≤)** algorithms is to reduce the effective **n**.
Ideally, we‚Äôd get it down to **O(n log n)**, or, if we‚Äôre lucky, even **O(log n)**.

Right now, our solution compares every node with every other node ‚Äî not exactly a
performance dream. Luckily, this scenario is a perfect fit for ‚ú® Spatial Acceleration
Structures ‚ú®.

These clever data structures trade some upfront computation for the ability to make very
fast spatial queries later. Examples of such queries include:

‚ÄúWhich are the 10 closest neighbors of node X?‚Äù

‚ÄúWhich nodes lie within region X?‚Äù

By limiting the number of comparisons we make at each step, these structures can
drastically reduce the number of overlap checks required, making large flows much more
manageable.

In our [showcase](https://node-collision-algorithms.vercel.app/), you can choose from
several other algorithms to compare performance and see how different approaches behave.
Here are a few we included and the benefits each brings:

[**quadtree-ts**](https://github.com/timohausmann/quadtree-ts) uses **quadtrees**, which
recursively subdivides space and stores only a limited number of nodes in each leaf,
allowing for fast queries of nearby nodes.

Both [**RBush**](https://github.com/mourner/rbush) and
[**Flatbush**](https://github.com/mourner/flatbush) are implementations of
[**packed Hilbert R-trees**](https://en.wikipedia.org/wiki/Hilbert_R-tree#Packed_Hilbert_R-trees).
The difference is that **Flatbush** is entirely static ‚Äî individual nodes cannot be
updated ‚Äî but it stores its data in a single array buffer, making it extremely efficient
for memory usage and data transfer between threads.

In short, instead of checking every pair of nodes in an **O(n¬≤)** loop, we can leverage a
spatial acceleration structure to iterate only over relevant overlaps like this:

```diff
- for each pair of nodes (A, B):
-    if A and B overlap (considering margin):
+ for each node (A):
+    for every overlapping node (B):
```

### Wrapping up

We‚Äôre so grateful to the community and thrilled by all the buzz around node-based UIs
right now. This work is our passion, and it‚Äôs amazing to see what everyone is building
with these tools.

Our naive solution works surprisingly well, but we know it can be improved. If anyone
wants to take a crack at making it faster or smarter, we‚Äôd love to see it!

If you‚Äôd like a more technical rundown of our implementation, feel free to check out the
[GitHub repository](https://github.com/xyflow/node-collision-algorithms) ‚Äî we‚Äôd love your
feedback and contributions!
